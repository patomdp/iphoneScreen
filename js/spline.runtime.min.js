
SPE.QualityModifiers = {
    'SphereGeometry': {
        'widthSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 128
         },
         'heightSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 128
         },
    },
    'CubeGeometry': {
        'cornerSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 128
         }
    },
    'ConeGeometry': {
        'radialSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 64
        },
        'heightSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 64
        },
        'cornerSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 64
        }
    },
    'CylinderGeometry': {
        'radialSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 64
        },
        'cornerSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 64
        }
    },
    'EllipseGeometry': {
        'spikes': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 64
        }
    },
    'PolygonGeometry': {
        'extrudeBevelSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 16
        }
    },
    'RectangleGeometry': {
        'extrudeBevelSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 16
        }
    },
    'StarGeometry': {
        'extrudeBevelSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 16
        }
    },
    'TorusGeometry': {
        'radialSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 64
        },
        'tubularSegments': {
            'scalers': { 'high': 2, 'middle': 1, 'low': 0.5, 'default': 1 },
            'minValue': 1,
            'maxValue': 128
        }
    },
}
/// WebGL related constants ************************************************************************

const UNSIGNED_BYTE = 5121;
const UNSIGNED_SHORT = 5123;
const UNSIGNED_INT = 5125;
const FLOAT = 5126;

const ARRAY_BUFFER = 34962;
const ELEMENT_ARRAY_BUFFER = 34963;

/// Spline-layer related constants *****************************************************************

const SPE_LAYER_TYPE_LIGHTING = 'light';
const SPE_LAYER_TYPE_COLOR = 'color';
const SPE_LAYER_TYPE_GRADIENT = 'gradient';
const SPE_LAYER_TYPE_NORMAL = 'normal';
const SPE_LAYER_TYPE_DEPTH = 'depth';
const SPE_LAYER_TYPE_TEXTURE = 'texture';
const SPE_LAYER_TYPE_NOISE = 'noise';
const SPE_LAYER_TYPE_FRESNEL = 'fresnel';
const SPE_LAYER_TYPE_POINTS = 'points';
const SPE_LAYER_TYPE_LINES = 'lines';

const SPE_LAYER_UNIFORM_TYPE_BOOL = 0;
const SPE_LAYER_UNIFORM_TYPE_INT = 1;
const SPE_LAYER_UNIFORM_TYPE_FLOAT = 2;
const SPE_LAYER_UNIFORM_TYPE_VEC2 = 3;
const SPE_LAYER_UNIFORM_TYPE_VEC3 = 4;
const SPE_LAYER_UNIFORM_TYPE_VEC4 = 5;
const SPE_LAYER_UNIFORM_TYPE_COLOR = 6;
const SPE_LAYER_UNIFORM_TYPE_ARRAY_INT = 7;
const SPE_LAYER_UNIFORM_TYPE_ARRAY_FLOAT = 8;
const SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC2 = 9;
const SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC3 = 10;
const SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC4 = 11;
const SPE_LAYER_UNIFORM_TYPE_ARRAY_COLOR = 12;
const SPE_LAYER_UNIFORM_TYPE_MAT3 = 13;
const SPE_LAYER_UNIFORM_TYPE_MAT4 = 14;
const SPE_LAYER_UNIFORM_TYPE_SAMPLER_2D = 15;

/// Spline available renderable types **************************************************************

const SPE_RENDERABLE_MESH3D = 0;
const SPE_RENDERABLE_MESH2D = 1;
const SPE_RENDERABLE_TEXT = 2;
const SPE_RENDERABLE_RIGGING = 3;

/// Spline material constatns **********************************************************************

const SPE_MATERIAL_SIDE_FRONT = 0;
const SPE_MATERIAL_SIDE_BACK = 1;
const SPE_MATERIAL_SIDE_BOTH = 2;

const SPE_COLOR_MAIN_BLUE = 0x349BFC;
const SPE_COLOR_DEFAULT = 0x7A7A7A;
const SPE_COLOR_RED = 0xFD5B5D;
const SPE_COLOR_GREEN = 0x5EE25D;
const SPE_COLOR_PURPLE = 0xC94CFF;
const SPE_COLOR_PINK = 0xFF75F7;
const SPE_COLOR_YELLOW = 0xEFBC22;
const SPE_COLOR_GRAY_DARK = 0x6C6C6C;
const SPE_COLOR_BLACK = 0x6C6C6C;

/// Spline text-related constants ******************************************************************

const SPE_TEXT_VERTICAL_ALIGN_TOP = 1;
const SPE_TEXT_VERTICAL_ALIGN_MIDDLE = 2;
const SPE_TEXT_VERTICAL_ALIGN_BOTTOM = 3;

const SPE_TEXT_HORIZONTAL_ALIGN_LEFT = 1;
const SPE_TEXT_HORIZONTAL_ALIGN_RIGHT = 2;
const SPE_TEXT_HORIZONTAL_ALIGN_CENTER = 3;
const SPE_TEXT_HORIZONTAL_ALIGN_JUSTIFY = 4;

const SPE_TEXT_TRANSFORM_STANDARD = 1;
const SPE_TEXT_TRANSFORM_UPPERCASE = 2;
const SPE_TEXT_TRANSFORM_LOWERCASE = 3;

const SPE_TEXT_TRAVELDIR_TO_RIGHT = 1;
const SPE_TEXT_TRAVELDIR_TO_LEFT = -1;

/// Spline available blending modes ****************************************************************

const SPE_BLENDING_NORMAL = 0;
const SPE_BLENDING_MULTIPLY = 1;
const SPE_BLENDING_SCREEN = 2;
const SPE_BLENDING_OVERLAY = 3;

/// Spline runtime view-modes **********************************************************************

const SPE_RUNTIME_VIEWMODE_FULLSCREEN = 1;
const SPE_RUNTIME_VIEWMODE_CUSTOM_SIZE = 2;
const SPE_RUNTIME_VIEWMODE_FULL_WIDTH = 3;
const SPE_RUNTIME_VIEWMODE_FULL_HEIGHT = 4;

/// Spline runtime mesh-quality modifiers **********************************************************

const SPE_RUNTIME_QUALITY_HIGH = 'high';
const SPE_RUNTIME_QUALITY_MIDDLE = 'middle';
const SPE_RUNTIME_QUALITY_LOW = 'low';
const SPE_RUNTIME_QUALITY_DEFAULT = 'default';
class SpeGltfDecoder {

    constructor( gltfSceneGraph ) {
        this.mGltfSceneGraph = gltfSceneGraph;
        this.mSceneGraph = null;
        this.mSceneCamera = null;
        this.mSceneOptions = {};
        this.mNodes = [];
        this.mCameras = [];
        this.mLights = [];
        this.mGeometries = [];
        this.mGeometriesSpe = [];
        this.mAccessors = [];
        this.mMaterials = [];
    }

    decode( gltfSceneGraph ) {
        if ( gltfSceneGraph ) {
            this.mGltfSceneGraph = gltfSceneGraph;
        }

        // Restart the three.js scene-graph
        this.mSceneGraph = new SpeScene();
        this.mSceneCamera = null;
        this.mSceneOptions = {};
        this.mNodes = [this.mSceneGraph]; // first node represents the scene
        this.mObjects = {}; // Map for objects based on its uuid
        this.mCameras = [];
        this.mLights = [];
        this.mGeometries = [];
        this.mGeometriesSpe = [];
        this.mAccessors = [];
        this.mMaterials = [];
        this.mInteractionStates = {};

        /* Grab the spline options encoded in the editor ******************************************/
        if ( this.mGltfSceneGraph.spline !== undefined ) {
            this.mSceneOptions['usePrimitives'] = ( this.mGltfSceneGraph.spline.usePrimitives !== undefined ) ?
                                                        this.mGltfSceneGraph.spline.usePrimitives : true;
            this.mSceneOptions['useOrbitControls'] = ( this.mGltfSceneGraph.spline.useOrbitControls !== undefined ) ?
                                                            this.mGltfSceneGraph.spline.useOrbitControls : true;
            this.mSceneOptions['bgColor'] = ( this.mGltfSceneGraph.spline.bgColor !== undefined ) ? 
                                                this.mGltfSceneGraph.spline.bgColor : new THREE.Color( 0x191919 );
            this.mSceneOptions['bgAlpha'] = ( this.mGltfSceneGraph.spline.bgAlpha !== undefined ) ?
                                                this.mGltfSceneGraph.spline.bgAlpha : 0;
            this.mSceneOptions['orbitDamped'] = ( this.mGltfSceneGraph.spline.orbitDamped !== undefined ) ?
                                                    this.mGltfSceneGraph.spline.orbitDamped : false;
            this.mSceneOptions['orbitTarget'] = ( this.mGltfSceneGraph.spline.orbitTarget !== undefined ) ?
                                                    this.mGltfSceneGraph.spline.orbitTarget : [0, 0, 0];
            this.mSceneOptions['cameraType'] = ( this.mGltfSceneGraph.spline.cameraType !== undefined ) ?
                                                    this.mGltfSceneGraph.spline.cameraType : 'Orthographic';
            this.mSceneOptions['cameraRotate'] = ( this.mGltfSceneGraph.spline.cameraRotate !== undefined ) ?
                                                    this.mGltfSceneGraph.spline.cameraRotate : true;
            this.mSceneOptions['cameraPan'] = ( this.mGltfSceneGraph.spline.cameraPan !== undefined ) ?
                                                    this.mGltfSceneGraph.spline.cameraPan : true;
            this.mSceneOptions['cameraZoom'] = ( this.mGltfSceneGraph.spline.cameraZoom !== undefined ) ?
                                                    this.mGltfSceneGraph.spline.cameraZoom : true;
            this.mSceneOptions['viewMode'] = ( this.mGltfSceneGraph.spline.viewMode !== undefined ) ?
                                                    this.mGltfSceneGraph.spline.viewMode : SPE_RUNTIME_VIEWMODE_FULLSCREEN;
            this.mSceneOptions['viewWidth'] = ( this.mGltfSceneGraph.spline.viewWidth !== undefined ) ?
                                                    this.mGltfSceneGraph.spline.viewWidth : 1024;
            this.mSceneOptions['viewHeight'] = ( this.mGltfSceneGraph.spline.viewHeight !== undefined ) ?
                                                    this.mGltfSceneGraph.spline.viewHeight : 768;
            this.mSceneOptions['quality'] = ( this.mGltfSceneGraph.spline.quality !== undefined ) ?
                                                this.mGltfSceneGraph.spline.quality : SPE_RUNTIME_QUALITY_DEFAULT;
        }
        /******************************************************************************************/
        const INTERACTIONS_ENABLED = ( typeof Interaction === 'function' );

        if ( INTERACTIONS_ENABLED ) {
            // @hack: (interaction module) parse resources required by this module *********************
            // @hack: (interaction-module) Parse images into SPE's image-cache
            SPE.CachedImages = {};
            if ( this.mGltfSceneGraph.spline && this.mGltfSceneGraph.spline.images ) {
                const images = this.mGltfSceneGraph.spline.images;
                for ( const [id, data] of Object.entries( images ) ) {
                    const image = new Image();
                    image.src = data.url;
                    SPE.CachedImages[id] = image;
                }
            }
            // @hack: (interaction-module) Parse textures into SPE's texture cache
            SPE.CachedTextures = {};
            if ( this.mGltfSceneGraph.spline && this.mGltfSceneGraph.spline.textures ) {
                const textures = this.mGltfSceneGraph.spline.textures;
                for ( const [id, data] of Object.entries( textures ) ) {
                    const image_id = data.image;
                    const image_data = SPE.CachedImages[image_id];
                    const texture = new THREE.Texture( image_data,
                                                       data.mapping, data.wrap[0], data.wrap[1],
                                                       data.magFilter, data.minFilter, data.format,
                                                       data.type, data.anisotropy, data.encoding );
                    texture.offset.fromArray( data.offset );
                    texture.repeat.fromArray( data.repeat );
                    texture.center.fromArray( data.center );
                    texture.updateMatrix();
                    SPE.CachedTextures[id] = texture;
                }
            }

            if ( this.mGltfSceneGraph.spline && this.mGltfSceneGraph.spline.interactionStates ) {
                const interactionStates = this.mGltfSceneGraph.spline.interactionStates;
                const textures = this.mGltfSceneGraph.spline.textures;
                for ( const [id, data] of Object.entries( interactionStates ) ) {
                    this.mInteractionStates[id] = new InteractionState().fromJSON( data, SPE.CachedTextures );
                }
            }
        }
        // *****************************************************************************************

        /* Decode all elements stored in the scene description ************************************/
        const cameras = this.mGltfSceneGraph['cameras'] || [];
        for ( let i = 0; i < cameras.length; i++ ) {
            this._decodeCamera( cameras[i] );
        }

        if ( this.mGltfSceneGraph.extensions && this.mGltfSceneGraph.extensions.KHR_lights_punctual &&
             this.mGltfSceneGraph.extensions.KHR_lights_punctual.lights ) {
            const lights = this.mGltfSceneGraph['extensions']['KHR_lights_punctual']['lights'];
            for ( let i = 0; i < lights.length; i++ ) {
                this._decodeLight( lights[i] );
            }
        }

        // Constructs the buffers from the given buffers|bufferViews|accessors encoded information
        this._constructGeometricData();

        const materials = this.mGltfSceneGraph['materials'] || [];
        for ( let i = 0; i < materials.length; i++ ) {
            this._decodeMaterial( materials[i] );
        }

        const meshes_spe = this.mGltfSceneGraph['meshes_spe'] || [];
        for ( let i = 0; i < meshes_spe.length; i++ ) {
            this._decodeSpeGeometry( meshes_spe[i] );
        }

        const meshes = this.mGltfSceneGraph['meshes'] || [];
        for ( let i = 0; i < meshes.length; i++ ) {
            this._decodeGeometry( meshes[i] );
        }

        const nodes = this.mGltfSceneGraph['nodes'] || [];
        for ( let i = 1; i < nodes.length; i++ ) { // first node is always scene
            this._decodeNode( nodes[i] );
        }

        if ( INTERACTIONS_ENABLED ) {
            if ( this.mGltfSceneGraph.spline && this.mGltfSceneGraph.spline.interactions ) {
                const interactions = this.mGltfSceneGraph.spline.interactions;
                for ( let i = 0; i < nodes.length; i++ ) {
                    const nodeDesc = nodes[i];
                    if ( nodeDesc.spe_interaction !== undefined && nodeDesc.spe_interaction !== null ) {
                        const interaction_indx = nodeDesc.spe_interaction;
                        if ( interaction_indx < interactions.length && interaction_indx >= 0 ) {
                            const data = interactions[interaction_indx];
                            const states = this.mInteractionStates;
                            const objects = this.mObjects;
                            this.mNodes[i].interaction.fromJSON( data, objects, states );
                        }
                    }
                }
            }
        }
        /******************************************************************************************/

        /* Construct the graph using the nodes parsed above ***************************************/
        const root_node = this.mGltfSceneGraph['nodes'][0];
        const dfs_stack = new SpeStack();
        for ( let i = 0; i < root_node.children.length; i++ ) {
            dfs_stack.push( [root_node.children[i], this.mSceneGraph] );
        }

        while ( !dfs_stack.empty() ) {
            const element = dfs_stack.pop();
            const node_index = element[0];
            const node_parent = element[1];

            // Create the node for the given node description
            if ( node_index < this.mNodes.length && node_index >= 0 ) {
                const node = this.mNodes[node_index];
                if ( !node ) {
                    continue;
                }
                if ( node_parent ) {
                    node_parent.add( node );
                }

                const node_children = this.mGltfSceneGraph['nodes'][node_index]['children'];
                if ( node_children !== undefined ) {
                    for ( let i = 0; i < node_children.length; i++ ) {
                        dfs_stack.push( [node_children[i], node] );
                    }
                }
            }
        }
        /******************************************************************************************/

        /* Setup fog if enabled in the scene ******************************************************/
        if ( this.mGltfSceneGraph.spline !== undefined ) {
            if ( this.mGltfSceneGraph.spline.fog ) {
                const fog_options = this.mGltfSceneGraph.spline.fog;
                const fog_color = ( fog_options.color !== undefined ) ? fog_options.color : 0xffffff;
                const fog_near = ( fog_options.near !== undefined ) ? fog_options.near : 500;
                const fog_far = ( fog_options.far !== undefined ) ? fog_options.far : 2000;
                this.mSceneGraph.fog = new THREE.Fog( fog_color, fog_near, fog_far );
            }
        }

        /******************************************************************************************/

        /* Grab the main camera (if encoded) ******************************************************/
        if ( this.mGltfSceneGraph.spline !== undefined ) {
            if ( this.mGltfSceneGraph.spline.mainCameraIndex !== undefined ) {
                const mainCameraIndex = this.mGltfSceneGraph.spline.mainCameraIndex;
                if ( mainCameraIndex < this.mNodes.length && mainCameraIndex >= 0 ) {
                    this.mSceneCamera = this.mNodes[mainCameraIndex];
                }
            }
        }
        /******************************************************************************************/

        return [this.mSceneGraph, this.mSceneCamera, this.mSceneOptions];
    }

    _decodeCamera( cameraDesc ) {
        let cam_type = ( cameraDesc.type !== undefined ) ? cameraDesc.type : 'Perspective';
        let cam_width = 100;
        let cam_height = 100;
        let cam_fov = 45;
        let cam_aspect = 1;
        let cam_near = 0.1;
        let cam_far = 50000;
        let camera = null;

        /**/ if ( cam_type === 'Perspective' ) {
            const params = ( cameraDesc.perspective ) ? cameraDesc.perspective : {};
            const params_spe = ( cameraDesc.spe_options ) ? cameraDesc.spe_options : {};

            cam_fov = ( params.yfov !== undefined ) ? params.yfov : 45;
            cam_aspect = ( params.aspectRatio !== undefined ) ? params.aspectRatio : 1.0;
            cam_near = ( params.znear !== undefined ) ? params.znear : 0.1;
            cam_far = ( params.zfar !== undefined ) ? params.zfar : 50000;

            camera = new SPE.CombinedCamera( cam_width, cam_height, cam_fov, cam_near, cam_far );
            camera.toPerspective();

            const cam_zoom = ( params_spe.zoom !== undefined ) ? params_spe.zoom : 1;
            camera.zoom = cam_zoom;
        }
        else if ( cam_type === 'Orthographic' ) {
            const params = ( cameraDesc.orthographic ) ? cameraDesc.orthographic : {};
            const params_spe = ( cameraDesc.spe_options ) ? cameraDesc.spe_options : {};

            cam_width = ( params.xmag !== undefined ) ? params.xmag : 100;
            cam_height = ( params.ymag !== undefined ) ? params.ymag : 100;
            cam_near = ( params.znear !== undefined ) ? params.znear : 0.1;
            cam_far = ( params.zfar !== undefined ) ? params.zfar : 50000;

            camera = new SPE.CombinedCamera( cam_width, cam_height, cam_fov, cam_near, cam_far );
            camera.toOrthographic();

            const cam_zoom = ( params_spe.zoom !== undefined ) ? params_spe.zoom : 1;
            camera.zoom = cam_zoom;
        }
        else {
            console.warn( `SpeGltfDecoder::_decodeCamera >>> unsupported camera type: ${cam_type}. Using Orthographic instead` );
            camera = new SPE.CombinedCamera( cam_width, cam_height, cam_fov, cam_near, cam_far );
            camera.toOrthographic();
        }
        this.mCameras.push( camera );
    }

    _decodeLight( lightDesc ) {
        /**/ if ( lightDesc['type'] === 'hemispheric' ) {
            const color = new THREE.Color().fromArray( ( lightDesc.color !== undefined ) ? lightDesc.color : [ 1., 1., 1. ] );
            const groundColor = new THREE.Color().setHex( 0x828282 );
            const intensity = ( lightDesc.intensity ) ? lightDesc.intensity : 1;
            this.mLights.push( new THREE.HemisphereLight( color, groundColor, intensity ) );
        }
        else if ( lightDesc['type'] === 'directional' ) {
            const light = new SPE.LightDirectional( new THREE.Color().fromArray( lightDesc['color'] ),
                                                      lightDesc['intensity'] );
            const shadowParams = lightDesc.shadows || {};
            light.castShadow = ( shadowParams.castShadow !== undefined ) ? shadowParams.castShadow : false;
            light.shadow.camera.right = ( shadowParams.shadowmapViewRight !== undefined ) ? shadowParams.shadowmapViewRight : 1250;
            light.shadow.camera.left = ( shadowParams.shadowmapViewLeft !== undefined ) ? shadowParams.shadowmapViewLeft : -1250;
            light.shadow.camera.top = ( shadowParams.shadowmapViewTop !== undefined ) ? shadowParams.shadowmapViewTop : 1250;
            light.shadow.camera.bottom = ( shadowParams.shadowmapViewBottom !== undefined ) ? shadowParams.shadowmapViewBottom : -1250;
            light.shadow.camera.near = ( shadowParams.shadowmapViewNear !== undefined ) ? shadowParams.shadowmapViewNear : 1;
            light.shadow.camera.far = ( shadowParams.shadowmapViewFar !== undefined ) ? shadowParams.shadowmapViewFar : 2500;

            this.mLights.push( light );
        }
        else if ( lightDesc['type'] === 'point' ) {
            const color = new THREE.Color().fromArray( ( lightDesc.color !== undefined ) ? lightDesc.color : [ 1., 1., 1. ] );
            const intensity = ( lightDesc.intensity ) ? lightDesc.intensity : 1;
            const distance = ( lightDesc.range !== undefined ) ? lightDesc.range : 0;
            const decay = ( lightDesc.decay !== undefined ) ? lightDesc.decay : 1;

            const light = new SPE.LightPoint( color, intensity, distance, decay );
            const shadowParams = lightDesc.shadows || {};
            light.castShadow = ( shadowParams.castShadow !== undefined ) ? shadowParams.castShadow : false;
            light.shadow.camera.near = ( shadowParams.shadowmapViewNear !== undefined ) ? shadowParams.shadowmapViewNear : 1;
            light.shadow.camera.far = ( shadowParams.shadowmapViewFar !== undefined ) ? shadowParams.shadowmapViewFar : 2500;

            this.mLights.push( light );
        }
        else if ( lightDesc['type'] === 'spot' ) {
            const color = new THREE.Color().fromArray( ( lightDesc.color !== undefined ) ? lightDesc.color : [ 1., 1., 1. ] );
            const intensity = ( lightDesc.intensity ) ? lightDesc.intensity : 1;
            const distance = ( lightDesc.range !== undefined ) ? lightDesc.range : 0;
            const decay = ( lightDesc.decay !== undefined ) ? lightDesc.decay : 1;
            const angle = ( lightDesc.innerConeAngle !== undefined ) ? lightDesc.innerConeAngle : Math.PI / 3;
            const penumbra = ( lightDesc.penumbra !== undefined ) ? lightDesc.penumbra : 0;

            const light = new SPE.LightSpot( color, intensity, distance, angle, penumbra, decay );
            const shadowParams = lightDesc.shadows || {};
            light.castShadow = ( shadowParams.castShadow !== undefined ) ? shadowParams.castShadow : false;
            light.shadow.camera.fov = ( shadowParams.shadowmapViewFov !== undefined ) ? shadowParams.shadowmapViewFov : THREE.MathUtils.RAD2DEG * 2 * angle;
            light.shadow.camera.near = ( shadowParams.shadowmapViewNear !== undefined ) ? shadowParams.shadowmapViewNear : 1;
            light.shadow.camera.far = ( shadowParams.shadowmapViewFar !== undefined ) ? shadowParams.shadowmapViewFar : 2500;

            this.mLights.push( light );
        }
        else {
            console.error( 'SpeGltfDecoder::_decodeLight >>> unsupported light type: ', lightDesc.type );
        }
    }

    _constructGeometricData() {
        // Decode the buffer data to be used for the buffer-views **********************************
        const buffersDesc = this.mGltfSceneGraph['buffers'];
        const buffers = []; // stores uint8 array buffers
        for ( let i = 0; i < buffersDesc.length; i++ ) {
            buffers.push( this._decodeBuffer( buffersDesc[i] ) );
        }
        // *****************************************************************************************

        // Decode the bufferViews to be used for the accessors *************************************
        const bufferViewsDesc = this.mGltfSceneGraph['bufferViews'];
        const bufferViews = [];
        for ( let i = 0; i < bufferViewsDesc.length; i++ ) {
            bufferViews.push( this._decodeBufferView( bufferViewsDesc[i], buffers ) );
        }
        // *****************************************************************************************

        // Decode the accessors and create the appropriate geometry-data ***************************
        const accessorsDesc = this.mGltfSceneGraph['accessors'];
        for ( let i = 0; i < accessorsDesc.length; i++ ) {
            this.mAccessors.push( this._decodeAccessor( accessorsDesc[i], bufferViews ) );
        }
        // *****************************************************************************************
    }

    _decodeBuffer( bufferDesc ) {
        const bytes_length = bufferDesc['byteLength'];
        const bytes_uri = bufferDesc['uri'];

        /**/ if ( bytes_uri.indexOf( 'base64' ) ) {
            // Grab base64 encoded data and decoded it to uint8 binary data
            const data_base64_str = bytes_uri.slice( bytes_uri.indexOf( 'base64' ) + 7 );
            const data_uint8_str = atob( data_base64_str );
            const data_uint8_buff = new Uint8Array( data_base64_str.length );
            for ( let i = 0; i < data_uint8_str.length; i++ ) {
                data_uint8_buff[i] = data_uint8_str.charCodeAt( i );
            }
            return { data: data_uint8_buff, length: bytes_length };
        }
        else if ( bytes_uri.indexOf( '.bin' ) ) {
            // @todo: grab data from binary file
            console.error( 'SpeGltfDecoder::_decodeBuffer >>> encode-from-.bin is not implement yet' );
            return '';
        }

        console.error( 'SpeGltfDecoder::_decodeBuffer >>> invalid options to parse buffer data' );
        return '';
    }

    _decodeBufferView( bufferViewDesc, buffers ) {
        const bytes_length = bufferViewDesc['byteLength'];
        const bytes_offset = bufferViewDesc['byteOffset'];
        const buffer_index = bufferViewDesc['buffer'];
        const buffer_target = bufferViewDesc['target'];
        if ( buffer_index < buffers.length && buffer_index >= 0 ) {
            const bytes = buffers[buffer_index]['data'].slice( bytes_offset, bytes_offset + bytes_length );
            return { data: bytes, length: bytes_length, target: buffer_target };
        }
        console.error( 'SpeGltfDecoder::_decodeBufferView >>> index-out-of-range in buffers array' );
        return {};
    }

    _decodeAccessor( accessorDesc, bufferViews ) {
        const buffer_view_index = accessorDesc['bufferView'];
        const bytes_offset = accessorDesc['byteOffset'];
        const component_type = accessorDesc['componentType']; // FLOAT, UNSIGNED_SHORT, ...
        const count = accessorDesc['count'];
        const type = accessorDesc['type']; // SCALAR, VEC2, VEC3, VEC4, MAT4, ...
        if ( buffer_view_index < bufferViews.length && buffer_view_index >= 0 ) {
            const buffer_view = bufferViews[buffer_view_index];
            const buffer_view_data = buffer_view['data'];
            const item_size = this._getAccessorItemSize( type );
            const component_size = this._getAccessorComponentSize( component_type );
            const bytes_length = count * item_size * component_size;
            const bytes = buffer_view_data.slice( bytes_offset, bytes_offset + bytes_length );
            let buffer_data = null;
            /**/ if ( component_type === UNSIGNED_SHORT ) {
                buffer_data = this._createUint16Buffer( bytes );
            }
            else if ( component_type === UNSIGNED_INT ) {
                buffer_data = this._createUint32Buffer( bytes );
            }
            else if ( component_type === FLOAT ) {
                buffer_data = this._createFloat32Buffer( bytes );
            }

            if ( !buffer_data ) {
                console.error( 'SpeGltfDecoder::_decodeAccessor >>> invalid component-type given' );
                return null;
            }
            return this._createBufferAttribute( buffer_data, item_size );
        }
        console.error( 'SpeGltfDecoder::_decodeAccessor >>> index-out-of-range in bufferViews array' );
        return null;
    }

    _decodeMaterial( materialDesc ) {
        let [materialName, materialProps] = Object.entries( materialDesc )[0];
        if ( materialProps.extensions !== undefined && materialProps.extensions.KHR_materials_common !== undefined ) {
            this._decodeSimpleMaterial( materialProps.extensions.KHR_materials_common, materialProps.spe_options, materialProps.spe_layers );
        }
        else {
            this._decodePbrMaterial( materialProps );
        }
    }

    _decodeSimpleMaterial( materialProps, materialOptions, materialLayers ) {
        const material_type = materialProps['technique'] || 'PHONG';
        const material_values = materialProps['values'] || {};
        const material_options = materialOptions || {};
        const material_layers = materialLayers || {};
        /**/ if ( material_type === 'PHONG' ) {
            const color = new THREE.Color().fromArray( ( material_values.diffuse !== undefined ) ?  material_values.diffuse : [ 0.5, 0.5, 0.5 ] );
            const specular = new THREE.Color().fromArray( ( material_values.specular !== undefined ) ? material_values.specular : [ 0.5, 0.5, 0.5 ] );
            const emissive = new THREE.Color().fromArray( ( material_values.emission !== undefined ) ? material_values.emission : [ 0.0, 0.0, 0.0 ] );
            const shininess = ( material_values.shininess !== undefined ) ? material_values.shininess : 32.0;
            const transparent = ( material_values.transparent !== undefined ) ? material_values.transparent : false;
            const opacity = ( material_values.transparency !== undefined ) ? material_values.transparency : 1.0;
            const visible = ( material_options.visible !== undefined ) ? material_options.visible : true;
            const wireframe = ( material_options.wireframe !== undefined ) ? material_options.wireframe : false;
            const side = ( material_options.side !== undefined ) ? material_options.side : THREE.FrontSide;
            const flatShading = ( material_options.flatShading !== undefined ) ? material_options.flatShading : false;
            const layers = material_layers;

            const materialObj = new SpePhongMaterial( layers, { color, specular, emissive, shininess, transparent, opacity, flatShading, side, wireframe, visible } );
            this.mMaterials.push( materialObj );
        }
        else if ( material_type === 'LAMBERT' ) {
            const color = new THREE.Color().fromArray( ( material_values.diffuse !== undefined ) ?  material_values.diffuse : [ 0.5, 0.5, 0.5 ] );
            const emissive = new THREE.Color().fromArray( ( material_values.emission !== undefined ) ? material_values.emission : [ 0.0, 0.0, 0.0 ] );
            const transparent = ( material_values.transparent !== undefined ) ? material_values.transparent : false;
            const opacity = ( material_values.transparency !== undefined ) ? material_values.transparency : 1.0;
            const visible = ( material_options.visible !== undefined ) ? material_options.visible : true;
            const wireframe = ( material_options.wireframe !== undefined ) ? material_options.wireframe : false;
            const side = ( material_options.side !== undefined ) ? material_options.side : THREE.FrontSide;
            const flatShading = ( material_options.flatShading !== undefined ) ? material_options.flatShading : false;
            const layers = material_layers;

            const materialObj = new SpeLambertMaterial( layers, { color, emissive, transparent, opacity, flatShading, side, wireframe, visible } );
            this.mMaterials.push( materialObj );
        }
        else if ( material_type === 'CONSTANT' ) {
            const color = new THREE.Color().fromArray( ( material_values.ambient !== undefined ) ?  material_values.ambient : [ 0.5, 0.5, 0.5 ] );
            const transparent = ( material_values.transparent !== undefined ) ? material_values.transparent : false;
            const opacity = ( material_values.transparency !== undefined ) ? material_values.transparency : 1.0;
            const visible = ( material_options.visible !== undefined ) ? material_options.visible : true;
            const wireframe = ( material_options.wireframe !== undefined ) ? material_options.wireframe : false;
            const side = ( material_options.side !== undefined ) ? material_options.side : THREE.FrontSide;
            const flatShading = ( material_options.flatShading !== undefined ) ? material_options.flatShading : false;
            const layers = material_layers;

            const materialObj = new SpeBasicMaterial( layers, { color, transparent, opacity, flatShading, side, wireframe, visible } );
            this.mMaterials.push( materialObj );
        }
        else if ( material_type === 'TOON' ) {
            const color = new THREE.Color().fromArray( ( material_values.ambient !== undefined ) ?  material_values.ambient : [ 0.5, 0.5, 0.5 ] );
            const transparent = ( material_values.transparent !== undefined ) ? material_values.transparent : false;
            const opacity = ( material_values.transparency !== undefined ) ? material_values.transparency : 1.0;
            const visible = ( material_options.visible !== undefined ) ? material_options.visible : true;
            const wireframe = ( material_options.wireframe !== undefined ) ? material_options.wireframe : false;
            const side = ( material_options.side !== undefined ) ? material_options.side : THREE.FrontSide;
            const flatShading = ( material_options.flatShading !== undefined ) ? material_options.flatShading : false;
            const layers = material_layers;

            const materialObj = new SpeToonMaterial( layers, { color, transparent, opacity, flatShading, side, wireframe, visible } );
            this.mMaterials.push( materialObj );
        }
        else if ( material_type === 'PHYSICAL' ) {
            const color = new THREE.Color().fromArray( ( material_values.ambient !== undefined ) ?  material_values.ambient : [ 0.5, 0.5, 0.5 ] );
            const transparent = ( material_values.transparent !== undefined ) ? material_values.transparent : false;
            const opacity = ( material_values.transparency !== undefined ) ? material_values.transparency : 1.0;
            const roughness = ( material_values.roughness !== undefined ) ? material_values.roughness : 0.3;
            const metalness = ( material_values.metalness !== undefined ) ? material_values.metalness : 0.0;
            const reflectivity = ( material_values.reflectivity !== undefined ) ? material_values.reflectivity : 0.5;
            const visible = ( material_options.visible !== undefined ) ? material_options.visible : true;
            const wireframe = ( material_options.wireframe !== undefined ) ? material_options.wireframe : false;
            const side = ( material_options.side !== undefined ) ? material_options.side : THREE.FrontSide;
            const flatShading = ( material_options.flatShading !== undefined ) ? material_options.flatShading : false;
            const layers = material_layers;

            const materialObj = new SpePhysicalMaterial( layers, { color, transparent, opacity, roughness, metalness, reflectivity, flatShading, side, wireframe, visible } );
            this.mMaterials.push( materialObj );
        }
        else if ( material_type === 'ARRAY' ) {
            const materials_techniques = ( material_values.techniques !== undefined ) ? material_values.techniques : new Array( material_layers.length ).fill( 'CONSTANT' );
            const materials_array = [];
            for ( let i = 0; i < material_layers.length; i++ ) {
                /**/ if ( materials_techniques[i] === 'CONSTANT' ) {
                    materials_array.push( new SpeBasicMaterial( material_layers[i], {} ) );
                }
                else if ( materials_techniques[i] === 'LAMBERT' ) {
                    materials_array.push( new SpeLambertMaterial( material_layers[i], {} ) );
                }
                else if ( materials_techniques[i] === 'PHONG' ) {
                    materials_array.push( new SpePhongMaterial( material_layers[i], {} ) );
                }
                else if ( materials_techniques[i] === 'TOON' ) {
                    materials_array.push( new SpeToonMaterial( material_layers[i], {} ) );
                }
                else if ( materials_techniques[i] === 'PHYSICAL' ) {
                    materials_array.push( new SpePhysicalMaterial( material_layers[i], {} ) );
                }
                else {
                    console.error( `SpeGltfDecoder::_decodeSimpleMaterial >>> unsupported technique (${materials_techniques[i]}) for element of array of materials` );
                    materials_array.push( new SpeBasicMaterial( material_layers[i], {} ) );
                }
            }
            this.mMaterials.push( materials_array );
        }
        else {
            console.error( 'SpeGltfDecoder::_decodeSimpleMaterial >>> unsupported material type: ', materialProps['technique'] );
        }
    }

    _decodePbrMaterial( materialProps ) {
        // @todo: implement when pbr materials are enabled
    }

    _decodeSpeGeometry( geometryDesc ) {
        const geom_type = ( geometryDesc.type !== undefined ) ? geometryDesc.type : 'SphereGeometry';
        const geom_params = this._applyQualityScalers( geom_type, ( geometryDesc.parameters !== undefined ) ? {...geometryDesc.parameters} : { width: 100, height: 100, depth: 100 } );

        if ( geom_type === 'CharacterGeometry' ) {
            // Call the char3d contruction helper function to place it in cache
            const char = ( geom_params.char !== undefined ) ? geom_params.char : '.';
            const fontFamily = ( geom_params.fontFamily !== undefined ) ? geom_params.fontFamily : 'roboto_regular';
            const lod = ( geom_params.lod !== undefined ) ? geom_params.lod : 1;
            SpeLoadCharData( char, fontFamily, lod ); // call stores it into cache
            // @dirty: storing character data directly
            this.mGeometriesSpe.push( geom_params );
        }
        else {
            const geom_buildfcn = SPE[geom_type].build;
            const geom = geom_buildfcn( geom_params );
            this.mGeometriesSpe.push( geom );
        }
    }

    _applyQualityScalers( geom_type, parameters ) {
        if ( SPE.QualityModifiers[geom_type] === undefined ) {
            return parameters;
        }

        const modified_parameters = {};
        const quality = this.mSceneOptions['quality'];

        for ( const [param_name, param_value] of Object.entries( parameters ) ) {
            if ( SPE.QualityModifiers[geom_type][param_name] === undefined ) {
                modified_parameters[param_name] = param_value;
                continue;
            }
            const minValue = SPE.QualityModifiers[geom_type][param_name].minValue;
            const maxValue = SPE.QualityModifiers[geom_type][param_name].maxValue;
            const scaler = SPE.QualityModifiers[geom_type][param_name].scalers[quality];
            modified_parameters[param_name] = Math.max( minValue, Math.min( maxValue, scaler * param_value ) );
        }
        return modified_parameters;
    }

    _decodeGeometry( geometryDesc ) {
        const primitives = geometryDesc['primitives'];
        const groups = geometryDesc['groups'];
        const parameters = geometryDesc['parameters'];
        // @todo: for now we're using only single-submesh meshes. Will add support for
        // multiple submesh objects later in the gltf encoder module for more complex objects
        const accessorsData = primitives[0];
        const indicesAccessor = accessorsData['indices'];
        const attribAccessors = accessorsData['attributes'];

        const index_buffer = this.mAccessors[indicesAccessor];
        const attribs_buffers = {};
        for ( let attribName in attribAccessors ) {
            attribs_buffers[attribName] = this.mAccessors[attribAccessors[attribName]];
        }

        const buffer_geometry = new THREE.BufferGeometry();
        if ( index_buffer ) {
            buffer_geometry.setIndex( index_buffer );
        }
        for ( let attribName in attribs_buffers ) {
            buffer_geometry.setAttribute( attribName.toLowerCase(), attribs_buffers[attribName] );
        }
        // If there's groups data, create groups for this buffer-geometry (multi-material mesh)
        if ( groups !== undefined ) {
            for ( let i = 0; i < groups.length; i++ ) {
                buffer_geometry.addGroup( groups[i]['start'], groups[i]['count'], groups[i]['materialIndex'] );
            }
        }
        if ( parameters !== undefined ) {
            const size = new THREE.Vector3();
            buffer_geometry.computeBoundingBox();
            buffer_geometry.boundingBox.getSize( size );
            // Setup as in the spline editor
            const width = ( parameters.width !== undefined ) ? parameters.width : size.x;
            const height = ( parameters.height !== undefined ) ? parameters.height : size.y;
            const depth = ( parameters.depth !== undefined ) ? parameters.depth : size.z;
            buffer_geometry.scale( ( Math.abs( size.x ) < 1e-5 ) ? 1 : width / size.x,
                                   ( Math.abs( size.y ) < 1e-5 ) ? 1 : height / size.y,
                                   ( Math.abs( size.z ) < 1e-5 ) ? 1 : depth / size.z )
            buffer_geometry.userData = { type: 'NonParametricGeometry', parameters: { width, height, depth } };
        }
        this.mGeometries.push( buffer_geometry );
    }

    _decodeNode( nodeDesc ) {
        /* Handle cameras setup in the scene as proper nodes */
        /**/ if ( nodeDesc.camera !== undefined ) {
            const camera_index = nodeDesc.camera;
            if ( camera_index < this.mCameras.length && camera_index >= 0 ) {
                const camera = this.mCameras[camera_index];
                camera.position.copy( new THREE.Vector3().fromArray( ( nodeDesc.translation ) ? nodeDesc.translation : [0., 0., 0.] ) );
                camera.quaternion.copy( new THREE.Quaternion().fromArray( ( nodeDesc.rotation ) ? nodeDesc.rotation : [0., 0., 0., 1.] ) );
                camera.hiddenMatrix.copy( new THREE.Matrix4().fromArray( ( nodeDesc.hiddenMatrix ) ? nodeDesc.hiddenMatrix : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] ) );
                camera.updateMatrix();
                this.mNodes.push( camera );

                const camera_uuid = ( nodeDesc.uuid !== undefined ) ? nodeDesc.uuid : THREE.MathUtils.generateUUID();
                this.mObjects[camera_uuid] = camera;
            }
            else {
                console.error( 'SpeGltfDecoder::_decodeNode >>> couldnt create node for associated camera (index out of bounds)' );
            }
        }
        /* Handle primitive meshes setup in the scene */
        else if ( nodeDesc.mesh_spe !== undefined ) {
            const geometry_index = nodeDesc.mesh_spe;
            let geometry = null;
            if ( geometry_index < this.mGeometriesSpe.length && geometry_index >= 0 ) {
                geometry = this.mGeometriesSpe[geometry_index];
            }
            else {
                console.warn( 'SpeGltfDecoder::_decodeNode >>> couldnt grab any associated geometry for a mesh-node (index out of bounds). Creating a default sphere instead' );
                geometry = new THREE.SphereBufferGeometry( 1.0, 10, 10 );
            }
            let material = null;
            if ( nodeDesc.material !== undefined ) {
                const material_index = nodeDesc.material;
                if ( material_index < this.mMaterials.length && material_index >= 0 ) {
                    material = this.mMaterials[material_index];
                }
                else {
                    console.warn( 'SpeGltfDecoder::_decodeNode >>> couldnt grab any associated material for a mesh-node (index out of bounds)' );
                }
            }
            if ( !material ) {
                console.error(  'SpeGltfDecoder::_decodeNode >>> mesh-node doesnt have a material. Creating a default phong-material instead' );
                material = new SpePhongMaterial( {}, { color: new THREE.Color( 0xffffff ), specular: new THREE.Color( 0xffffff ) } );
            }

            const mesh_type = ( nodeDesc.type !== undefined ) ? nodeDesc.type : 'mesh3d';
            let mesh = null;
            /**/ if ( mesh_type === 'mesh3d' ) {
                mesh = new SpeMesh3D( geometry, material );
            }
            else if ( mesh_type === 'mesh2d' ) {
                mesh = new SpeMesh2D( geometry, material );
            }
            else if ( mesh_type === 'text' ) {
                mesh = new SpeTextContainer( geometry, material );
            }
            else if ( mesh_type === 'character' ) {
                mesh = new SpeTextChar3D( geometry, material );
            }
            else {
                console.error( `SpeGltfDecoder::_decodeNode >>> mesh-type ${mesh_type} not supported` );
                mesh = new SpeMesh3D( geometry, material );
            }

            mesh.visible = ( nodeDesc.visible !== undefined ) ? nodeDesc.visible : true;
            mesh.castShadow = ( nodeDesc.castShadow !== undefined ) ? nodeDesc.castShadow : true;
            mesh.receiveShadow = ( nodeDesc.receiveShadow !== undefined ) ? nodeDesc.receiveShadow : true;
            mesh.position.copy( new THREE.Vector3().fromArray( ( nodeDesc.translation ) ? nodeDesc.translation : [0., 0., 0.] ) );
            mesh.quaternion.copy( new THREE.Quaternion().fromArray( ( nodeDesc.rotation ) ? nodeDesc.rotation : [0., 0., 0., 1.] ) );
            mesh.scale.copy( new THREE.Vector3().fromArray( ( nodeDesc.scale ) ? nodeDesc.scale : [1., 1., 1.] ) );
            mesh.hiddenMatrix.copy( new THREE.Matrix4().fromArray( ( nodeDesc.hiddenMatrix ) ? nodeDesc.hiddenMatrix : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] ) );
            mesh.updateMatrix();
            this.mNodes.push( mesh );

            const mesh_uuid = ( nodeDesc.uuid !== undefined ) ? nodeDesc.uuid : THREE.MathUtils.generateUUID();
            this.mObjects[mesh_uuid] = mesh;

            if ( nodeDesc.spe_cloner ) {
                mesh.cloner = new Cloner( mesh ).fromJSON( nodeDesc.spe_cloner_data );
                mesh.add( mesh.cloner );
            }
        }
        /* Handle non-parametric meshes setup in the scene */
        else if ( nodeDesc.mesh !== undefined ) {
            const geometry_index = nodeDesc.mesh;
            let geometry = null;
            if ( geometry_index < this.mGeometries.length && geometry_index >= 0 ) {
                geometry = this.mGeometries[geometry_index];
            }
            else {
                console.warn( 'SpeGltfDecoder::_decodeNode >>> couldnt grab any associated geometry for a mesh-node (index out of bounds). Creating a default sphere instead' );
                geometry = new THREE.SphereBufferGeometry( 1.0, 10, 10 );
            }
            let material = null;
            if ( nodeDesc.material !== undefined ) {
                const material_index = nodeDesc.material;
                if ( material_index < this.mMaterials.length && material_index >= 0 ) {
                    material = this.mMaterials[material_index];
                }
                else {
                    console.warn( 'SpeGltfDecoder::_decodeNode >>> couldnt grab any associated material for a mesh-node (index out of bounds)' );
                }
            }
            if ( !material ) {
                console.warn(  'SpeGltfDecoder::_decodeNode >>> mesh-node doesnt have a material. Creating a default phong-material instead' );
                material = new SpePhongMaterial( {}, { color: new THREE.Color( 0xffffff ), specular: new THREE.Color( 0xffffff ) } );
            }

            const mesh = new SpeMesh3D( geometry, material );
            mesh.visible = ( nodeDesc.visible !== undefined ) ? nodeDesc.visible : true;
            mesh.castShadow = ( nodeDesc.castShadow !== undefined ) ? nodeDesc.castShadow : true;
            mesh.receiveShadow = ( nodeDesc.receiveShadow !== undefined ) ? nodeDesc.receiveShadow : true;
            mesh.position.copy( new THREE.Vector3().fromArray( ( nodeDesc.translation ) ? nodeDesc.translation : [0., 0., 0.] ) );
            mesh.quaternion.copy( new THREE.Quaternion().fromArray( ( nodeDesc.rotation ) ? nodeDesc.rotation : [0., 0., 0., 1.] ) );
            mesh.scale.copy( new THREE.Vector3().fromArray( ( nodeDesc.scale ) ? nodeDesc.scale : [1., 1., 1.] ) );
            mesh.hiddenMatrix.copy( new THREE.Matrix4().fromArray( ( nodeDesc.hiddenMatrix ) ? nodeDesc.hiddenMatrix : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] ) );
            mesh.updateMatrix();
            this.mNodes.push( mesh );

            const mesh_uuid = ( nodeDesc.uuid !== undefined ) ? nodeDesc.uuid : THREE.MathUtils.generateUUID();
            this.mObjects[mesh_uuid] = mesh;

            if ( nodeDesc.spe_cloner ) {
                mesh.cloner = new Cloner( mesh ).fromJSON( nodeDesc.spe_cloner_data );
                mesh.add( mesh.cloner );
            }
        }
        /* Handle lights setup in the scene as a proper node */
        else if ( nodeDesc.extensions !== undefined && nodeDesc.extensions.KHR_lights_punctual !== undefined &&
                  nodeDesc.extensions.KHR_lights_punctual.light !== undefined ) {
            const light_index = nodeDesc.extensions.KHR_lights_punctual.light;
            if ( light_index < this.mLights.length && light_index >= 0 ) {
                const light = this.mLights[light_index];
                light.position.copy( new THREE.Vector3().fromArray( ( nodeDesc.translation ) ? nodeDesc.translation : [0., 0., 0.] ) );

                if ( light.type === 'SpotLight' || light.type === 'DirectionalLight' ) {
                    const quaternion = new THREE.Quaternion().fromArray( ( nodeDesc.rotation ) ? nodeDesc.rotation : [0., 0., 0., 1.] );
                    const rotmat = new THREE.Matrix4().makeRotationFromQuaternion( quaternion );
                    const direction = new THREE.Vector3( rotmat.elements[8], rotmat.elements[9], rotmat.elements[10] );
                    light.target.position.x = light.position.x + direction.x;
                    light.target.position.y = light.position.y + direction.y;
                    light.target.position.z = light.position.z + direction.z;
                }
                if ( light.hiddenMatrix ) {
                    light.hiddenMatrix.copy( new THREE.Matrix4().fromArray( ( nodeDesc.hiddenMatrix ) ? nodeDesc.hiddenMatrix : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] ) );
                }
                light.visible = ( nodeDesc.visible !== undefined ) ? nodeDesc.visible : true;
                this.mNodes.push( light );

                const light_uuid = ( nodeDesc.uuid !== undefined ) ? nodeDesc.uuid : THREE.MathUtils.generateUUID();
                this.mObjects[light_uuid] = light;
            }
            else {
                console.error( 'SpeGltfDecoder::_decodeNode >>> couldnt create node for associated light (index out of bounds)' );
            }
        }
        else if ( nodeDesc.spe_empty_object ) {
            const empty_object = new SpeEmptyObject();
            empty_object.position.copy( new THREE.Vector3().fromArray( ( nodeDesc.translation ) ? nodeDesc.translation : [0., 0., 0.] ) );
            empty_object.quaternion.copy( new THREE.Quaternion().fromArray( ( nodeDesc.rotation ) ? nodeDesc.rotation : [0., 0., 0., 1.] ) );
            empty_object.scale.copy( new THREE.Vector3().fromArray( ( nodeDesc.scale ) ? nodeDesc.scale : [1., 1., 1.] ) );
            empty_object.hiddenMatrix.copy( new THREE.Matrix4().fromArray( ( nodeDesc.hiddenMatrix ) ? nodeDesc.hiddenMatrix : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] ) );
            empty_object.updateMatrix();
            this.mNodes.push( empty_object );

            const empty_object_uuid = ( nodeDesc.uuid !== undefined ) ? nodeDesc.uuid : THREE.MathUtils.generateUUID();
            this.mObjects[empty_object_uuid] = empty_object;
        }
        else {
            console.warn( 'SpeGltfDecoder::_decodeNode >>> Unsupported node, creating a default THREE.Object3D instead' );
            const def_object = new THREE.Object3D();
            def_object.position.copy( new THREE.Vector3().fromArray( ( nodeDesc.translation ) ? nodeDesc.translation : [0., 0., 0.] ) );
            def_object.quaternion.copy( new THREE.Quaternion().fromArray( ( nodeDesc.rotation ) ? nodeDesc.rotation : [0., 0., 0., 1.] ) );
            def_object.scale.copy( new THREE.Vector3().fromArray( ( nodeDesc.scale ) ? nodeDesc.scale : [1., 1., 1.] ) );
            this.mNodes.push( def_object );
        }
    }

    _getAccessorItemSize( type ) {
        /**/ if ( type === 'SCALAR' ) return 1;
        else if ( type === 'VEC2' ) return 2;
        else if ( type === 'VEC3' ) return 3;
        else if ( type === 'VEC4' ) return 4;
        else if ( type === 'MAT4' ) return 16;

        console.error( 'SpeGltfDecoder::_getAccessorItemSize >>> invalid item-type' );
        return 1;
    }

    _getAccessorComponentSize( component_type ) {
        /**/ if ( component_type === UNSIGNED_BYTE ) return 1;
        else if ( component_type === UNSIGNED_SHORT ) return 2;
        else if ( component_type === UNSIGNED_INT ) return 4;
        else if ( component_type === FLOAT ) return 4;

        console.error( 'SpeGltfDecoder::_getAccessorComponentSize >>> invalid component-type' );
        return 1;
    }

    _createUint16Buffer( bytes ) {
        return new Uint16Array( bytes.buffer );
    }

    _createUint32Buffer( bytes ) {
        return new Uint32Array( bytes.buffer );
    }

    _createFloat32Buffer( bytes ) {
        const float_arr = new Float32Array( bytes.length / Float32Array.BYTES_PER_ELEMENT );
        const float_view = new DataView( new ArrayBuffer( Float32Array.BYTES_PER_ELEMENT ) );
        for ( let i = 0; i < float_arr.length; i++ ) {
            float_view.setUint8( 0, bytes[4 * i + 0] );
            float_view.setUint8( 1, bytes[4 * i + 1] );
            float_view.setUint8( 2, bytes[4 * i + 2] );
            float_view.setUint8( 3, bytes[4 * i + 3] );
            float_arr[i] = float_view.getFloat32( 0, true );
        }
        return float_arr;
    }

    _createBufferAttribute( buffer_arr, item_size ) {
        /**/ if ( buffer_arr.constructor.name === 'Float32Array' ) {
            return new THREE.Float32BufferAttribute( buffer_arr, item_size );
        }
        else if ( buffer_arr.constructor.name === 'Uint16Array' ) {
            return new THREE.Uint16BufferAttribute( buffer_arr, item_size );
        }
        else if ( buffer_arr.constructor.name === 'Uint32Array' ) {
            return new THREE.Uint32BufferAttribute( buffer_arr, item_size );
        }
        console.error( 'SpeGltfDecoder::_createBufferAttribute >>> unsupported buffer-array-type' );
        return null;
    }
};
class SpeIMesh extends THREE.Mesh {

    constructor( geometry, material ) {
        super( geometry, material );
        // Local transform used as fix in the editor
        this.mLocalTransform = new THREE.Matrix4();
        // Interaction handle used for animations
        this.mInteraction = ( typeof Interaction === 'function' ) ? ( new Interaction( this ) ) : null;
    }

    get interaction() {
        return this.mInteraction;
    }

    set interaction( interactionObj ) {
        this.mInteraction = interactionObj;
    }

    get hiddenMatrix() {
        return this.mLocalTransform;
    }

    set hiddenMatrix( mat ) {
        this.mLocalTransform.copy( mat );
    }

    set visibility( value ) {
        this.visible = value;

        for ( let i = 0, l = this.children.length; i < l; ++i ) {
            // Only entity children (cloner and stroke are not entities)
            if ( this.children[ i ].traverseEntity === undefined ) continue;
            this.children[ i ].traverseEntity( function( object ) {
                if ( object.objectHelper !== undefined && object.visible === true ) {
                    object.objectHelper.visible = value;
                }
            } );
        }
    }

    get visibility() {
        return this.visible;
    }

    updateGeometry( geometry ) {
        this.geometry.copy( geometry );
    }

    computeSingleBoundingBox() {
        if ( !this.singleBoundingBox ) {
            this.singleBoundingBox = new SPE.Box3();
        }

        this.singleBoundingBox.setFromObjectSize( this, false );
        this.singleBoundingBox.computeVertices();
        this.singleBoundingBox.computeEdges();
    }

    computeComplexBoundingBox( recursive ) {
        if ( !this.complexBoundingBox ) {
            this.complexBoundingBox = new SPE.Box3();
        }

        this.complexBoundingBox.setFromObjectSize( this, recursive );
    }

    // Use fix for local-transform from the editor
    updateMatrixWorld( force ) {
        if ( this.matrixAutoUpdate ) this.updateMatrix();

        if ( this.matrixWorldNeedsUpdate || force ) {
            if ( this.parent === null ) {
                this.matrixWorld.multiplyMatrices( this.mLocalTransform, this.matrix );
            }
            else {
                this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.mLocalTransform );
                this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }

        // update children
        const children = this.children;
        for ( let i = 0, l = children.length; i < l; i ++ ) {
            children[ i ].updateMatrixWorld( force );
        }
    }

    // Use fix for local-transform from the editor
    updateWorldMatrix( updateParents, updateChildren ) {
        var parent = this.parent;

        if ( updateParents === true && parent !== null ) {
            parent.updateWorldMatrix( true, false );
        }

        if ( this.matrixAutoUpdate ) this.updateMatrix();

        if ( this.parent === null ) {
            this.matrixWorld.multiplyMatrices( this.mLocalTransform, this.matrix ); // nisa modification
        } else {
            //this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
            this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.mLocalTransform );  // nisa modification
            this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );  // nisa modification
        }

        // update children
        if ( updateChildren === true ) {
            var children = this.children;
            for ( var i = 0, l = children.length; i < l; i ++ ) {
                children[ i ].updateWorldMatrix( false, true );
            }
        }
    }

    shallowClone( recursive ) {
        return new this.constructor( this.geometry, this.material ).shallowCopy( this, recursive );
    }

    shallowCopy( source, recursive = true ) {
        let children = source.children;
        source.children = [];
        super.copy( source );
        source.children = children;

        this.userDataFromJson( this.userData );
        if ( recursive === true ) {
            for ( let i = 0, l = children.length; i < l; ++i ) {
                let child = source.children[ i ];
                if ( child.userData.isEntity === true ) {
                    this.add( child.shallowClone() );
                }
            }
        }
        return this;
    }

    traverseEntity ( callback ) {
        function traverse( object ) {
            if ( ! object.userData.isEntity ) {
                return;
            }

            callback( object );

            const children = object.children;
            for ( let i = 0, l = children.length; i < l; ++i ) {
                traverse( children[ i ] );
            }
        }
        traverse( this );
    }

    userDataFromJson( userData ) {
        this.userData = userData;
        this.userData.positionToCenter = new THREE.Vector3();
        
        if ( userData.hiddenMatrix !== undefined ) {
            this.userData.hiddenMatrix = new THREE.Matrix4().fromArray( userData.hiddenMatrix.elements );
        }
        if ( userData.lock === undefined ) this.userData.lock = false; // PATCH: changing the version
    }
};
class SpeMesh3D extends SpeIMesh {

    constructor( geometry, material ) {
        super( geometry, material );
    }
}
class SpeEmptyObject extends THREE.Group {

    constructor() {
        super();
        // Local transform used as fix in the editor
        this.mLocalTransform = new THREE.Matrix4();
        // Interaction handle used for animations
        this.mInteraction = ( typeof Interaction === 'function' ) ? ( new Interaction( this ) ) : null;
    }

    get interaction() {
        return this.mInteraction;
    }

    set interaction( interactionObj ) {
        this.mInteraction = interactionObj;
    }

    get hiddenMatrix() {
        return this.mLocalTransform;
    }

    set hiddenMatrix( mat ) {
        this.mLocalTransform.copy( mat );
    }

    // Use fix for local-transform from the editor
    updateMatrixWorld( force ) {
        if ( this.matrixAutoUpdate ) this.updateMatrix();

        if ( this.matrixWorldNeedsUpdate || force ) {
            if ( this.parent === null ) {
                this.matrixWorld.multiplyMatrices( this.mLocalTransform, this.matrix );
            }
            else {
                this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.mLocalTransform );
                this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }

        // update children
        const children = this.children;
        for ( let i = 0, l = children.length; i < l; i ++ ) {
            children[ i ].updateMatrixWorld( force );
        }
    }

    // Use fix for local-transform from the editor
    updateWorldMatrix( updateParents, updateChildren ) {
        var parent = this.parent;

        if ( updateParents === true && parent !== null ) {
            parent.updateWorldMatrix( true, false );
        }

        if ( this.matrixAutoUpdate ) this.updateMatrix();

        if ( this.parent === null ) {
            this.matrixWorld.multiplyMatrices( this.mLocalTransform, this.matrix ); // nisa modification
        } else {
            //this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
            this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.mLocalTransform );  // nisa modification
            this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );  // nisa modification
        }

        // update children
        if ( updateChildren === true ) {
            var children = this.children;
            for ( var i = 0, l = children.length; i < l; i ++ ) {
                children[ i ].updateWorldMatrix( false, true );
            }
        }
    }
};
class SpeMesh2D extends SpeIMesh {

    constructor( geometry, material ) {
        super( geometry, material );
    }
}
/**
*   Layer list abstraction, representing a linked-list used to manage
*   the layers used in an object's material within the spline editor|runtime
*/
class SpeLayersList {

    /**
    *   Creates a layer-list initialized with the given layers
    *   @param {Array<Object>} layers Descriptions of the layers in object form
    */
    constructor( layers ) {
        this.mHead = null;
        this.mShader = null;

        if ( layers !== undefined && Object.keys( layers ).length > 0 ) {
            for ( let i = 0; i < layers.length; i++ ) {
                this.addLayer( i, layers[i].type, layers[i].uniforms );
            }
        }
        else {
            // Constructs some default layers (lighting + color)
            this.addLayer( 0, SPE_LAYER_TYPE_COLOR, {} );
            this.addLayer( 1, SPE_LAYER_TYPE_LIGHTING, {} );
        }
    }

    get head() {
        return this.mHead;
    }

    set head( obj ) {
        this.mHead = obj;
    }

    get shader() {
        return this.mShader;
    }

    set shader( obj ) {
        this.mShader = obj;
    }

    addLayer( id, type, uniforms ) {
        const layer = SpeLayer.CreateLayer( id, type, uniforms );
        if ( layer === null ) {
            console.error( 'SpeLayersList::addLayer >>> couldnt create a layer of type: ', type );
            return;
        }

        if ( this.mHead === null ) {
            this.mHead = layer;
        }
        else {
            let current_layer = this.mHead;
            while( current_layer.next ) {
                current_layer = current_layer.next;
            }
            current_layer.next = layer;
        }
        return layer;
    }

    addLayerBeforeAt( params, before ) {
        const layer_id = ( params.id !== undefined ) ? params.id : ( 100 + Math.floor(Math.random() * 999 ) ); // PATCH nisa: temporal solution, we need property [id] in SpeLayersList to keep a autoincremental identifier (ask nisa)
        const layer_type = ( params.type !== undefined ) ? params.type : SPE_LAYER_TYPE_COLOR;
        const layer_uniforms = layer_type !== 'texture' ? SpeLayer.DictToUniforms( params ) : SpeLayerTexture.DictToUniforms( params );
        const new_layer = SpeLayer.CreateLayer( layer_id, layer_type, layer_uniforms );

        let current_layer = this.head;
        new_layer.next = before;
        if ( current_layer === before ) {
            this.head = new_layer;
        }
        else {
            while ( current_layer.next !== before ) {
                current_layer = current_layer.next;
            }
            current_layer.next = new_layer;
        }
        return new_layer;
    }

    removeLayer( id ) {
        let layer = this.head;
        let prev = undefined;
        let pos = 0;

        if ( layer.id == id ) {
            this.head = layer.next;
        }
        else {
            pos = 1;
            prev = layer;
            layer = layer.next;

            while ( layer != undefined ) {
                if ( layer.id == id ) {
                    prev.next = layer.next;
                    break
                }
                pos++;
                prev = layer;
                layer = layer.next;
            }
        }
        return pos;

    }

    getLayer( id ) {
        let layer = this.head;
        while ( layer ) {
            if ( layer.id == id ) {
                break;
            }
            layer = layer.next;
        }
        return layer;

    }

    updateLayerUniform( id, name ) {
        const layer = this.getLayer( id );
        if ( !layer ) {
            return;
        }
        if ( layer.uniforms[name] === undefined ) {
            console.error( `SpeLayersList::updateLayerUniform >>> uniform ${name} not found in layer` );
            return;
        }
        this.mShader.uniforms[name] = { value: layer.uniforms[name].value };
    }

    updateLayerUniformByLayer( layer, name ) {
        if ( layer.uniforms[name] === undefined ) {
            console.error( `SpeLayersList::updateLayerUniformByLayer >>> uniform ${name} not found in layer` );
            return;
        }
        this.mShader.uniforms[name] = { value: layer.uniforms[name].value };
    }

    getUniforms() {
        const uniforms = {};
        let current_layer = this.mHead;
        while ( current_layer ) {
            for ( let [unif_name, unif_value] of Object.entries( current_layer.uniforms ) ) {
                uniforms[unif_name] = unif_value;
            }
            current_layer = current_layer.next;
        }
        return uniforms;
    }

    getDefinesCode() {
        let code = '';
        let current_layer = this.mHead;
        while( current_layer ) {
            for ( let [def_name, def_val] of Object.entries( current_layer.defines ) ) {
                code += `#define ${def_name} ${def_val}\n`;
            }
            current_layer = current_layer.next;
        }
        return code;
    }

    getVertUniformsCode() {
        let code = '';
        let current_layer = this.mHead;
        while( current_layer ) {
            code += current_layer.generateUniformsCodeVert();
            current_layer = current_layer.next;
        }
        return code;
    }

    getFragUniformsCode() {
        let code = '';
        let current_layer = this.mHead;
        while( current_layer ) {
            code += current_layer.generateUniformsCodeFrag();
            current_layer = current_layer.next;
        }
        return code;
    }

    getFragShaderCodePreLighting() {
        let code = '';
        let current_layer = this.mHead;
        while ( current_layer.type !== SPE_LAYER_TYPE_LIGHTING ) {
            code += current_layer.generateShaderCodeFrag( 'bef' );
            current_layer = current_layer.next;
        }
        return code;
    }

    getFragShaderCodeLighting() {
        let current_layer = this.mHead;
        while( current_layer.type !== SPE_LAYER_TYPE_LIGHTING ) {
            current_layer = current_layer.next;
        }
        return current_layer.generateShaderCodeFrag();
    }

    getFragShaderCodePostLighting() {
        let code = '';
        let current_layer = this.mHead;
        while ( current_layer.type !== SPE_LAYER_TYPE_LIGHTING ) {
            current_layer = current_layer.next;
        }
        current_layer = current_layer.next;
        while ( current_layer ) {
            code += current_layer.generateShaderCodeFrag( 'aft' );
            current_layer = current_layer.next;
        }
        return code;
    }
};
class SpeLayer {

    constructor( id, type = SPE_LAYER_TYPE_COLOR, uniforms = {} ) {
        this.mId = id;
        this.mType = type;
        this.mNext = null;
        this.mDefines = {};
        this.mUniforms = {};

        this.mProgramVertUniforms = '';
        this.mProgramFragUniforms = '';

        this.initializeUniformsAndDefines( uniforms );
    }

    get id() {
        return this.mId;
    }

    get type() {
        return this.mType;
    }

    get next() {
        return this.mNext;
    }

    set next( nextLayer ) {
        this.mNext = nextLayer;
    }

    get defines() {
        return this.mDefines;
    }

    get uniforms() {
        return this.mUniforms;
    }

    get paramNames() {
        const uniform_unique_names = Object.keys( this.mUniforms );
        const uniform_prefix = `f${this.mId}_`;
        const uniform_names = [];
        for ( let i = 0; i < uniform_unique_names.length; i++ ) {
            const u_name = uniform_unique_names[i];
            uniform_names.push( u_name.slice( u_name.indexOf( uniform_prefix ) + uniform_prefix.length ) );
        }
        return uniform_names;
    }

    getValues() {
        const uniform_prefix = `f${this.mId}_`;
        const uniforms_post = { type: this.type };
        for ( const [u_name, u_value] of Object.entries( this.mUniforms ) ) {
            const u_name_post = u_name.slice( u_name.indexOf( uniform_prefix ) + uniform_prefix.length );
            if ( u_value.value.toArray ) {
                uniforms_post[u_name_post] = u_value.value.toArray();
            }
            else {
                uniforms_post[u_name_post] = u_value.value;
            }
        }
        return uniforms_post;
    }

    initializeUniformsAndDefines( uniforms ) {
        console.error( 'SpeLayer::initializeUniformsAndDefines >>> virtual method' );
    }

    generateUniformsCodeVert() {
        return '\n\r';
    }

    generateUniformsCodeFrag() {
        return '\n\r';
    }

    generateShaderCodeVert( output_var ) {
        return '\n\r';
    }

    generateShaderCodeFrag( output_var ) {
        return '\n\r';
    }

    copy( src ) {
        if ( this.mType !== src.mType ) {
            console.error( `SpeLayer::copy >>> cant copy layer of different type dst=${this.mType}, src=${src.mType}` );
            return;
        }
        this.mId = src.mId;
        // Copy defines from source
        this.mDefines = { ...src.mDefines };
        // Copy uniforms from source
        this.copyUniforms( src );
    }

    clone() {
        return SpeLayer.CreateLayer( this.mId, this.mType, this.mUniforms );
    }

    copyUniforms( src ) {
        console.error( 'SpeLayer::copyUniforms >>> virtual method' );
    }

    static CreateLayer( id, type, uniforms ) {
        /**/ if ( type === SPE_LAYER_TYPE_LIGHTING ) {
            return new SpeLayerLighting( id, uniforms );
        }
        else if ( type === SPE_LAYER_TYPE_COLOR ) {
            return new SpeLayerColor( id, uniforms );
        }
        else if ( type === SPE_LAYER_TYPE_GRADIENT ) {
            return new SpeLayerGradient( id, uniforms );
        }
        else if ( type === SPE_LAYER_TYPE_NORMAL ) {
            return new SpeLayerNormal( id, uniforms );
        }
        else if ( type === SPE_LAYER_TYPE_DEPTH ) {
            return new SpeLayerDepth( id, uniforms );
        }
        else if ( type === SPE_LAYER_TYPE_TEXTURE ) {
            return new SpeLayerTexture( id, uniforms );
        }
        else if ( type === SPE_LAYER_TYPE_NOISE ) {
            return new SpeLayerNoise( id, uniforms );
        }
        else if ( type === SPE_LAYER_TYPE_FRESNEL ) {
            return new SpeLayerFresnel( id, uniforms );
        }
        else if ( type === SPE_LAYER_TYPE_POINTS ) {
            return new SpeLayerPoints( id, uniforms );
        }
        else if ( type === SPE_LAYER_TYPE_LINES ) {
            return new SpeLayerLines( id, uniforms );
        }
        return null;
    }

    static DictToUniforms( dict ) {
        const uniforms = {};
        for ( const [key, val] of Object.entries( dict ) ) {
            uniforms[key] = { value: val };
        }
        return uniforms;
    }
};

class SpeLayerLighting extends SpeLayer {

    constructor( id, uniforms ) {
        super( id, SPE_LAYER_TYPE_LIGHTING, uniforms );
    }

    initializeUniformsAndDefines( uniforms ) {
        this.mDefines['SPE_USE_LAYER_LIGHTING'] = '';

        this.mUniforms[`f${this.mId}_alpha`] = { value: ( uniforms.alpha !== undefined ? uniforms.alpha.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_mode`] = { value: ( uniforms.mode !== undefined ? uniforms.mode.value : SPE_BLENDING_NORMAL ) };
    }

    generateUniformsCodeFrag() {
        return `
            // SPE: Lighting layer uniforms *****
            uniform float f${this.mId}_alpha;
            uniform int f${this.mId}_mode;
            // **********************************
        `;
    }

    generateShaderCodeFrag() {
        return `
            // SPE: Lighting layer frag-shader-code ************************************************
            // @todo: instead of == use absolute distance for vector comparison
            if ( outgoingLight != diffuseColor.rgb ) {
                float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
                accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha * lightAccu;
                outgoingLight = spe_blend( diffuseColor.rgb, outgoingLight, f${this.mId}_alpha, f${this.mId}_mode );
            }
            // *************************************************************************************
        `;
    }

    copyUniforms( src ) {
        if ( !( src instanceof SpeLayerLighting ) ) {
            return;
        }

        this.mUniforms[`f${this.mId}_alpha`] = { value: src.uniforms[`f${src.id}_alpha`].value };
        this.mUniforms[`f${this.mId}_mode`] = { value: src.uniforms[`f${src.id}_mode`].value };
    }
};

class SpeLayerColor extends SpeLayer {

    constructor( id, uniforms ) {
        super( id, SPE_LAYER_TYPE_COLOR, uniforms );
    }

    initializeUniformsAndDefines( uniforms ) {
        this.mDefines['SPE_USE_LAYER_COLOR'] = '';

        this.mUniforms[`f${this.mId}_alpha`] = { value: ( uniforms.alpha !== undefined ? uniforms.alpha.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_mode`] = { value: ( uniforms.mode !== undefined ? uniforms.mode.value : SPE_BLENDING_NORMAL ) };
        this.mUniforms[`f${this.mId}_color`] = { value: ( uniforms.color !== undefined ? new THREE.Color( uniforms.color.value ) : new THREE.Color( SPE_COLOR_DEFAULT ) ) };
    }

    generateUniformsCodeFrag() {
        return `
            // SPE: Color layer uniforms **********
            uniform float f${this.mId}_alpha;
            uniform int f${this.mId}_mode;
            uniform vec3 f${this.mId}_color;
            // ************************************
        `;
    }

    generateShaderCodeFrag( output_var ) {
        return `
            // SPE: Color layer frag-shader-code ***************************************************
            float f${this.mId}_calpha = f${this.mId}_alpha / clamp( f${this.mId}_alpha + accumAlpha, 0.00001, 1.0 );
            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha;
            ${output_var} = spe_blend( ${output_var}, f${this.mId}_color, f${this.mId}_calpha, f${this.mId}_mode );
            // *************************************************************************************
        `;
    }

    copyUniforms( src ) {
        if ( !( src instanceof SpeLayerColor ) ) {
            return;
        }

        this.mUniforms[`f${this.mId}_alpha`] = { value: src.uniforms[`f${src.id}_alpha`].value };
        this.mUniforms[`f${this.mId}_mode`] = { value: src.uniforms[`f${src.id}_mode`].value };
        this.mUniforms[`f${this.mId}_color`] = { value: src.uniforms[`f${src.id}_color`].value.clone() };
    }
};

class SpeLayerTexture extends SpeLayer {

    constructor( id, uniforms ) {
        super( id, SPE_LAYER_TYPE_TEXTURE, uniforms );
    }

    initializeUniformsAndDefines( uniforms ) {
        this.mDefines['SPE_USE_LAYER_TEXTURE'] = '';
        this.mDefines['USE_UV'] = '';

        // @hack: (interaction module) retrieve a texture appropriately (whether from data or interaction-module's cached textures)
        function get_texture( value ) {
            if ( value instanceof THREE.Texture ) {
                return value;
            }
            else if ( typeof( value ) === 'string' ) {
                return create_texture_from_base64( value );
            }
            console.error( 'SpeLayerTexture::get_texture >>> cant retrieve texture from given parameters' );
            return new THREE.Texture();
        }

        function create_texture_from_base64( base64 ) {
            const image = new Image();
            image.src = base64;
            const texture = new THREE.Texture( image );
            texture.needsUpdate = true;
            return texture;
        }

        this.mUniforms[`f${this.mId}_alpha`] = { value: ( uniforms.alpha !== undefined ? uniforms.alpha.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_mode`] = { value: ( uniforms.mode !== undefined ? uniforms.mode.value : SPE_BLENDING_NORMAL ) };
        this.mUniforms[`f${this.mId}_texture`] = { value: ( uniforms.texture !== undefined ? get_texture( uniforms.texture.value ) : new THREE.Texture() ) };
        this.mUniforms[`f${this.mId}_mat`] = { value: ( uniforms.mat !== undefined ? this.mUniforms[`f${this.mId}_texture`].value.matrix.fromArray( uniforms.mat.value.elements !== undefined ? uniforms.mat.value.elements : uniforms.mat.value ) : this.mUniforms[`f${this.mId}_texture`].value.matrix ) };
        this.mUniforms[`f${this.mId}_crop`] = { value: ( uniforms.crop !== undefined ? uniforms.crop.value : 0 ) };
    }

    generateUniformsCodeFrag() {
        return `
            // SPE: Texture layer uniforms ********
            uniform float f${this.mId}_alpha;
            uniform int f${this.mId}_mode;
            uniform sampler2D f${this.mId}_texture;
            uniform mat3 f${this.mId}_mat;
            uniform float f${this.mId}_crop;
            // ************************************
        `;
    }

    generateShaderCodeFrag( output_var ) {
        return `
            // SPE: Texture layer frag-shader-code *************************************************
            vec2 f${this.mId}_vUv = ( f${this.mId}_mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
            vec4 f${this.mId}_tmp = texture2D( f${this.mId}_texture, f${this.mId}_vUv );
            vec3 f${this.mId}_col = f${this.mId}_tmp.rgb;
            float f${this.mId}_lalpha = f${this.mId}_alpha * f${this.mId}_tmp.a;
            if ( f${this.mId}_crop > 0.5 ) {
                if ( f${this.mId}_vUv.x < 0.0 || f${this.mId}_vUv.x > 1.0 ||
                     f${this.mId}_vUv.y < 0.0 || f${this.mId}_vUv.y > 1.0 ) {
                        f${this.mId}_lalpha = 0.0;
                }
            }
            float f${this.mId}_calpha =  f${this.mId}_lalpha / clamp( f${this.mId}_lalpha + accumAlpha, 0.00001, 1.0 );
            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_lalpha;
            ${output_var} = spe_blend( ${output_var}, f${this.mId}_col, f${this.mId}_calpha, f${this.mId}_mode );
            // *************************************************************************************
        `;
    }

    copyUniforms( src ) {
        if ( !( src instanceof SpeLayerTexture ) ) {
            return;
        }

        this.mUniforms[`f${this.mId}_alpha`] = { value: src.uniforms[`f${src.id}_alpha`].value };
        this.mUniforms[`f${this.mId}_mode`] = { value: src.uniforms[`f${src.id}_mode`].value };
        this.mUniforms[`f${this.mId}_texture`] = { value: src.uniforms[`f${src.id}_texture`].value.clone() };
        this.mUniforms[`f${this.mId}_mat`] = { value : this.mUniforms[`f${this.mId}_texture`].value.matrix };
        this.mUniforms[`f${this.mId}_crop`] = { value: src.uniforms[`f${src.id}_crop`].value };
    }

    static DictToUniforms( dict ) {
        return {
            'alpha': { value: dict.alpha },
            'mode': { value: dict.mode },
            'texture': { value: dict.texture },
            'mat': { value: dict.texture.matrix },
            'crop': { value: dict.crop }
        }
    }
};

class SpeLayerNormal extends SpeLayer {

    constructor( id, uniforms ) {
        super( id, SPE_LAYER_TYPE_NORMAL, uniforms );
    }

    initializeUniformsAndDefines( uniforms ) {
        this.mDefines['SPE_USE_LAYER_NORMAL'] = '';

        this.mUniforms[`f${this.mId}_alpha`] = { value: ( uniforms.alpha !== undefined ? uniforms.alpha.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_mode`] = { value: ( uniforms.mode !== undefined ? uniforms.mode.value : SPE_BLENDING_NORMAL ) };
        this.mUniforms[`f${this.mId}_cnormal`] = { value: ( uniforms.cnormal !== undefined ? new THREE.Vector3().fromArray( uniforms.cnormal.value ) : new THREE.Vector3( 1, 1, 1 ) ) };
    }

    generateUniformsCodeFrag() {
        return `
            // SPE: Normal layer uniforms ********
            uniform float f${this.mId}_alpha;
            uniform int f${this.mId}_mode;
            uniform vec3 f${this.mId}_cnormal;
            // ***********************************
        `;
    }

    generateShaderCodeFrag( output_var ) {
        return `
            // SPE: Normal layer frag-shader-code **************************************************
            vec3 f${this.mId}_normal = packNormalToRGB( normal ).rgb;
            f${this.mId}_normal *= step( vec3(0.5), f${this.mId}_cnormal );
            float f${this.mId}_calpha = f${this.mId}_alpha / clamp( f${this.mId}_alpha + accumAlpha, 0.00001, 1.0 );
            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha;
            ${output_var} = spe_blend( ${output_var}, f${this.mId}_normal, f${this.mId}_calpha, f${this.mId}_mode );
            // *************************************************************************************
        `;
    }

    copyUniforms( src ) {
        if ( !( src instanceof SpeLayerNormal ) ) {
            return;
        }

        this.mUniforms[`f${this.mId}_alpha`] = { value: src.uniforms[`f${src.id}_alpha`].value };
        this.mUniforms[`f${this.mId}_mode`] = { value: src.uniforms[`f${src.id}_mode`].value };
        this.mUniforms[`f${this.mId}_cnormal`] = { value: src.uniforms[`f${src.id}_cnormal`].value.clone() };
    }
};

class SpeLayerDepth extends SpeLayer {

    constructor( id, uniforms ) {
        super( id, SPE_LAYER_TYPE_DEPTH, uniforms );
    }

    initializeUniformsAndDefines( uniforms ) {
        this.mDefines['SPE_USE_LAYER_DEPTH'] = '';

        this.mUniforms[`f${this.mId}_alpha`] = { value: ( uniforms.alpha !== undefined ? uniforms.alpha.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_mode`] = { value: ( uniforms.mode !== undefined ? uniforms.mode.value : SPE_BLENDING_NORMAL ) };
        this.mUniforms[`f${this.mId}_near`] = { value: ( uniforms.near !== undefined ? uniforms.near.value : 700 ) };
        this.mUniforms[`f${this.mId}_far`] = { value: ( uniforms.far !== undefined ? uniforms.far.value : 1000 ) };
        this.mUniforms[`f${this.mId}_origin`] = { value: ( uniforms.origin !== undefined ) ? new THREE.Vector3().fromArray( uniforms.origin.value ) : new THREE.Vector3() };
        this.mUniforms[`f${this.mId}_isVector`] = { value: ( uniforms.isVector !== undefined ) ? uniforms.isVector.value : 0 };
        this.mUniforms[`f${this.mId}_colorA`] = { value: uniforms.colorA ? new THREE.Color( uniforms.colorA.value ) : new THREE.Color() };
        this.mUniforms[`f${this.mId}_colorB`] = { value: uniforms.colorB ? new THREE.Color( uniforms.colorB.value ) : new THREE.Color( 0, 0, 0 ) };
    }

    generateUniformsCodeFrag() {
        return `
            // SPE: Depth layer uniforms *************
            uniform float f${this.mId}_alpha;
            uniform int f${this.mId}_mode;
            uniform float f${this.mId}_near;
            uniform float f${this.mId}_far;
            uniform float f${this.mId}_isVector;
            uniform vec3 f${this.mId}_origin;
            uniform vec3 f${this.mId}_colorA;
            uniform vec3 f${this.mId}_colorB;
            // ***************************************
        `;
    }

    generateShaderCodeFrag( output_var ) {
        return `
            // SPE: Depth layer frag-shader-code ***************************************************
            vec3 base${this.mId} = ( f${this.mId}_isVector > 0.5 ) ?  f${this.mId}_origin : cameraPosition;
            float dist${this.mId} = length( dWorldPosition.xyz - base${this.mId} );
            float dep${this.mId} = ( dist${this.mId} - f${this.mId}_near ) / ( f${this.mId}_far - f${this.mId}_near );
            vec3 f${this.mId}_depth =  mix( f${this.mId}_colorB, f${this.mId}_colorA, 1.0 - clamp( dep${this.mId}, 0., 1. ) );
            float f${this.mId}_calpha = f${this.mId}_alpha / clamp( f${this.mId}_alpha + accumAlpha, 0.001, 1.0 );
            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha;
            ${output_var} = spe_blend( ${output_var}, f${this.mId}_depth, f${this.mId}_calpha, f${this.mId}_mode );
            // *************************************************************************************
        `;
    }

    copyUniforms( src ) {
        if ( !( src instanceof SpeLayerDepth ) ) {
            return;
        }

        this.mUniforms[`f${this.mId}_alpha`] = { value: src.uniforms[`f${src.id}_alpha`].value };
        this.mUniforms[`f${this.mId}_mode`] = { value: src.uniforms[`f${src.id}_mode`].value };
        this.mUniforms[`f${this.mId}_near`] = { value: src.uniforms[`f${src.id}_near`].value };
        this.mUniforms[`f${this.mId}_far`] = { value: src.uniforms[`f${src.id}_far`].value };
        this.mUniforms[`f${this.mId}_origin`] = { value: src.uniforms[`f${src.id}_origin`].value.clone() };
        this.mUniforms[`f${this.mId}_isVector`] = { value: src.uniforms[`f${src.id}_isVector`].value };
        this.mUniforms[`f${this.mId}_colorA`] = { value: src.uniforms[`f${src.id}_colorA`].value.clone() };
        this.mUniforms[`f${this.mId}_colorB`] = { value: src.uniforms[`f${src.id}_colorB`].value.clone() };
    }
};

class SpeLayerNoise extends SpeLayer {

    constructor( id, uniforms ) {
        super( id, SPE_LAYER_TYPE_NOISE, uniforms );
    }

    initializeUniformsAndDefines( uniforms ) {
        this.mDefines['SPE_USE_LAYER_NOISE'] = '';
        this.mDefines['SPE_USE_LAYER_TEXTURE'] = '';
        this.mDefines['SPE_NOISE_NUM_OCTAVES'] = '5';
        this.mDefines['USE_UV'] = '';

        this.mUniforms[`f${this.mId}_alpha`] = { value: ( uniforms.alpha !== undefined ? uniforms.alpha.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_mode`] = { value: ( uniforms.mode !== undefined ? uniforms.mode.value : SPE_BLENDING_NORMAL ) };
        this.mUniforms[`f${this.mId}_scale`] = { value: ( uniforms.scale !== undefined ? uniforms.scale.value : 2.0 ) };
        this.mUniforms[`f${this.mId}_move`] = { value: ( uniforms.move !== undefined ? uniforms.move.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_distortion`] = { value: ( uniforms.distortion !== undefined ? new THREE.Vector2().fromArray( uniforms.distortion.value ) : new THREE.Vector2( 1, 1 ) ) };
        this.mUniforms[`f${this.mId}_fA`] = { value: ( uniforms.fA !== undefined ? new THREE.Vector2().fromArray( uniforms.fA.value ) : new THREE.Vector2( 1.7, 9.2 ) ) };
        this.mUniforms[`f${this.mId}_fB`] = { value: ( uniforms.fB !== undefined ? new THREE.Vector2().fromArray( uniforms.fB.value ) : new THREE.Vector2( 8.3, 2.8 ) ) };
        this.mUniforms[`f${this.mId}_colorA`] = { value: ( uniforms.colorA !== undefined ? new THREE.Color( uniforms.colorA.value ) : new THREE.Color( 0.4, 0.4, 0.4 ) ) };
        this.mUniforms[`f${this.mId}_colorB`] = { value: ( uniforms.colorB !== undefined ? new THREE.Color( uniforms.colorB.value ) : new THREE.Color( 0.4, 0.4, 0.4 ) ) };
        this.mUniforms[`f${this.mId}_colorC`] = { value: ( uniforms.colorC !== undefined ? new THREE.Color( uniforms.colorC.value ) : new THREE.Color( 1, 1, 1 ) ) };
        this.mUniforms[`f${this.mId}_colorD`] = { value: ( uniforms.colorD !== undefined ? new THREE.Color( uniforms.colorD.value ) : new THREE.Color( 1, 1, 1 ) ) };
        this.mUniforms[`f${this.mId}_intA`] = { value: ( uniforms.intA !== undefined ? uniforms.intA.value : 10.0 ) };
        this.mUniforms[`f${this.mId}_intB`] = { value: ( uniforms.intB !== undefined ? uniforms.intB.value : 10.0 ) };
        this.mUniforms[`f${this.mId}_intC`] = { value: ( uniforms.intC !== undefined ? uniforms.intC.value : 10.0 ) };
        this.mUniforms[`f${this.mId}_intD`] = { value: ( uniforms.intD !== undefined ? uniforms.intD.value : 10.0 ) };
    }

    generateUniformsCodeFrag() {
        return `
            // SPE: Noise layer uniforms *******************
            uniform float f${this.mId}_alpha;
            uniform int f${this.mId}_mode;
            uniform float f${this.mId}_scale;
            uniform float f${this.mId}_move;
            uniform vec2 f${this.mId}_fA;
            uniform vec2 f${this.mId}_fB;
            uniform vec2 f${this.mId}_distortion;
            uniform vec3 f${this.mId}_colorA;
            uniform vec3 f${this.mId}_colorB;
            uniform vec3 f${this.mId}_colorC;
            uniform vec3 f${this.mId}_colorD;
            uniform float f${this.mId}_intA;
            uniform float f${this.mId}_intB;
            uniform float f${this.mId}_intC;
            uniform float f${this.mId}_intD;
            // *********************************************
        `;
    }

    generateShaderCodeFrag( output_var ) {
        return `
            // SPE: Noise layer frag-shader-code ***************************************************
            vec2 f${this.mId}_st = vUv * f${this.mId}_scale;
            vec3 f${this.mId}_color;
            vec2 f${this.mId}_q = vec2( fbm( f${this.mId}_st ), fbm( f${this.mId}_st + vec2(1.0) ) );
            vec2 f${this.mId}_r = vec2( fbm( f${this.mId}_st + f${this.mId}_distortion * f${this.mId}_q + f${this.mId}_fA + f${this.mId}_move ),
                                        fbm( f${this.mId}_st + f${this.mId}_distortion * f${this.mId}_q + f${this.mId}_fB + f${this.mId}_move ) );
            float f${this.mId}_f = fbm( f${this.mId}_st + f${this.mId}_r );
            f${this.mId}_color = mix( f${this.mId}_colorA * f${this.mId}_intA, f${this.mId}_colorB * f${this.mId}_intB,
                         clamp((f${this.mId}_f*f${this.mId}_f)*4.0,0.0,1.0) );
            f${this.mId}_color = mix( f${this.mId}_color, f${this.mId}_colorC * f${this.mId}_intC,
                         clamp( length(f${this.mId}_q), 0.0, 1.0 ) );
            f${this.mId}_color = mix( f${this.mId}_color, f${this.mId}_colorD * f${this.mId}_intD,
                         clamp( length(f${this.mId}_r.x), 0.0, 1.0 ) );
            vec3 f${this.mId}_noise = clamp( vec3( f${this.mId}_f * f${this.mId}_color ), 0.0, 1.0 );
            float f${this.mId}_calpha = f${this.mId}_alpha / clamp( f${this.mId}_alpha + accumAlpha, 0.001, 1.0 );
            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha;
            ${output_var} = spe_blend( ${output_var}, f${this.mId}_noise, f${this.mId}_calpha, f${this.mId}_mode );
            // *************************************************************************************
        `;
    }

    copyUniforms( src ) {
        if ( !( src instanceof SpeLayerNoise ) ) {
            return;
        }

        this.mUniforms[`f${this.mId}_alpha`] = { value: src.uniforms[`f${src.id}_alpha`].value };
        this.mUniforms[`f${this.mId}_mode`] = { value: src.uniforms[`f${src.id}_mode`].value };
        this.mUniforms[`f${this.mId}_scale`] = { value: src.uniforms[`f${src.id}_scale`].value };
        this.mUniforms[`f${this.mId}_move`] = { value: src.uniforms[`f${src.id}_move`].value };
        this.mUniforms[`f${this.mId}_distortion`] = { value: src.uniforms[`f${src.id}_distortion`].value.clone() };
        this.mUniforms[`f${this.mId}_fA`] = { value: src.uniforms[`f${src.id}_fA`].value.clone() };
        this.mUniforms[`f${this.mId}_fB`] = { value: src.uniforms[`f${src.id}_fB`].value.clone() };
        this.mUniforms[`f${this.mId}_colorA`] = { value: src.uniforms[`f${src.id}_colorA`].value.clone() };
        this.mUniforms[`f${this.mId}_colorB`] = { value: src.uniforms[`f${src.id}_colorB`].value.clone() };
        this.mUniforms[`f${this.mId}_colorC`] = { value: src.uniforms[`f${src.id}_colorC`].value.clone() };
        this.mUniforms[`f${this.mId}_colorD`] = { value: src.uniforms[`f${src.id}_colorD`].value.clone() };
        this.mUniforms[`f${this.mId}_intA`] = { value: src.uniforms[`f${src.id}_intA`].value };
        this.mUniforms[`f${this.mId}_intB`] = { value: src.uniforms[`f${src.id}_intB`].value };
        this.mUniforms[`f${this.mId}_intC`] = { value: src.uniforms[`f${src.id}_intC`].value };
        this.mUniforms[`f${this.mId}_intD`] = { value: src.uniforms[`f${src.id}_intD`].value };
    }
};

class SpeLayerFresnel extends SpeLayer {

    constructor( id, uniforms ) {
        super( id, SPE_LAYER_TYPE_FRESNEL, uniforms );
    }

    initializeUniformsAndDefines( uniforms ) {
        this.mDefines['SPE_USE_LAYER_FRESNEL'] = '';

        this.mUniforms[`f${this.mId}_alpha`] = { value: ( uniforms.alpha !== undefined ? uniforms.alpha.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_mode`] = { value: ( uniforms.mode !== undefined ? uniforms.mode.value : SPE_BLENDING_NORMAL ) };
        this.mUniforms[`f${this.mId}_bias`] = { value: ( uniforms.bias !== undefined ? uniforms.bias.value : 0.1 ) };
        this.mUniforms[`f${this.mId}_scale`] = { value: ( uniforms.scale !== undefined ? uniforms.scale.value : 1 ) };
        this.mUniforms[`f${this.mId}_intensity`] = { value: ( uniforms.intensity !== undefined ? uniforms.intensity.value : 2 ) };
        this.mUniforms[`f${this.mId}_factor`] = { value: ( uniforms.factor !== undefined ? uniforms.factor.value : 1 ) };
        this.mUniforms[`f${this.mId}_color`] = { value: ( uniforms.color !== undefined ? new THREE.Color( uniforms.color.value ) : new THREE.Color() ) };
    }

    generateUniformsCodeFrag() {
        return `
            // SPE: Fresnel layer uniforms *********
            uniform float f${this.mId}_alpha;
            uniform int f${this.mId}_mode;
            uniform float f${this.mId}_bias;
            uniform float f${this.mId}_scale;
            uniform float f${this.mId}_intensity;
            uniform float f${this.mId}_factor;
            uniform vec3 f${this.mId}_color;
            // *************************************
        `;
    }

    generateShaderCodeFrag( output_var ) {
        return `
            // SPE: Fresnel layer frag-shader-code *************************************************
            float f${this.mId}_fresnel = f${this.mId}_bias + f${this.mId}_scale * pow( f${this.mId}_factor + dot( normalize( vWorldViewDir ), normalize( vWorldNormal ) ), f${this.mId}_intensity );
            float f${this.mId}_lalpha = clamp( f${this.mId}_fresnel, 0.0, 1.0 ) * f${this.mId}_alpha;
            float f${this.mId}_calpha = f${this.mId}_lalpha / clamp( f${this.mId}_lalpha + accumAlpha, 0.001, 1.0 );
            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_lalpha;
            ${output_var} = spe_blend( ${output_var}, f${this.mId}_color, f${this.mId}_calpha, f${this.mId}_mode );
            // *************************************************************************************
        `;
    }

    copyUniforms( src ) {
        if ( !( src instanceof SpeLayerFresnel ) ) {
            return;
        }

        this.mUniforms[`f${this.mId}_alpha`] = { value: src.uniforms[`f${src.id}_alpha`].value };
        this.mUniforms[`f${this.mId}_mode`] = { value: src.uniforms[`f${src.id}_mode`].value };
        this.mUniforms[`f${this.mId}_bias`] = { value: src.uniforms[`f${src.id}_bias`].value };
        this.mUniforms[`f${this.mId}_scale`] = { value: src.uniforms[`f${src.id}_scale`].value };
        this.mUniforms[`f${this.mId}_intensity`] = { value: src.uniforms[`f${src.id}_intensity`].value };
        this.mUniforms[`f${this.mId}_factor`] = { value: src.uniforms[`f${src.id}_factor`].value };
        this.mUniforms[`f${this.mId}_color`] = { value: src.uniforms[`f${src.id}_color`].value.clone() };
    }
};

class SpeLayerGradient extends SpeLayer {

    constructor( id, uniforms ) {
        super( id, SPE_LAYER_TYPE_GRADIENT, uniforms );
    }

    initializeUniformsAndDefines( uniforms ) {
        this.mDefines['SPE_USE_LAYER_GRADIENT'] = '';
        this.mDefines['SPE_GRADIENT_MAX_SIZE'] = '10';
        this.mDefines['USE_UV'] = '';

        function array_to_arrayvec4( src_arr ) {
            const dst_arr = [];
            for ( let i = 0; i < Math.floor( src_arr.length / 4 ); i++ ) {
                dst_arr.push( new THREE.Vector4( src_arr[4 * i + 0], src_arr[4 * i + 1], src_arr[4 * i + 2], src_arr[4 * i + 3] ) );
            }
            return dst_arr;
        }
		
        this.mUniforms[`f${this.mId}_alpha`] = { value: ( uniforms.alpha !== undefined ? uniforms.alpha.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_mode`] = { value: ( uniforms.mode !== undefined ? uniforms.mode.value : SPE_BLENDING_NORMAL ) };
        this.mUniforms[`f${this.mId}_gl_type`] = { value: ( uniforms.gl_type !== undefined ? uniforms.gl_type.value : 0 ) };
        this.mUniforms[`f${this.mId}_num`] = { value: ( uniforms.num !== undefined ? uniforms.num.value : 2 ) };
        this.mUniforms[`f${this.mId}_smooth`] = { value: ( uniforms.smooth !== undefined ? uniforms.smooth.value : false ) };
        this.mUniforms[`f${this.mId}_colors`] = { value: array_to_arrayvec4( uniforms.colors !== undefined ? uniforms.colors.value : new Array(40).fill() ) };
        this.mUniforms[`f${this.mId}_steps`] = { value: ( uniforms.steps !== undefined ? uniforms.steps.value : new Array(10).fill() ) };
        this.mUniforms[`f${this.mId}_offset`] = { value: ( uniforms.offset !== undefined ? new THREE.Vector2().fromArray( uniforms.offset.value ) : new THREE.Vector2(0,0) ) };
        this.mUniforms[`f${this.mId}_morph`] = { value: ( uniforms.morph !== undefined ? new THREE.Vector2().fromArray( uniforms.morph.value ) : new THREE.Vector2(0,0) ) };
        this.mUniforms[`f${this.mId}_angle`] = { value: ( uniforms.angle !== undefined ? uniforms.angle.value : 0 ) };
    }

    generateUniformsCodeFrag() {
        return `
            // SPE: Gradient layer uniforms ****************
            uniform float f${this.mId}_alpha;
            uniform int f${this.mId}_mode;
            uniform int f${this.mId}_gl_type;
            uniform int f${this.mId}_num;
            uniform bool f${this.mId}_smooth;
            uniform vec4 f${this.mId}_colors[SPE_GRADIENT_MAX_SIZE];
            uniform float f${this.mId}_steps[SPE_GRADIENT_MAX_SIZE];
            uniform vec2 f${this.mId}_offset;
            uniform vec2 f${this.mId}_morph;
            uniform float f${this.mId}_angle;
            // *********************************************
        `;
    }

    generateShaderCodeFrag( output_var ) {
        return `
            // SPE: Gradient layer frag-shader-code ************************************************
            vec4 f${this.mId}_color = f${this.mId}_colors[0];
            vec2 f${this.mId}_m = f${this.mId}_morph / vUv.xy;
            vec2 f${this.mId}_rot = vec2( 0.5 + f${this.mId}_m.x, f${this.mId}_m.y );
            vec2 f${this.mId}_dt = vec2(
                cos( f${this.mId}_angle ) * f${this.mId}_rot.x - sin( f${this.mId}_angle ) * f${this.mId}_rot.y,
                sin( f${this.mId}_angle ) * f${this.mId}_rot.x + cos( f${this.mId}_angle ) * f${this.mId}_rot.y
            );
            vec2 f${this.mId}_pt = ( vUv - 0.5 + f${this.mId}_offset ) / 2.0 + f${this.mId}_dt / 2.0;
            float f${this.mId}_t = dot( f${this.mId}_pt, f${this.mId}_dt ) / dot( f${this.mId}_dt, f${this.mId}_dt );
            if ( f${this.mId}_gl_type == 1 ) {
                f${this.mId}_t = distance (
                    ( vUv + f${this.mId}_morph ) * 3.0,
                    ( vUv + f${this.mId}_offset ) + 1.0
                ) + f${this.mId}_angle;
            } else if ( f${this.mId}_gl_type == 2 ) {
                float f${this.mId}_polar = atan(
                    vUv.x + f${this.mId}_morph.x - 0.5 + f${this.mId}_offset.x,
                    vUv.y + f${this.mId}_morph.y - 0.5 + f${this.mId}_offset.y
                ) * -1.0;
                f${this.mId}_t = fract( ( f${this.mId}_angle / PI / -2.0 ) + 0.5 * ( f${this.mId}_polar / PI ) );
            }
            float f${this.mId}_p;
            for ( int i = 1; i < SPE_GRADIENT_MAX_SIZE; i++ ) {
                if ( i < f${this.mId}_num ) {
                    f${this.mId}_p = clamp( ( f${this.mId}_t - f${this.mId}_steps[i-1] ) / ( f${this.mId}_steps[i] - f${this.mId}_steps[i-1] ), 0.0, 1.0 );
                    f${this.mId}_color = mix( f${this.mId}_color, f${this.mId}_colors[i],
                        ( f${this.mId}_smooth ) ? smoothstep( 0.0, 1.0, f${this.mId}_p ) : f${this.mId}_p
                    );
                } else {
                    break;
                }
            }
            float f${this.mId}_lalpha = f${this.mId}_alpha * f${this.mId}_color.a;
            float f${this.mId}_calpha =  f${this.mId}_lalpha / clamp( f${this.mId}_lalpha + accumAlpha, 0.00001, 1.0 );
            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_lalpha;
            ${output_var} = spe_blend( ${output_var}, f${this.mId}_color.xyz, f${this.mId}_calpha, f${this.mId}_mode );
            // *************************************************************************************
        `;
    }

    getValues() {
	
		function arrayvec4_to_array( src_arrvec4 ) { 
            const dst_arr = [];
            for ( let i = 0; i < src_arrvec4.length; i++ ) {
				dst_arr.push( src_arrvec4[ i ].x, src_arrvec4[ i ].y, src_arrvec4[ i ].z, src_arrvec4[ i ].w );
            }
            return dst_arr;
		}
		
		const uniforms_post = { type: this.type };
		uniforms_post['alpha'] = this.mUniforms[`f${this.mId}_alpha`].value;
        uniforms_post['mode'] = this.mUniforms[`f${this.mId}_mode`].value;
        uniforms_post['gl_type'] = this.mUniforms[`f${this.mId}_gl_type`].value;
        uniforms_post['num'] = this.mUniforms[`f${this.mId}_num`].value;
        uniforms_post['smooth'] = this.mUniforms[`f${this.mId}_smooth`].value;
        uniforms_post['colors'] = arrayvec4_to_array( this.mUniforms[`f${this.mId}_colors`].value );
		uniforms_post['steps'] = [].concat( this.mUniforms[`f${this.mId}_steps`].value );
        uniforms_post['offset'] = this.mUniforms[`f${this.mId}_offset`].value.toArray();
		uniforms_post['morph'] =  this.mUniforms[`f${this.mId}_morph`].value.toArray();
		uniforms_post['angle'] = this.mUniforms[`f${this.mId}_angle`].value;
        return uniforms_post;
    }

    copyUniforms( src ) {
        if ( !( src instanceof SpeLayerGradient ) ) {
            return;
        }

        function copy_arrayvec4( src_arr ) {
            const dst_arr = [];
            for ( let i = 0; i < src_arr.length; i++ ) {
                dst_arr.push( src_arr[i].clone() );
            }
            return dst_arr;
        }

        this.mUniforms[`f${this.mId}_alpha`] = { value: src.uniforms[`f${src.id}_alpha`].value };
        this.mUniforms[`f${this.mId}_mode`] = { value: src.uniforms[`f${src.id}_mode`].value };
        this.mUniforms[`f${this.mId}_gl_type`] = { value: src.uniforms[`f${src.id}_gl_type`].value };
        this.mUniforms[`f${this.mId}_num`] = { value: src.uniforms[`f${src.id}_num`].value };
        this.mUniforms[`f${this.mId}_smooth`] = { value: src.uniforms[`f${src.id}_smooth`].value };
        this.mUniforms[`f${this.mId}_colors`] = { value: copy_arrayvec4( src.uniforms[`f${src.id}_colors`].value ) };
        this.mUniforms[`f${this.mId}_steps`] = { value: [].concat( src.uniforms[`f${src.id}_steps`].value ) };
        this.mUniforms[`f${this.mId}_offset`] = { value: src.uniforms[`f${src.id}_offset`].value.clone() };
        this.mUniforms[`f${this.mId}_morph`] = { value: src.uniforms[`f${src.id}_morph`].value.clone() };
        this.mUniforms[`f${this.mId}_angle`] = { value: src.uniforms[`f${src.id}_angle`].value };
    }
};

class SpeLayerPoints extends SpeLayer {

    constructor( id, uniforms ) {
        super( id, SPE_LAYER_TYPE_POINTS, uniforms );
    }

    initializeUniformsAndDefines( uniforms ) {
        this.mDefines['SPE_USE_LAYER_POINTS'] = '';

        this.mUniforms[`f${this.mId}_alpha`] = { value: ( uniforms.alpha !== undefined ? uniforms.alpha.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_mode`] = { value: ( uniforms.mode !== undefined ? uniforms.mode.value : SPE_BLENDING_NORMAL ) };
        this.mUniforms[`f${this.mId}_color`] = { value: ( uniforms.color !== undefined ? new THREE.Color( uniforms.color.value ) : new THREE.Color( 0xbababa ) ) };
        this.mUniforms[`f${this.mId}_useBack`] = { value: ( uniforms.useBack !== undefined ? uniforms.useBack.value : true ) };
        this.mUniforms[`f${this.mId}_threshold`] = { value: ( uniforms.threshold !== undefined ? uniforms.threshold.value : 0.9 ) };
    }

    generateUniformsCodeFrag() {
        return `
            // SPE: Points layer uniforms **************
            uniform float f${this.mId}_alpha;
            uniform int f${this.mId}_mode;
            uniform vec3 f${this.mId}_color;
            uniform bool f${this.mId}_useBack;
            uniform float f${this.mId}_threshold;
            // *****************************************
        `;
    }

    generateShaderCodeFrag( output_var ) {
        return `
            // SPE: Points layer frag-shader-code **************************************************
            float f${this.mId}_dist = length( vBarycentric );
            float f${this.mId}_edge = aastep( f${this.mId}_threshold, f${this.mId}_dist, 0.00 );
            float f${this.mId}_factor = gl_FrontFacing ? 1.0 : ( f${this.mId}_useBack ? 0.5 : 0.0 );
            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha * f${this.mId}_edge;
            ${output_var} = spe_blend( ${output_var}, f${this.mId}_factor * f${this.mId}_color, f${this.mId}_alpha * f${this.mId}_edge, f${this.mId}_mode );
            // *************************************************************************************
        `;
    }
};

class SpeLayerLines extends SpeLayer {

    constructor( id, uniforms ) {
        super( id, SPE_LAYER_TYPE_LINES, uniforms );
    }

    initializeUniformsAndDefines( uniforms ) {
        this.mDefines['SPE_USE_LAYER_LINES'] = '';

        this.mUniforms[`f${this.mId}_alpha`] = { value: ( uniforms.alpha !== undefined ? uniforms.alpha.value : 1.0 ) };
        this.mUniforms[`f${this.mId}_mode`] = { value: ( uniforms.mode !== undefined ? uniforms.mode.value : SPE_BLENDING_NORMAL ) };
        this.mUniforms[`f${this.mId}_color`] = { value: ( uniforms.color !== undefined ?  new THREE.Color( uniforms.color.value ) : new THREE.Color( 0xbababa ) ) };
        this.mUniforms[`f${this.mId}_thickness`] = { value: ( uniforms.thickness !== undefined ? uniforms.thickness.value : 0.01 ) };
        this.mUniforms[`f${this.mId}_useBack`] = { value: ( uniforms.useBack !== undefined ? uniforms.useBack.value : true ) };
        this.mUniforms[`f${this.mId}_smoothOffset`] = { value: ( uniforms.smoothOffset !== undefined ? uniforms.smoothOffset.value : 0.03 ) };
    }

    generateUniformsCodeFrag() {
        return `
            // SPE: Lines layer uniforms *************************
            uniform float f${this.mId}_alpha;
            uniform int f${this.mId}_mode;
            uniform vec3 f${this.mId}_color;
            uniform float f${this.mId}_thickness;
            uniform bool f${this.mId}_useBack;
            uniform float f${this.mId}_smoothOffset;
            // **************************************************
        `;
    }

    generateShaderCodeFrag( output_var ) {
        return `
            // SPE: Lines layer frag-shader-code ***************************************************
            float f${this.mId}_dist = min( vBarycentric.x, min( vBarycentric.y, vBarycentric.z ) );
            float f${this.mId}_comp_thickness = f${this.mId}_thickness;
            float f${this.mId}_edge = 1.0 - aastep( f${this.mId}_comp_thickness, f${this.mId}_dist, f${this.mId}_smoothOffset );
            float f${this.mId}_factor = gl_FrontFacing ? 1.0 : ( f${this.mId}_useBack ? 0.5 : 0.0 );
            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha * f${this.mId}_edge;
            ${output_var} = spe_blend( ${output_var}, f${this.mId}_factor * f${this.mId}_color, f${this.mId}_alpha * f${this.mId}_edge, f${this.mId}_mode );
            // *************************************************************************************
        `;
    }
};

// @hack: (interaction-module) Register layer build-function for interaction-module for the case of runtime only
if ( !SPE.CreateLayerFromJSON ) {
    // @hack: (interaction-module) transform the uniforms from the expected format stored by the toJSON from the interaction module
    function preprocess_uniforms( layer_id, uniforms ) {
        const processed_uniforms = {};
        const uniform_prefix = `f${layer_id}_`;
        for ( const key in uniforms ) {
            const uniform_name = key.slice(key.indexOf( uniform_prefix ) + uniform_prefix.length);
            const uniform_value = uniforms[key].value;
            /**/ if ( typeof( uniform_value ) === 'boolean' ) {
                processed_uniforms[uniform_name] = { name: uniform_name, value: uniform_value, type: SPE_LAYER_UNIFORM_TYPE_BOOL };
            }
            else if ( typeof( uniform_value ) === 'number' ) {
                if ( Number.isInteger( uniform_value ) ) {
                    processed_uniforms[uniform_name] = { name: uniform_name, value: uniform_value, type: SPE_LAYER_UNIFORM_TYPE_INT };
                }
                else {
                    processed_uniforms[uniform_name] = { name: uniform_name, value: uniform_value, type: SPE_LAYER_UNIFORM_TYPE_FLOAT };
                }
            }
            else if ( typeof( uniform_value ) === 'string' && !isNaN( uniform_value ) ) {
                const value = Number( uniform_value );
                if ( Number.isInteger( value ) ) {
                    processed_uniforms[uniform_name] = { name: uniform_name, value: value, type: SPE_LAYER_UNIFORM_TYPE_INT };
                }
                else {
                    processed_uniforms[uniform_name] = { name: uniform_name, value: value, type: SPE_LAYER_UNIFORM_TYPE_FLOAT };
                }
            }
            else if ( uniform_value instanceof Object && Object.entries( uniform_value ).length === 2 ) {
                if ( uniform_value.x !== undefined && uniform_value.y !== undefined ) {
                    processed_uniforms[uniform_name] = { name: uniform_name, value: [uniform_value.x, uniform_value.y], type: SPE_LAYER_UNIFORM_TYPE_VEC2 };
                }
            }
            else if ( uniform_value instanceof Object && Object.entries( uniform_value ).length === 3 ) {
                if ( uniform_value.x !== undefined && uniform_value.y !== undefined && uniform_value.z !== undefined ) {
                    processed_uniforms[uniform_name] = { name: uniform_name, value: [uniform_value.x, uniform_value.y, uniform_value.z], type: SPE_LAYER_UNIFORM_TYPE_VEC3 };
                }
            }
            else if ( uniform_value instanceof Object && Object.entries( uniform_value ).length === 4 ) {
                if ( uniform_value.x !== undefined && uniform_value.y !== undefined && uniform_value.z !== undefined && uniform_value.w !== undefined ) {
                    processed_uniforms[uniform_name] = { name: uniform_name, value: [uniform_value.x, uniform_value.y, uniform_value.z, uniform_value.w], type: SPE_LAYER_UNIFORM_TYPE_VEC4 };
                }
                else if ( uniform_value.r !== undefined && uniform_value.g !== undefined && uniform_value.b !== undefined && uniform_value.a !== undefined ) {
                    processed_uniforms[uniform_name] = { name: uniform_name, value: [uniform_value.r, uniform_value.g, uniform_value.b, uniform_value.a], type: SPE_LAYER_UNIFORM_TYPE_COLOR };
                }
            }
            else if ( uniform_value instanceof Array && typeof( uniform_value[0] ) === 'number' ) {
                if ( Number.isInteger( uniform_value[0] ) ) {
                    processed_uniforms[uniform_name] = { name: uniform_name, value: [].concat( uniform_value ), type: SPE_LAYER_UNIFORM_TYPE_ARRAY_INT };
                }
                else {
                    processed_uniforms[uniform_name] = { name: uniform_name, value: [].concat( uniform_value ), type: SPE_LAYER_UNIFORM_TYPE_ARRAY_FLOAT };
                }
            }
            else if ( uniform_value instanceof Array && uniform_value[0] instanceof Object && Object.entries( uniform_value[0] ).length === 2 ) {
                if ( uniform_value[0].x !== undefined && uniform_value[0].y !== undefined ) {
                    let arr_values = [];
                    for ( let i = 0; i < uniform_value.length; i++ ) {
                        arr_values = arr_values.concat( [uniform_value[i].x, uniform_value[i].y] );
                    }
                    processed_uniforms[uniform_name] = { name: uniform_name, value: arr_values, type: SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC2 };
                }
            }
            else if ( uniform_value instanceof Array && uniform_value[0] instanceof Object && Object.entries( uniform_value[0] ).length === 3 ) {
                if ( uniform_value[0].x !== undefined && uniform_value[0].y !== undefined && uniform_value[0].z !== undefined ) {
                    let arr_values = [];
                    for ( let i = 0; i < uniform_value.length; i++ ) {
                        arr_values = arr_values.concat( [uniform_value[i].x, uniform_value[i].y, uniform_value[i].z] );
                    }
                    processed_uniforms[uniform_name] = { name: uniform_name, value: arr_values, type: SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC3 };
                }
            }
            else if ( uniform_value instanceof Array && uniform_value[0] instanceof Object && Object.entries( uniform_value[0] ).length === 4 ) {
                if ( uniform_value[0].x !== undefined && uniform_value[0].y !== undefined && uniform_value[0].z !== undefined && uniform_value[0].w !== undefined ) {
                    let arr_values = [];
                    for ( let i = 0; i < uniform_value.length; i++ ) {
                        arr_values = arr_values.concat( [uniform_value[i].x, uniform_value[i].y, uniform_value[i].z, uniform_value[i].w] );
                    }
                    processed_uniforms[uniform_name] = { name: uniform_name, value: arr_values, type: SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC4 };
                }
            }
            else if ( uniform_value instanceof Array && uniform_value[0] instanceof THREE.Color ) {
                if ( uniform_value[0].x !== undefined && uniform_value[0].y !== undefined && uniform_value[0].z !== undefined && uniform_value[0].w !== undefined ) {
                    let arr_values = [];
                    for ( let i = 0; i < uniform_value.length; i++ ) {
                        arr_values = arr_values.concat( [uniform_value[i].r, uniform_value[i].g, uniform_value[i].b, uniform_value[i].a] );
                    }
                    processed_uniforms[uniform_name] = { name: uniform_name, value: arr_values, type: SPE_LAYER_UNIFORM_TYPE_ARRAY_COLOR };
                }
            }
            else if ( uniform_value instanceof Object && Object.entries( uniform_value ).length === 1 ) {
                if ( uniform_value.elements !== undefined && uniform_value.elements instanceof Array ) {
                    if ( uniform_value.elements.length === 9 ) {
                        processed_uniforms[uniform_name] = { name: uniform_name, value: [].concat( uniform_value.elements ), type: SPE_LAYER_UNIFORM_TYPE_MAT3 };
                    }
                    else if ( uniform_value.elements.length === 16 ) {
                        processed_uniforms[uniform_name] = { name: uniform_name, value: [].concat( uniform_value.elements ), type: SPE_LAYER_UNIFORM_TYPE_MAT4 };
                    }
                    else {
                        console.error( 'SpeLayer::preprocess_uniforms >>> unsupported matrix-type of uniform: ', uniform_value.elements );
                    }
                }
            }
            else if ( typeof ( uniform_value ) === 'string' ) {
                // Hash in the textures cache
                processed_uniforms[uniform_name] = { name: uniform_name, value: SPE.CachedTextures[uniform_value], type: SPE_LAYER_UNIFORM_TYPE_SAMPLER_2D };
            }
            else {
                console.error( 'SpeLayer::preprocess_uniforms >>> unsupported uniform-value: ', uniform_value );
            }
        }
        return processed_uniforms;
    };

    SPE.CreateLayerFromJSON = function( json, textures ) {
        const layer_id = json.id;
        const layer_type = json.type;
        const layer_uniforms = preprocess_uniforms( json.id, json.uniforms );
        const layer = SpeLayer.CreateLayer( layer_id, layer_type, layer_uniforms );
        return layer;
    };
}
class SpeBasicMaterial extends THREE.MeshPhongMaterial {

    constructor( layers = {}, parameters = {} ) {
        super( parameters );

        this.mLayersList = null;
        // Construct layers-list with given initial layers
        if ( Object.keys( layers ).length > 0 ) {
            this.mLayersList = new SpeLayersList( layers );
            // Add callback for shader-code injection
            this.onBeforeCompile = SpeShaderLib.GetSetupCallback( this );
        }
    }

    get layersList() {
        return this.mLayersList;
    }

    set layersList( obj ) {
        this.mLayersList = obj;
        this.onBeforeCompile = SpeShaderLib.GetSetupCallback( this );
    }

    copy( source ) {
        if ( !this.mLayersList ) {
            super.copy( source );
        }
        else {
            const layersList = source.layersList;
            source.layersList = undefined;
            super.copy( source );
            this.layerList = layersList.clone();
        }

        return this;
    }
};

class SpeLambertMaterial extends THREE.MeshLambertMaterial {

    constructor( layers = {}, parameters = {} ) {
        super( parameters );

        this.mLayersList = null;
        // Construct layers-list with given initial layers
        if ( Object.keys( layers ).length > 0 ) {
            this.mLayersList = new SpeLayersList( layers );
            // Add callback for shader-code injection
            this.onBeforeCompile = SpeShaderLib.GetSetupCallback( this );
        }
    }

    get layersList() {
        return this.mLayersList;
    }

    set layersList( obj ) {
        this.mLayersList = obj;
        this.onBeforeCompile = SpeShaderLib.GetSetupCallback( this );
    }

    copy( source ) {
        if ( !this.mLayersList ) {
            super.copy( source );
        }
        else {
            const layersList = source.layersList;
            source.layersList = undefined;
            super.copy( source );
            this.layerList = layersList.clone();
        }

        return this;
    }
};

class SpePhongMaterial extends THREE.MeshPhongMaterial {

    constructor( layers = {}, parameters = {} ) {
        super( parameters );

        this.mLayersList = null;
        // Construct layers-list with given initial layers
        if ( Object.keys( layers ).length > 0 ) {
            this.mLayersList = new SpeLayersList( layers );
            // Add callback for shader-code injection
            this.onBeforeCompile = SpeShaderLib.GetSetupCallback( this );
        }
    }

    get layersList() {
        return this.mLayersList;
    }

    set layersList( obj ) {
        this.mLayersList = obj;
        this.onBeforeCompile = SpeShaderLib.GetSetupCallback( this );
    }

    copy( source ) {
        if ( !this.mLayersList ) {
            super.copy( source );
        }
        else {
            const layersList = source.layersList;
            source.layersList = undefined;
            super.copy( source );
            this.layerList = layersList.clone();
        }

        return this;
    }
};

class SpePhysicalMaterial extends THREE.MeshPhysicalMaterial {

    constructor( layers = {}, parameters = {} ) {
        // Set default roughness to 0.3
        if ( parameters.roughness === undefined ) parameters.roughness = 0.3;

        super( parameters );

        this.mLayersList = null;
        // Construct layers-list with given initial layers
        if ( Object.keys( layers ).length > 0 ) {
            this.mLayersList = new SpeLayersList( layers );
            // Add callback for shader-code injection
            this.onBeforeCompile = SpeShaderLib.GetSetupCallback( this );
        }
    }

    get layersList() {
        return this.mLayersList;
    }

    set layersList( obj ) {
        this.mLayersList = obj;
        this.onBeforeCompile = SpeShaderLib.GetSetupCallback( this );
    }

    copy( source ) {
        if ( !this.mLayersList ) {
            super.copy( source );
        }
        else {
            const layersList = source.layersList;
            source.layersList = undefined;
            super.copy( source );
            this.layerList = layersList.clone();
        }

        return this;
    }
};

class SpeToonMaterial extends THREE.MeshToonMaterial {

    constructor( layers = {}, parameters = {} ) {
        super( parameters );

        this.mLayersList = null;
        // Construct layers-list with given initial layers
        if ( Object.keys( layers ).length > 0 ) {
            this.mLayersList = new SpeLayersList( layers );
            // Add callback for shader-code injection
            this.onBeforeCompile = SpeShaderLib.GetSetupCallback( this );
        }
    }

    get layersList() {
        return this.mLayersList;
    }

    set layersList( obj ) {
        this.mLayersList = obj;
        this.onBeforeCompile = SpeShaderLib.GetSetupCallback( this );
    }

    copy( source ) {
        if ( !this.mLayersList ) {
            super.copy( source );
        }
        else {
            const layersList = source.layersList;
            source.layersList = undefined;
            super.copy( source );
            this.layerList = layersList.clone();
        }

        return this;
    }
};
/* Cache used to store loaded fonts by name-id */
var SpeFontsCache = {};
/* Cache used to store character geometric-data by char */
var SpeCharsCache = {};
/* Path to the font resources */
const SPE_PATH_FONTS = 'assets/fonts/';
/* Default font to be used for texts in the scene */
const SPE_DEFAULT_TEXT_FONT = 'roboto_regular';
/* Default character used if no character is given by the user */
const SPE_DEFAULT_TEXT_CHARACTER = '.';
/* Default level of detail for the characters of text in the scene */
const SPE_DEFAULT_TEXT_LOD = 16;

/* Returns a promiise linked to a font-resource to be loaded */
function SpeLoadFont( font_family ) {
    return new Promise( function( resolve, reject ) {
        if ( !SpeFontsCache[font_family] ) {
            const font_loader = new THREE.FontLoader();
            const font_resource_path = SPE_PATH_FONTS + font_family + '.json';
            font_loader.load( font_resource_path, function( font ) {
                SpeFontsCache[font_family] = font;
                resolve( font );
            } );
        }
        else {
            resolve( SpeFontsCache[font_family] );
        }
    } );
};

/* Retuns the required character data used to contruct a character in the scene */
function SpeLoadCharData( char, font_family, lod ) {
    if ( SpeCharsCache[char] ) {
        if ( SpeCharsCache[char][lod] && SpeCharsCache[char][lod]['fontFamily'] === font_family ) {
            return SpeCharsCache[char][lod];
        }
    }
    else {
        SpeCharsCache[char] = {}; // Initialize the cache for this character
    }

    const font = ( SpeFontsCache[font_family] !== undefined ) ? SpeFontsCache[font_family] : SpeFontsCache[SPE_DEFAULT_TEXT_FONT];
    const shape = font.generateShapes( char, 1 );

    SpeCharsCache[char][lod] = { geometry: new THREE.ShapeBufferGeometry( shape, lod ),
                                 fontFamily: font_family,
                                 resolution: font.data.resolution,
                                 glyphsHa: font.data.glyphs[char].ha };
    return SpeCharsCache[char][lod];
};

class SpeTextChar3D extends SpeIMesh {

    constructor( parameters, material ) {
        // Get the geometric-data for this character
        const char = ( parameters.char !== undefined ) ? parameters.char : SPE_DEFAULT_TEXT_CHARACTER;
        const font_family = ( parameters.fontFamily !== undefined ) ? parameters.fontFamily : SPE_DEFAULT_TEXT_FONT;
        const lod = ( parameters.lod !== undefined ) ? parameters.lod : SPE_DEFAULT_TEXT_LOD;
        const char_data = SpeLoadCharData( char, font_family, lod );
        const char_geometry = char_data.geometry;
        super( char_geometry, material );

        this.mChar = char;
        this.mFontFamily = font_family;
        this.mLod = lod;

        this.mFontSize = ( parameters.fontSize !== undefined ) ? parameters.fontSize : 16;
        this.mLetterSpacing = ( parameters.letterSpacing !== undefined ) ? parameters.letterSpacing : 1;

        this.mResolution = char_data.resolution;
        this.mGlyphsHa = char_data.glyphsHa;
        this.mLocalPosition = new THREE.Vector2();
        this.mCharSize = this.mGlyphsHa * ( this.mFontSize / this.mResolution ) * this.mLetterSpacing;

        this.updateFontSize( this.mFontSize );
    }

    updateFontSize( fontSize ) {
        this.mFontSize = fontSize;
        this.mCharSize = this.mGlyphsHa * ( this.mFontSize / this.mResolution ) * this.mLetterSpacing;
        this.scale.set( this.mFontSize, this.mFontSize, 1 );
    }

};
class SpeTextContainer extends SpeIMesh {

    constructor( geometry, material ) {
        // Hide the plane geometry of the container
        material.visible = false;
        super( geometry, material );
    }
}

class SpeLoaderManager {

    constructor( assets ) {
        this.mAssets = assets || {};
        this.mOnFinishCallback = null;

        this.mNumAssetsToLoad = 0;
        this.mNumAssetsLoaded = 0;
    }

    run( finish_callback ) {
        this.mOnFinishCallback = finish_callback;
        // Start loading process
        const fonts = ( this.mAssets.fonts !== undefined ) ? this.mAssets.fonts : [];
        const images = ( this.mAssets.images !== undefined ) ? this.mAssets.images : [];
        const models = ( this.mAssets.models !== undefined ) ? this.mAssets.models : [];
        const animations = ( this.mAssets.animations !== undefined ) ? this.mAssets.animations : [];

        this.mNumAssetsLoaded = 0;
        this.mNumAssetsToLoad = fonts.length + images.length + models.length + animations.length;
        if ( this.mNumAssetsToLoad < 1 ) {
            this.mOnFinishCallback();
        }
        else {
            const self = this;
            // Load fonts using three-js built-in font loader **************************************
            for ( let i = 0; i < fonts.length; i++ ) {
                const font_loader = new THREE.FontLoader();
                const font_family = fonts[i];
                const font_resource_path = SPE_PATH_FONTS + font_family + '.json';
                font_loader.load( font_resource_path, function( font ) {
                    SpeFontsCache[font_family] = font;
                    self.mNumAssetsLoaded++;
                    if ( self.mNumAssetsLoaded === self.mNumAssetsToLoad ) {
                        self.mOnFinishCallback();
                    }
                } );
            }

            // Load images using three-js built-in textures loader *********************************
            // @todo: implement me

            // Load models using three-js build-in model loaders ***********************************
            // @todo: implement me

            // Load animations using three-js build-in animation loader ****************************
            // @todo: implement me
        }
    }
}
class SpeRuntime {

    /**
    *   Creates a runtime given some configuration parameters
    *   @param {Object} gltfScene Scene description in GLTF-format
    *   @param {Object} assets List of assets to be pre-loaded
    *   @param {Object} config Configuration parameters of the runtime
    */
    constructor( gltfScene, assets, config = {} ) {
        this.mGltfScene = gltfScene;
        this.mConfig = config;

        this.mViewportMode = SPE_RUNTIME_VIEWMODE_FULLSCREEN;
        this.mViewportWidth = window.innerWidth;
        this.mViewportHeight = window.innerHeight;

        const canvas = document.getElementById( 'canvas3d' );
        this.mRenderer = new THREE.WebGLRenderer( { antialias: true, alpha: true, canvas: canvas } );
        this.mRenderer.setPixelRatio( window.devicePixelRatio );
        this.mRenderer.setSize( this.mViewportWidth, this.mViewportHeight );
        this.mRenderer.shadowMap.enabled = true;
        this.mRenderer.shadowMap.type = THREE.PCFSoftShadowMap;

        this.mScene = new SpeScene();
        this.mSceneOptions = {};

        this.mMainCamera = null;
        this.mOrbitControls = null;
        this.mPlayHandler = null;

        this.mRunning = false;

        this.mLoaderManager = new SpeLoaderManager( assets );
        this.mLoaderManager.run( this.onRuntimeAssetsLoaded.bind( this ) );
    }

    run() {
        requestAnimationFrame( this.run.bind( this ) );
        // Update and render the current scene
        this.onRender();
    }

    onRuntimeAssetsLoaded() {
        console.info( 'SpeRuntime >>> Finished loading assets for the spline-runtime' );
        // Load the given scene in GLTF format
        this.loadFromGltf( this.mGltfScene );
        // Setup resize-callback properly
        window.addEventListener( 'resize', this.onResize.bind( this ) );
        // Let the runtime know that we're currently running
        this.mRunning = true;
        // Force resize to fit the current window size
        this.onResize();
    }

    /**
    *   Renders the scene using the internal renderer
    */
    onRender() {
        if ( !this.mRunning )
            return;

        if ( SPE_USES_PREVIEW_IMAGE ) {
            document.querySelector( '.spline-preview-image-container' ).style.display = 'none';

            SPE_USES_PREVIEW_IMAGE = false;
        }

        if ( this.mPlayHandler && !this.mPlayHandler.isEnable ) {
            this.mPlayHandler.activate();
        }

        if ( this.mOrbitControls ) {
            this.mOrbitControls.update();
        }
        if ( this.mScene && this.mMainCamera ) {
            this.mRenderer.autoClear = true;
            this.mRenderer.render( this.mScene, this.mMainCamera );
        }
    }

    /**
    *   Updates the viewport according to the applied resize operation
    */
    onResize() {
        if ( !this.mRunning )
            return;

        if ( this.mViewportMode === SPE_RUNTIME_VIEWMODE_FULLSCREEN ||
             this.mViewportMode === SPE_RUNTIME_VIEWMODE_FULL_WIDTH ) {
            this.mViewportWidth = window.innerWidth;
        }
        if ( this.mViewportMode === SPE_RUNTIME_VIEWMODE_FULLSCREEN ||
             this.mViewportMode === SPE_RUNTIME_VIEWMODE_FULL_HEIGHT ) {
            this.mViewportHeight = window.innerHeight;
        }

        if ( this.mMainCamera ) {
            if ( this.mMainCamera.type === 'PerspectiveCamera' ) {
                this.mMainCamera.aspect = this.mViewportWidth / this.mViewportHeight;
            }
            else if ( this.mMainCamera.type === 'OrthographicCamera' ) {
                this.mMainCamera.left = -this.mViewportWidth / 2;
                this.mMainCamera.right = this.mViewportWidth / 2;
                this.mMainCamera.top = this.mViewportHeight / 2;
                this.mMainCamera.bottom = -this.mViewportHeight / 2;
            }
            this.mMainCamera.updateProjectionMatrix();
        }
        if ( this.mRenderer ) {
            this.mRenderer.setSize( this.mViewportWidth, this.mViewportHeight );
        }
    }

    /**
    *   Creates a scene from a given description object in GLTF format
    *   @param {Object} gltfScene Description of the scene in GLTF format
    */
    loadFromGltf( gltfScene ) {
        const gltfDecoder = new SpeGltfDecoder( gltfScene );
        const [scene, camera, options] = gltfDecoder.decode();
        this.mScene = scene;
        this.mMainCamera = camera;
        this.mSceneOptions = options;

        const clearColor = ( this.mSceneOptions.bgColor !== undefined ) ?
                                new THREE.Color().fromArray( this.mSceneOptions.bgColor ) : 
                                new THREE.Color( 0x191919 );
        const clearAlpha = ( this.mSceneOptions.bgAlpha !== undefined ) ? 
                                this.mSceneOptions.bgAlpha : 0;
        this.mRenderer.setClearColor( clearColor, clearAlpha );

        this.mViewportMode = this.mSceneOptions.viewMode;
        this.mViewportWidth = this.mSceneOptions.viewWidth;
        this.mViewportHeight = this.mSceneOptions.viewHeight;

        if ( this.mSceneOptions.useOrbitControls ) {
            this.mOrbitControls = new THREE.OrbitControls( this.mMainCamera, this.mRenderer.domElement );
            this.mOrbitControls.target.fromArray( this.mSceneOptions.orbitTarget );
            this.mOrbitControls.enableRotate = this.mSceneOptions.cameraRotate;
            this.mOrbitControls.enablePan = this.mSceneOptions.cameraPan;
            this.mOrbitControls.enableZoom = this.mSceneOptions.cameraZoom;
            this.mOrbitControls.enableDamping = this.mSceneOptions.orbitDamped;

            if ( this.mSceneOptions.orbitDamped ) {
                this.mOrbitControls.rotateSpeed = 1.0;
                this.mOrbitControls.panSpeed = 1.0;
            }
            else {
                this.mOrbitControls.rotateSpeed = 1.0;
                this.mOrbitControls.panSpeed = 1.0;
            }
        }
        // Start animations using play-mode handler
        const INTERACTIONS_ENABLED = ( typeof Interaction === 'function' );
        if ( INTERACTIONS_ENABLED ) {
            this.mPlayHandler = new PlayMode( this.mRenderer.domElement, this.mScene, this.mMainCamera );
        }
    }
};
class SpeScene extends THREE.Scene {

    constructor() {
        super();
    }

    traverseEntity( fcn_callback ) {
        function traverse( object ) {
            if ( object instanceof SpeMesh3D || object instanceof SpeMesh2D ||
                 object instanceof SpeTextContainer || object instanceof THREE.Group ||
                 object instanceof SpeEmptyObject || object instanceof SPE.CombinedCamera ||
                 object instanceof SPE.LightSpot || object instanceof SPE.LightPoint || object instanceof SPE.LightDirectional  ) {
                // Call function callback provided by the user
                fcn_callback( object );
                // Traverse recursively to the object's children
                for ( let i = 0; i < object.children.length; i++ ) {
                    traverse( object.children[ i ] );
                }
            }
        }

        for ( let i = 0; i < this.children.length; i++ ) {
            traverse( this.children[ i ] );
        }
    }

};
class SpeShaderLib {

    static SetupShader( shader, material ) {
        // Blending modes and blending helper functions ********************************************
        shader.fragmentShader = `
            /* SPE-Blending helper functions */
            #define SPE_BLENDING_NORMAL 0
            #define SPE_BLENDING_MULTIPLY 1
            #define SPE_BLENDING_SCREEN 2
            #define SPE_BLENDING_OVERLAY 3
            vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
                return mix( a, b, alpha );
            }
            vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
                return mix( a, a * b, alpha );
            }
            vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
                vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
                return mix( a, tmp, alpha );
            }
            vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
                vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
                return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
            }
            vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
                /**/ if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
                else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
                else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
                else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
                return vec3( 1.0 );
            }
            ` + shader.fragmentShader;
        // *****************************************************************************************

        // Fresnel-layer feature requirements ******************************************************
        shader.vertexShader = `
            #ifdef SPE_USE_LAYER_FRESNEL
                varying vec3 vWorldViewDir;
                varying vec3 vWorldNormal;
            #endif /* SPE_USE_LAYER_FRESNEL */
            ` + shader.vertexShader;

        shader.fragmentShader = `
            #ifdef SPE_USE_LAYER_FRESNEL
                varying vec3 vWorldViewDir;
                varying vec3 vWorldNormal;
            #endif /* SPE_USE_LAYER_FRESNEL */
            ` + shader.fragmentShader;

        shader.vertexShader = shader.vertexShader.replace(
            '#include <project_vertex>',
            `
            #include <project_vertex>
            #ifdef SPE_USE_LAYER_FRESNEL
                vec4 fWorldPosition = modelMatrix * vec4( position, 1.0 );
                vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ? 
                                    ( fWorldPosition.xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );
                vWorldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );
            #endif /* SPE_USE_LAYER_FRESNEL */
            ` );
        // *****************************************************************************************

        // Shared declarations for layers that require barycentric coordinates *********************
        shader.vertexShader = `
            #if defined( SPE_USE_LAYER_POINTS ) || defined( SPE_USE_LAYER_LINES )
                attribute vec3 barycentric;
                varying vec3 vBarycentric;
            #endif /* SPE_USE_LAYER_POINTS || SPE_USE_LAYER_LINES */
        ` + shader.vertexShader;

        shader.vertexShader = shader.vertexShader.replace(
            '#include <begin_vertex>',
            `
            #include <begin_vertex>
            #if defined( SPE_USE_LAYER_POINTS ) || defined( SPE_USE_LAYER_LINES )
                vBarycentric = barycentric;
            #endif /* SPE_USE_LAYER_POINTS || SPE_USE_LAYER_LINES */
            ` );

        shader.fragmentShader = `
            #if defined( SPE_USE_LAYER_POINTS ) || defined( SPE_USE_LAYER_LINES )
                varying vec3 vBarycentric;
                float aastep( float threshold, float dist, float smoothOffset ) {
                    float afwidth = fwidth( dist ) * 0.5;
                    return smoothstep( threshold - afwidth - smoothOffset, threshold + afwidth + smoothOffset, dist );
                }
            #endif /* SPE_USE_LAYER_POINTS || SPE_USE_LAYER_LINES */
        ` + shader.fragmentShader;
        // *****************************************************************************************

        // Noise-layer feature requirements ********************************************************
        shader.fragmentShader = `
            #ifdef SPE_USE_LAYER_NOISE
                float random ( in vec2 _st ) {
                    return sin(sin(dot(_st.xy, vec2(12.834,77.212))) * 320.3456); // Ale: I am usin sin() instead of fract() to create a different noise.
                }
                float noise ( in vec2 _st ) {
                    vec2 i = floor(_st);
                    vec2 f = fract(_st);
                    // Four corners in 2D of a tile
                    float a = random(i);
                    float b = random(i + vec2(1.0, 0.0)); // Ale: By incrementing disproportionally these values. You get a geometrical distortion.
                    float c = random(i + vec2(0.0, 1.0));
                    float d = random(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }
                float fbm ( in vec2 _st ) {
                    float v = 0.0;
                    float a = 0.5;
                    vec2 shift = vec2(100.0);
                    // Rotate to reduce axial bias
                    mat2 rot = mat2(cos(0.5), sin(0.5),
                                    -sin(0.5), cos(0.50));
                    for (int i = 0; i < SPE_NOISE_NUM_OCTAVES; ++i) {
                        v += a * noise(_st);
                        _st = rot * _st * 2.0 + shift;
                        a *= 0.5;
                    }
                    return v;
                }
            #endif /* SPE_USE_LAYER_NOISE */
            ` + shader.fragmentShader;

        shader.fragmentShader = shader.fragmentShader.replace(
            '#include <normal_fragment_begin>', ''
        );

        shader.fragmentShader = shader.fragmentShader.replace(
            '#include <normal_fragment_maps>', ''
        )

        if ( material instanceof SpeBasicMaterial ) {
            shader.fragmentShader = shader.fragmentShader.replace(
               `#include <lights_phong_fragment>
                #include <lights_fragment_begin>
                #include <lights_fragment_maps>
                #include <lights_fragment_end>`, ''
            )
            shader.fragmentShader = shader.fragmentShader.replace(
                `vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;`,
                `vec3 outgoingLight = diffuseColor.rgb;`
            );
        }
        // Normal-layer feature requirements *******************************************************
        if ( material instanceof SpeLambertMaterial ) {

            shader.vertexShader = `
                #ifdef SPE_USE_LAYER_NORMAL
                    varying vec3 vNormal;
                #endif /* SPE_USE_LAYER_NORMAL */
                ` + shader.vertexShader;

            shader.vertexShader = shader.vertexShader.replace(
                '#include <defaultnormal_vertex>',
                `
                #include <defaultnormal_vertex>
                #ifdef SPE_USE_LAYER_NORMAL
                    vNormal = normalize( transformedNormal );
                #endif /* SPE_USE_LAYER_NORMAL */
                ` );

            shader.fragmentShader = `
                #ifdef SPE_USE_LAYER_NORMAL
                    varying vec3 vNormal;
                #endif /* SPE_USE_LAYER_NORMAL */
                ` + shader.fragmentShader;

            // Before lighting // @todo: check if this portion is not repeated lines below
            shader.fragmentShader = shader.fragmentShader.replace(
                'vec4 diffuseColor = vec4( diffuse, opacity );',
                `
                #ifdef SPE_USE_LAYER_NORMAL
                    #include <normal_fragment_begin>
                    #include <normal_fragment_maps>
                #endif /* SPE_USE_LAYER_NORMAL */
                    float accumAlpha = 0.0;
                    vec3 bef = vec3( 1.0 );
                    #before
                    vec4 diffuseColor = vec4( bef, 1.0 );
                ` );
        }
        // *****************************************************************************************

        // Depth-layer feature requirements ****************************************************
        shader.vertexShader = shader.vertexShader.replace(
            '#include <common>',
            `
            #include <common>
            #ifdef SPE_USE_LAYER_DEPTH
                varying vec4 dWorldPosition;
            #endif /* SPE_USE_LAYER_DEPTH */
            ` );

        shader.vertexShader = shader.vertexShader.replace(
            '#include <worldpos_vertex>',
            `
            #include <worldpos_vertex>
            #ifdef SPE_USE_LAYER_DEPTH
                dWorldPosition = modelMatrix * vec4( transformed, 1.0 );
            #endif
            ` );

        shader.fragmentShader = `
            #ifdef SPE_USE_LAYER_DEPTH
                varying vec4 dWorldPosition;
            #endif /* SPE_USE_LAYER_DEPTH */
            ` + shader.fragmentShader;
        // *************************************************************************************

        // Before lighting
        shader.fragmentShader = shader.fragmentShader.replace(
            'vec4 diffuseColor = vec4( diffuse, opacity );',
            `
                #include <normal_fragment_begin>
                #include <normal_fragment_maps>
                float accumAlpha = 0.0;
                vec3 bef = vec3( 1.0 );
                #before
                vec4 diffuseColor = vec4( bef, 1.0 );
            ` );

        // After lighting
        shader.fragmentShader = shader.fragmentShader.replace(
            'gl_FragColor = vec4( outgoingLight, diffuseColor.a );',
            `
                #lighting
                vec3 aft = outgoingLight;
                #after
                gl_FragColor = vec4( aft, accumAlpha * opacity );
            ` );
    }

    static GetSetupCallback( material ) {
        let string = '';
        for ( let i = 0; i < material.uuid.length; ++i ) {
            const c = material.uuid[ i ];
            if ( c != '-' ) string += c;
        }

        return eval( `shader => {
            // Hashing required as in issue https://github.com/mrdoob/three.js/issues/13192
            const __hash___${string} = true;
            const layersList = material.layersList;
            // Inject base functionality into both vertex and fragment shaders
            SpeShaderLib.SetupShader( shader, material );
            shader.uniforms = THREE.UniformsUtils.merge( [ shader.uniforms, layersList.getUniforms() ] );
            for ( let [key, uniform] of Object.entries( shader.uniforms ) ) {
                if ( uniform.value && uniform.value.isTexture ) {
                    uniform.value.needsUpdate = true;
                }
            }
            // Inject shader-code in fragment shader previous to the lighting step
            shader.fragmentShader = shader.fragmentShader.replace( '#before', layersList.getFragShaderCodePreLighting() );
            // Inject shader-code in fragment shader for the lighting step
            shader.fragmentShader = shader.fragmentShader.replace( '#lighting', layersList.getFragShaderCodeLighting() );
            // Inject shader-code in fragment shader after the lighting step
            shader.fragmentShader = shader.fragmentShader.replace( '#after', layersList.getFragShaderCodePostLighting() );
            // Inject uniforms variables in both vertex and fragment shaders
            shader.vertexShader = layersList.getVertUniformsCode() + shader.vertexShader;
            shader.fragmentShader = layersList.getFragUniformsCode() + shader.fragmentShader;
            // Inject defines in both vertex and fragment shaders
            shader.vertexShader = layersList.getDefinesCode() + shader.vertexShader;
            shader.fragmentShader = layersList.getDefinesCode() + shader.fragmentShader;
            // Link the shader to its related layers-list
            layersList.shader = shader;
        }` );
    }
};
class SpeStack {

    constructor() {
        this.elements = [];
    }

    push( element ) {
        this.elements.push( element );
    }

    pop() {
        if ( this.elements.length === 0 ) {
            return null;
        }
        return this.elements.pop();
    }

    top() {
        return this.elements[this.elements.length - 1];
    }

    empty() {
        return ( this.elements.length === 0 );
    }
}

class SpeQueue {

    constructor() {
        this.elements = [];
    }

    push( element ) {
        this.elements.push( element );
    }

    pop() {
        if ( this.elements.length === 0 ) {
            return null;
        }
        return this.elements.shift();
    }

    front() {
        return this.elements[0];
    }

    empty() {
        return ( this.elements.length === 0 );
    }
};// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

THREE.OrbitControls = function ( object, domElement ) {

    if ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter "domElement" is now mandatory.' );
    if ( domElement === document ) console.error( 'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

    this.object = object;
    this.domElement = domElement;

    // Set to false to disable this control
    this.enabled = true;

    // "target" sets the location of focus, where the object orbits around
    this.target = new THREE.Vector3();

    // How far you can dolly in and out ( PerspectiveCamera only )
    this.minDistance = 0;
    this.maxDistance = Infinity;

    // How far you can zoom in and out ( OrthographicCamera only )
    this.minZoom = 0;
    this.maxZoom = Infinity;

    // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.
    this.minPolarAngle = 0; // radians
    this.maxPolarAngle = Math.PI; // radians

    // How far you can orbit horizontally, upper and lower limits.
    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
    this.minAzimuthAngle = - Infinity; // radians
    this.maxAzimuthAngle = Infinity; // radians

    // Set to true to enable damping (inertia)
    // If damping is enabled, you must call controls.update() in your animation loop
    this.enableDamping = false;
    this.dampingFactor = 0.05;

    // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
    // Set to false to disable zooming
    this.enableZoom = true;
    this.zoomSpeed = 1.0;

    // Set to false to disable rotating
    this.enableRotate = true;
    this.rotateSpeed = 1.0;

    // Set to false to disable panning
    this.enablePan = true;
    this.panSpeed = 1.0;
    this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
    this.keyPanSpeed = 7.0; // pixels moved per arrow key push

    // Set to true to automatically rotate around the target
    // If auto-rotate is enabled, you must call controls.update() in your animation loop
    this.autoRotate = false;
    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

    // Set to false to disable use of the keys
    this.enableKeys = true;

    // The four arrow keys
    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

    // Mouse buttons
    this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };

    // Touch fingers
    this.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

    // for reset
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;

    //
    // public methods
    //

    this.getPolarAngle = function () {

        return spherical.phi;

    };

    this.getAzimuthalAngle = function () {

        return spherical.theta;

    };

    this.saveState = function () {

        scope.target0.copy( scope.target );
        scope.position0.copy( scope.object.position );
        scope.zoom0 = scope.object.zoom;

    };

    this.reset = function () {

        scope.target.copy( scope.target0 );
        scope.object.position.copy( scope.position0 );
        scope.object.zoom = scope.zoom0;

        scope.object.updateProjectionMatrix();
        scope.dispatchEvent( changeEvent );

        scope.update();

        state = STATE.NONE;

    };

    // this method is exposed, but perhaps it would be better if we can make it private...
    this.update = function () {

        var offset = new THREE.Vector3();

        // so camera.up is the orbit axis
        var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
        var quatInverse = quat.clone().inverse();

        var lastPosition = new THREE.Vector3();
        var lastQuaternion = new THREE.Quaternion();

        var twoPI = 2 * Math.PI;

        return function update() {

            var position = scope.object.position;

            offset.copy( position ).sub( scope.target );

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion( quat );

            // angle from z-axis around y-axis
            spherical.setFromVector3( offset );

            if ( scope.autoRotate && state === STATE.NONE ) {

                rotateLeft( getAutoRotationAngle() );

            }

            if ( scope.enableDamping ) {

                spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                spherical.phi += sphericalDelta.phi * scope.dampingFactor;

            } else {

                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;

            }

            // restrict theta to be between desired limits

            var min = scope.minAzimuthAngle;
            var max = scope.maxAzimuthAngle;

            if ( isFinite( min ) && isFinite( max ) ) {

                if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

                if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

                if ( min < max ) {

                    spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

                } else {

                    spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
                        Math.max( min, spherical.theta ) :
                        Math.min( max, spherical.theta );

                }

            }

            // restrict phi to be between desired limits
            spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

            spherical.makeSafe();


            spherical.radius *= scale;

            // restrict radius to be between desired limits
            spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

            // move target to panned location

            if ( scope.enableDamping === true ) {

                scope.target.addScaledVector( panOffset, scope.dampingFactor );

            } else {

                scope.target.add( panOffset );

            }

            offset.setFromSpherical( spherical );

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion( quatInverse );

            position.copy( scope.target ).add( offset );

            scope.object.lookAt( scope.target );

            if ( scope.enableDamping === true ) {

                sphericalDelta.theta *= ( 1 - scope.dampingFactor );
                sphericalDelta.phi *= ( 1 - scope.dampingFactor );

                panOffset.multiplyScalar( 1 - scope.dampingFactor );

            } else {

                sphericalDelta.set( 0, 0, 0 );

                panOffset.set( 0, 0, 0 );

            }

            scale = 1;

            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

            if ( zoomChanged ||
                lastPosition.distanceToSquared( scope.object.position ) > EPS ||
                8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

                scope.dispatchEvent( changeEvent );

                lastPosition.copy( scope.object.position );
                lastQuaternion.copy( scope.object.quaternion );
                zoomChanged = false;

                return true;

            }

            return false;

        };

    }();

    this.dispose = function () {

        scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );

        scope.domElement.removeEventListener( 'pointerdown', onPointerDown, false );
        scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

        scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
        scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
        scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

        scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove, false );
        scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp, false );

        scope.domElement.removeEventListener( 'keydown', onKeyDown, false );

        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

    };

    //
    // internals
    //

    var scope = this;

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    var STATE = {
        NONE: - 1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
    };

    var state = STATE.NONE;

    var EPS = 0.000001;

    // current position in spherical coordinates
    var spherical = new THREE.Spherical();
    var sphericalDelta = new THREE.Spherical();

    var scale = 1;
    var panOffset = new THREE.Vector3();
    var zoomChanged = false;

    var rotateStart = new THREE.Vector2();
    var rotateEnd = new THREE.Vector2();
    var rotateDelta = new THREE.Vector2();

    var panStart = new THREE.Vector2();
    var panEnd = new THREE.Vector2();
    var panDelta = new THREE.Vector2();

    var dollyStart = new THREE.Vector2();
    var dollyEnd = new THREE.Vector2();
    var dollyDelta = new THREE.Vector2();

    function getAutoRotationAngle() {

        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

    }

    function getZoomScale() {

        return Math.pow( 0.95, scope.zoomSpeed );

    }

    function rotateLeft( angle ) {

        sphericalDelta.theta -= angle;

    }

    function rotateUp( angle ) {

        sphericalDelta.phi -= angle;

    }

    var panLeft = function () {

        var v = new THREE.Vector3();

        return function panLeft( distance, objectMatrix ) {

            v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
            v.multiplyScalar( - distance );

            panOffset.add( v );

        };

    }();

    var panUp = function () {

        var v = new THREE.Vector3();

        return function panUp( distance, objectMatrix ) {

            if ( scope.screenSpacePanning === true ) {

                v.setFromMatrixColumn( objectMatrix, 1 );

            } else {

                v.setFromMatrixColumn( objectMatrix, 0 );
                v.crossVectors( scope.object.up, v );

            }

            v.multiplyScalar( distance );

            panOffset.add( v );

        };

    }();

    // deltaX and deltaY are in pixels; right and down are positive
    var pan = function () {

        var offset = new THREE.Vector3();

        return function pan( deltaX, deltaY ) {

            var element = scope.domElement;

            if ( scope.object.isPerspectiveCamera ) {

                // perspective
                var position = scope.object.position;
                offset.copy( position ).sub( scope.target );
                var targetDistance = offset.length();

                // half of the fov is center to top of screen
                targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

                // we use only clientHeight here so aspect ratio does not distort speed
                panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
                panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

            } else if ( scope.object.isOrthographicCamera ) {

                // orthographic
                panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
                panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

            } else {

                // camera neither orthographic nor perspective
                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
                scope.enablePan = false;

            }

        };

    }();

    function dollyOut( dollyScale ) {

        if ( scope.object.isPerspectiveCamera ) {

            scale /= dollyScale;

        } else if ( scope.object.isOrthographicCamera ) {

            scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;

        } else {

            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
            scope.enableZoom = false;

        }

    }

    function dollyIn( dollyScale ) {

        if ( scope.object.isPerspectiveCamera ) {

            scale *= dollyScale;

        } else if ( scope.object.isOrthographicCamera ) {

            scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;

        } else {

            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
            scope.enableZoom = false;

        }

    }

    //
    // event callbacks - update the object state
    //

    function handleMouseDownRotate( event ) {

        rotateStart.set( event.clientX, event.clientY );

    }

    function handleMouseDownDolly( event ) {

        dollyStart.set( event.clientX, event.clientY );

    }

    function handleMouseDownPan( event ) {

        panStart.set( event.clientX, event.clientY );

    }

    function handleMouseMoveRotate( event ) {

        rotateEnd.set( event.clientX, event.clientY );

        rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

        var element = scope.domElement;

        rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

        rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

        rotateStart.copy( rotateEnd );

        scope.update();

    }

    function handleMouseMoveDolly( event ) {

        dollyEnd.set( event.clientX, event.clientY );

        dollyDelta.subVectors( dollyEnd, dollyStart );

        if ( dollyDelta.y > 0 ) {

            dollyOut( getZoomScale() );

        } else if ( dollyDelta.y < 0 ) {

            dollyIn( getZoomScale() );

        }

        dollyStart.copy( dollyEnd );

        scope.update();

    }

    function handleMouseMovePan( event ) {

        panEnd.set( event.clientX, event.clientY );

        panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

        pan( panDelta.x, panDelta.y );

        panStart.copy( panEnd );

        scope.update();

    }

    function handleMouseUp( /*event*/ ) {

        // no-op

    }

    function handleMouseWheel( event ) {

        if ( event.deltaY < 0 ) {

            dollyIn( getZoomScale() );

        } else if ( event.deltaY > 0 ) {

            dollyOut( getZoomScale() );

        }

        scope.update();

    }

    function handleKeyDown( event ) {

        var needsUpdate = false;

        switch ( event.keyCode ) {

            case scope.keys.UP:
                pan( 0, scope.keyPanSpeed );
                needsUpdate = true;
                break;

            case scope.keys.BOTTOM:
                pan( 0, - scope.keyPanSpeed );
                needsUpdate = true;
                break;

            case scope.keys.LEFT:
                pan( scope.keyPanSpeed, 0 );
                needsUpdate = true;
                break;

            case scope.keys.RIGHT:
                pan( - scope.keyPanSpeed, 0 );
                needsUpdate = true;
                break;

        }

        if ( needsUpdate ) {

            // prevent the browser from scrolling on cursor keys
            event.preventDefault();

            scope.update();

        }


    }

    function handleTouchStartRotate( event ) {

        if ( event.touches.length == 1 ) {

            rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

        } else {

            var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
            var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

            rotateStart.set( x, y );

        }

    }

    function handleTouchStartPan( event ) {

        if ( event.touches.length == 1 ) {

            panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

        } else {

            var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
            var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

            panStart.set( x, y );

        }

    }

    function handleTouchStartDolly( event ) {

        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

        var distance = Math.sqrt( dx * dx + dy * dy );

        dollyStart.set( 0, distance );

    }

    function handleTouchStartDollyPan( event ) {

        if ( scope.enableZoom ) handleTouchStartDolly( event );

        if ( scope.enablePan ) handleTouchStartPan( event );

    }

    function handleTouchStartDollyRotate( event ) {

        if ( scope.enableZoom ) handleTouchStartDolly( event );

        if ( scope.enableRotate ) handleTouchStartRotate( event );

    }

    function handleTouchMoveRotate( event ) {

        if ( event.touches.length == 1 ) {

            rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

        } else {

            var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
            var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

            rotateEnd.set( x, y );

        }

        rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

        var element = scope.domElement;

        rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

        rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

        rotateStart.copy( rotateEnd );

    }

    function handleTouchMovePan( event ) {

        if ( event.touches.length == 1 ) {

            panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

        } else {

            var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
            var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

            panEnd.set( x, y );

        }

        panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

        pan( panDelta.x, panDelta.y );

        panStart.copy( panEnd );

    }

    function handleTouchMoveDolly( event ) {

        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

        var distance = Math.sqrt( dx * dx + dy * dy );

        dollyEnd.set( 0, distance );

        dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

        dollyOut( dollyDelta.y );

        dollyStart.copy( dollyEnd );

    }

    function handleTouchMoveDollyPan( event ) {

        if ( scope.enableZoom ) handleTouchMoveDolly( event );

        if ( scope.enablePan ) handleTouchMovePan( event );

    }

    function handleTouchMoveDollyRotate( event ) {

        if ( scope.enableZoom ) handleTouchMoveDolly( event );

        if ( scope.enableRotate ) handleTouchMoveRotate( event );

    }

    function handleTouchEnd( /*event*/ ) {

        // no-op

    }

    //
    // event handlers - FSM: listen for events and reset state
    //

    function onPointerDown( event ) {

        if ( scope.enabled === false ) return;

        switch ( event.pointerType ) {

            case 'mouse':
            case 'pen':
                onMouseDown( event );
                break;

            // TODO touch

        }

    }

    function onPointerMove( event ) {

        if ( scope.enabled === false ) return;

        switch ( event.pointerType ) {

            case 'mouse':
            case 'pen':
                onMouseMove( event );
                break;

            // TODO touch

        }

    }

    function onPointerUp( event ) {

        if ( scope.enabled === false ) return;

        switch ( event.pointerType ) {

            case 'mouse':
            case 'pen':
                onMouseUp( event );
                break;

            // TODO touch

        }

    }

    function onMouseDown( event ) {

        // Prevent the browser from scrolling.
        event.preventDefault();

        // Manually set the focus since calling preventDefault above
        // prevents the browser from setting it automatically.

        scope.domElement.focus ? scope.domElement.focus() : window.focus();

        var mouseAction;

        switch ( event.button ) {

            case 0:

                mouseAction = scope.mouseButtons.LEFT;
                break;

            case 1:

                mouseAction = scope.mouseButtons.MIDDLE;
                break;

            case 2:

                mouseAction = scope.mouseButtons.RIGHT;
                break;

            default:

                mouseAction = - 1;

        }

        switch ( mouseAction ) {

            case THREE.MOUSE.DOLLY:

                if ( scope.enableZoom === false ) return;

                handleMouseDownDolly( event );

                state = STATE.DOLLY;

                break;

            case THREE.MOUSE.ROTATE:

                if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

                    if ( scope.enablePan === false ) return;

                    handleMouseDownPan( event );

                    state = STATE.PAN;

                } else {

                    if ( scope.enableRotate === false ) return;

                    handleMouseDownRotate( event );

                    state = STATE.ROTATE;

                }

                break;

            case THREE.MOUSE.PAN:

                if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

                    if ( scope.enableRotate === false ) return;

                    handleMouseDownRotate( event );

                    state = STATE.ROTATE;

                } else {

                    if ( scope.enablePan === false ) return;

                    handleMouseDownPan( event );

                    state = STATE.PAN;

                }

                break;

            default:

                state = STATE.NONE;

        }

        if ( state !== STATE.NONE ) {

            scope.domElement.ownerDocument.addEventListener( 'pointermove', onPointerMove, false );
            scope.domElement.ownerDocument.addEventListener( 'pointerup', onPointerUp, false );

            scope.dispatchEvent( startEvent );

        }

    }

    function onMouseMove( event ) {

        if ( scope.enabled === false ) return;

        event.preventDefault();

        switch ( state ) {

            case STATE.ROTATE:

                if ( scope.enableRotate === false ) return;

                handleMouseMoveRotate( event );

                break;

            case STATE.DOLLY:

                if ( scope.enableZoom === false ) return;

                handleMouseMoveDolly( event );

                break;

            case STATE.PAN:

                if ( scope.enablePan === false ) return;

                handleMouseMovePan( event );

                break;

        }

    }

    function onMouseUp( event ) {

        if ( scope.enabled === false ) return;

        handleMouseUp( event );

        scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove, false );
        scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp, false );

        scope.dispatchEvent( endEvent );

        state = STATE.NONE;

    }

    function onMouseWheel( event ) {

        if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

        event.preventDefault();
        event.stopPropagation();

        scope.dispatchEvent( startEvent );

        handleMouseWheel( event );

        scope.dispatchEvent( endEvent );

    }

    function onKeyDown( event ) {

        if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

        handleKeyDown( event );

    }

    function onTouchStart( event ) {

        if ( scope.enabled === false ) return;

        event.preventDefault(); // prevent scrolling

        switch ( event.touches.length ) {

            case 1:

                switch ( scope.touches.ONE ) {

                    case THREE.TOUCH.ROTATE:

                        if ( scope.enableRotate === false ) return;

                        handleTouchStartRotate( event );

                        state = STATE.TOUCH_ROTATE;

                        break;

                    case THREE.TOUCH.PAN:

                        if ( scope.enablePan === false ) return;

                        handleTouchStartPan( event );

                        state = STATE.TOUCH_PAN;

                        break;

                    default:

                        state = STATE.NONE;

                }

                break;

            case 2:

                switch ( scope.touches.TWO ) {

                    case THREE.TOUCH.DOLLY_PAN:

                        if ( scope.enableZoom === false && scope.enablePan === false ) return;

                        handleTouchStartDollyPan( event );

                        state = STATE.TOUCH_DOLLY_PAN;

                        break;

                    case THREE.TOUCH.DOLLY_ROTATE:

                        if ( scope.enableZoom === false && scope.enableRotate === false ) return;

                        handleTouchStartDollyRotate( event );

                        state = STATE.TOUCH_DOLLY_ROTATE;

                        break;

                    default:

                        state = STATE.NONE;

                }

                break;

            default:

                state = STATE.NONE;

        }

        if ( state !== STATE.NONE ) {

            scope.dispatchEvent( startEvent );

        }

    }

    function onTouchMove( event ) {

        if ( scope.enabled === false ) return;

        event.preventDefault(); // prevent scrolling
        event.stopPropagation();

        switch ( state ) {

            case STATE.TOUCH_ROTATE:

                if ( scope.enableRotate === false ) return;

                handleTouchMoveRotate( event );

                scope.update();

                break;

            case STATE.TOUCH_PAN:

                if ( scope.enablePan === false ) return;

                handleTouchMovePan( event );

                scope.update();

                break;

            case STATE.TOUCH_DOLLY_PAN:

                if ( scope.enableZoom === false && scope.enablePan === false ) return;

                handleTouchMoveDollyPan( event );

                scope.update();

                break;

            case STATE.TOUCH_DOLLY_ROTATE:

                if ( scope.enableZoom === false && scope.enableRotate === false ) return;

                handleTouchMoveDollyRotate( event );

                scope.update();

                break;

            default:

                state = STATE.NONE;

        }

    }

    function onTouchEnd( event ) {

        if ( scope.enabled === false ) return;

        handleTouchEnd( event );

        scope.dispatchEvent( endEvent );

        state = STATE.NONE;

    }

    function onContextMenu( event ) {

        if ( scope.enabled === false ) return;

        event.preventDefault();

    }

    //

    scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

    scope.domElement.addEventListener( 'pointerdown', onPointerDown, false );
    scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

    scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
    scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
    scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

    scope.domElement.addEventListener( 'keydown', onKeyDown, false );

    // make sure element can receive keys.

    if ( scope.domElement.tabIndex === - 1 ) {

        scope.domElement.tabIndex = 0;

    }

    // force an update at start

    this.update();

};

THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;


// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move

THREE.MapControls = function ( object, domElement ) {

    THREE.OrbitControls.call( this, object, domElement );

    this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

    this.mouseButtons.LEFT = THREE.MOUSE.PAN;
    this.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;

    this.touches.ONE = THREE.TOUCH.PAN;
    this.touches.TWO = THREE.TOUCH.DOLLY_ROTATE;

};

THREE.MapControls.prototype = Object.create( THREE.EventDispatcher.prototype );
THREE.MapControls.prototype.constructor = THREE.MapControls;
/**
 * @author nisa
 * 
 */

function InteractionEvent( type, key ) {	

	this.targets = [];

	this._type = type;
	this.key = key; // used by KEY_DOWN and KEY_UP interactions
	this.ui = { isCollapsed: false };

}

InteractionEvent.TYPE = {
	MOUSE_DOWN: 0,
	MOUSE_UP: 1,
	MOUSE_HOVER: 2,
	MOUSE_ENTER: 3,
	MOUSE_LEAVE: 4,
	KEY_DOWN: 5,
	KEY_UP: 6,
	START: 7,
	LOOK_AT: 8,
	SCROLL: 9,
};
InteractionEvent.ORDER = [
	InteractionEvent.TYPE.MOUSE_DOWN,
	InteractionEvent.TYPE.MOUSE_UP,
	InteractionEvent.TYPE.MOUSE_HOVER,
	InteractionEvent.TYPE.KEY_DOWN,
];

InteractionEvent.prototype = {

	constructor: InteractionEvent,

	get type() {

		return this._type;

	},

	set type( type ) {
	
		this._type = type;

		if ( type !== InteractionEvent.TYPE.KEY_DOWN && type !== InteractionEvent.TYPE.KEY_UP ) {

			this.key = undefined;

		}
		
	},

	//

	newTarget: function( object ) {

		const target = new InteractionTarget();
		target.object = object;
		if ( object.interaction.states.length > 0 ) target.state = object.interaction.states[ object.interaction.states.length - 1 ];
		
		this.targets.push( target );
		
		Interaction.targets.add( target );

		return target;

	},

	addTarget: function( target, index ) {

		this.targets.splice( index, 0, target );

		Interaction.targets.add( target );

	},

	removeTarget: function( index ) {

		Interaction.targets.delete( this.targets[ index ] );
		
		this.targets.splice( index, 1 );

	},

	//

	dispatchReverse: function() {
		
		for ( let i = 0, l = this.targets.length; i < l; ++i ) {

			const target = this.targets[ i ];

			if ( target.state !== undefined ) {

				target.object.interaction.reverse( target );

			}

		}

	},

	dispatch: function() {

		for ( let i = 0, l = this.targets.length; i < l; ++i ) {
		
			const target = this.targets[ i ];

			if ( target.state !== undefined ) {

				target.object.interaction.play( target );

			}

		}
		
	},

	//

	copy: function( source ) {

		this.ui.isCollapsed = source.ui.isCollapsed;
		
		return this;

	},

	clone: function() {

		return new InteractionEvent( this.type, this.key ).copy( this );

	},

	toJSON: function( meta ) {

		const data = {
			type: this._type,
			key: this.key,
			ui: { isCollapsed: this.ui.isCollapsed }
		}

		if ( this.targets.length > 0 ) {

			data.targets = [];

			for ( let i = 0, l = this.targets.length; i < l; ++i ) {

				data.targets.push( this.targets[ i ].toJSON( meta ) );

			}
		}

		return data;

	},

	fromJSON: function( data, objects, states ) {

		this._type = data.type;
		this.key = data.key;
		this.targets = [];
		this.ui = { isCollapsed: data.ui.isCollapsed };

		if ( data.targets !== undefined ) {

			for ( let i = 0, l = data.targets.length; i < l; ++i ) {

				this.addTarget( new InteractionTarget().fromJSON( data.targets[ i ], objects, states ) );

			}

		}

		return this;

	}
	
};/**
 * @author nisa
 * 
 */

function Interaction( object ) {

	this.uuid = THREE.MathUtils.generateUUID();
	this.object = object;
	this.states = [];
	this.events = [];
	this.selectedState;

	// for animation
	this.animation;
	this.currentState; // current
	this.prevState; // previous

	this.statesManager = new InteractionStatesManager( this );
	
}

Interaction.targets = new Set();

Interaction.prototype = {

	constructor: Interaction,

	newState: function( name ) {

		const state = new InteractionState();
		state.name = name;
		state.update( this.object );
		
		this.selectedState = this.states.length;

		this.states.push( state );
		return state;

	},

	addState: function( state, index ) {

		this.states.splice( index, 0, state );

	},

	removeState: function( index ) {

		if ( this.selectedState === index ) this.selectedState = undefined;
		this.states.splice( index, 1 );

	},
	
	selectState: function( index ) {

		if ( index !== undefined ) this.states[ index ].execute( this.object );

		this.selectedState = index;

	},

	//

	getEventType: function( type ) {

		return this.events.find( event => event.type === type );

	},

	hasEventType: function( type, key ) {

		if ( type === InteractionEvent.TYPE.KEY_DOWN || type === InteractionEvent.TYPE.KEY_UP ) {

			if ( key === undefined ) return false;

			return this.events.some( event => event.type === type && event.key === key );

		} 

		return this.events.some( event => event.type === type );

	},

	newEvent: function() {

		const type = InteractionEvent.ORDER.find( type => this.hasEventType( type ) === false )
		const event = new InteractionEvent( type );
		this.events.push( event );

		return event;

	},

	addEvent: function( event, index ) {

		this.events.splice( index, 0, event );

		const targets = this.events[ index ].targets;

		for ( let i = 0, l = targets.length; i < l; ++i ) {

			if ( targets[ i ].object !== undefined ) {

				Interaction.targets.add( targets[ i ] );

			}

		}

	},

	removeEvent: function( index ) {

		const targets = this.events[ index ].targets;

		for ( let i = 0, l = targets.length; i < l; ++i ) {

			if ( targets[ i ].object !== undefined ) {

				Interaction.targets.delete( targets[ i ] );

			}

		}

		//

		this.events.splice( index, 1 );

	},

	//

	copy: function( source ) {

		this.selectedState = source.selectedState;
		
		for ( let i = 0, l = source.states.length; i < l; ++i ) {

			this.addState( source.states[ i ].clone(), i );

		}

		for ( let i = 0, l = source.events.length; i < l; ++i ) {

			this.addEvent( source.events[ i ].clone(), i );

			const sourceTargets = source.events[ i ].targets;

			for ( let j = 0, lj = sourceTargets.length; j < lj; ++j ) {

				const clone = sourceTargets[ j ].clone();
				
				if ( sourceTargets[ j ].object === source.object ) {

					clone.object = this.object;
					clone.state = this.states[ source.states.indexOf( sourceTargets[ j ].state ) ];

				} else {

					clone.object = sourceTargets[ j ].object;
					clone.state = sourceTargets[ j ].state;

				}

				this.events[ i ].addTarget( clone, j );
	
			}

		}

		return this;

	},

	clone: function( object ) {

		return new Interaction( object ).copy( this );

	},

	toJSON: function( meta ) {

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}
		
		const data = {};
		data.uuid = this.uuid;
			
		if ( this.selectedState !== undefined ) data.selectedState = this.selectedState;

		if ( this.states.length > 0) {

			data.states = [];

			for ( let i = 0, l = this.states.length; i < l; ++i ) {
	
				data.states.push( serialize( meta.interactionStates, this.states[ i ] ) );
	
			}

		}

		if ( this.events.length > 0 ) {

			data.events = [];

			for ( let i = 0, l = this.events.length; i < l; ++i ) {
	
				data.events.push( this.events[ i ].toJSON( meta ) );
	
			}

		}

		return data;

	},

	fromJSON: function( data, objects, states ) {
		
		this.uuid = data.uuid;
		this.selectedState = data.selectedState;
		this.states = [];
		this.events = [];

		if ( data.states !== undefined ) {

			for ( let i = 0, l = data.states.length; i < l; ++i ) {
				
				this.states.push( states[ data.states[ i ] ] );

			}

		}

		if ( data.events !== undefined ) {

			for ( let i = 0, l = data.events.length; i < l; ++i ) {
				
				this.events.push( new InteractionEvent().fromJSON( data.events[ i ], objects, states ) );

			}

		}
		
		return this;

	},

	//

	start: function() {

		if ( this.animation !== undefined ) {
			
			this.animation.pause();	
			this.animation = undefined;
			this._removeBackLayer();

		}

		if ( this.states.length > 1 ) {

			this.states[ 0 ].execute( this.object );
			this.currentState = this.states[ 0 ];
			this.prevState = undefined;

			const interactionEvent = this.getEventType( InteractionEvent.TYPE.START );

			if ( interactionEvent !== undefined && interactionEvent.targets.length > 0 ) {

				this.play( interactionEvent.targets[ 0 ] );

			}

		}

	},

	end: function() {

		if ( this.animation !== undefined ) {
			
			this.animation.pause();	
			this.animation = undefined;
			this._removeBackLayer();

		}

		if ( this.states.length > 1 ) {
		
			this.states[ this.selectedState ].execute( this.object );

		}

		this.currentState = undefined;
		this.prevState = undefined;
		
	},

	lookAt: function( mouseX, mouseY ) {

		const fly = new THREE.Vector3( mouseX, mouseY, -600 );
		
  		this.object.lookAt( fly );

	},

	play: function( target ) {

		// Open the link stored in the target by the user
		// if ( IsValidURL( target.url ) ) {
		// 	window.open( target.url, '_blank' );
		// }

		if ( target.state !== undefined ) {

			this.animate( target.state, target );

		}

	},

	reverse: function( target ) {

		// Open the link stored in the target by the user
		// if ( IsValidURL( target.url ) ) {
		// 	window.open( target.url, '_blank' );
		// }

		this.animate( this.prevState, target );

	},

	_removeBackLayer: function() {

		if ( this.object.material !== undefined ) {

			const material = this.object.material;

			if ( Array.isArray( material ) ) {

				for ( let i = 0, l = material.length; i < l; ++i ) {

					const layers = material[ i ].layersList;
					let layer = layers.head;

					while ( layer ) {

						if ( layer.backLayer ) {

							delete layer.backLayer;
							const tmp = layer.next;
							layers.removeLayer( layer.id );
							layer = tmp;

						} else if ( layer.isBack ) { 
						
							delete layer.isBack;
							layer = layer.next;

						} else {

							layer = layer.next;

						}

					}

				}

			} else {

				const layers = material.layersList;
				let layer = layers.head;

				while ( layer ) {

					while ( layer ) {

						if ( layer.backLayer ) {

							delete layer.backLayer;
							const tmp = layer.next;
							layers.removeLayer( layer.id );
							layer = tmp;

						} else if ( layer.isBack ) { 
						
							delete layer.isBack;
							layer = layer.next;

						} else {

							layer = layer.next;

						}

					}

				}

			}
			
		}

	},

	getTimingFunction: function( easing, cubicControls, springParameters ) {

		switch ( easing ) {
			// https://www.w3.org/TR/css-easing-1/#cubic-bezier-easing-functions
			case InteractionTarget.EASING.LINEAR: 
				return 'cubicBezier( 0, 0, 1, 1 )';
			case InteractionTarget.EASING.EASE:
				return 'cubicBezier( .25, .1, .25, 1 )';
			case InteractionTarget.EASING.EASE_IN: 
				return 'cubicBezier( .42, 0, 1, 1 )';
			case InteractionTarget.EASING.EASE_OUT: 
				return 'cubicBezier( 0, 0, .58, 1 )';
			case InteractionTarget.EASING.EASE_IN_OUT: 
				return 'cubicBezier( .42, 0, .58, 1 )';
			case InteractionTarget.EASING.CUBIC: 
				// return 'cubicBezier( .5, .05, .1, .3 )';
				return `cubicBezier( ${cubicControls[ 0 ]}, ${cubicControls[ 1 ]}, ${cubicControls[ 2 ]}, ${cubicControls[ 3 ]} )`;
			case InteractionTarget.EASING.SPRING: 
				// return 'spring( 1, 80, 10, 0 )';
				return `spring( ${springParameters.mass}, ${springParameters.stiffness}, ${springParameters.damping}, ${springParameters.velocity} )`;

		}

	},

	animate: function( state, target ) {

		// update current and previous state
		if ( this.currentState !== state ) {
			
			this.prevState = this.currentState;
			this.currentState = state;
	
		}

		// pause previous animations
		if ( this.animation !== undefined ) this.animation.pause();	
		this._removeBackLayer();

		if ( target.cycle === true && target.repeat === true ) {

			this.animation = anime.timeline( {
				duration: target.duration,
				delay: target.delay / 2, // PATCH, to solve bug on anime.js
				endDelay: target.delay / 2, // PATCH, to solve bug on anime.js
				direction: 'alternate',
				loop: true,
				rewind: target.rewind,
				easing: this.getTimingFunction( target.easing, target.cubicControls, target.springParameters ),
			} );

		} else if ( target.cycle === true && target.repeat === false ) {
		
			this.animation = anime.timeline( {
				duration: target.duration,
				delay: target.delay, // PATCH, to solve bug on anime.js
				endDelay: target.delay / 2, // PATCH, to solve bug on anime.js
				direction: 'alternate',
				// loop: 1,
				rewind: target.rewind,
				easing: this.getTimingFunction( target.easing, target.cubicControls, target.springParameters ),
			} );

		} else if ( target.cycle === false && target.repeat === true ) {

			this.animation = anime.timeline( {
				duration: target.duration,
				delay: target.delay,
				direction: 'normal',
				loop: true,
				easing: this.getTimingFunction( target.easing, target.cubicControls, target.springParameters ),
			} );

		} else {

			this.animation = anime.timeline( {
				duration: target.duration,
				delay: target.delay,
				direction: 'normal',
				easing: this.getTimingFunction( target.easing, target.cubicControls, target.springParameters ),
			} );

		}

		this.animation.finished.then( () => {

			this._removeBackLayer();

		} );

		this.animateMatrix( state );
		this.animateGeometry( state );
		this.animateMaterial( state );
		this.animateCamera( state );
		
	},

	animateMatrix: function( state ) {

		if ( this.object.position.equals( state.position ) === false ) {
				
			const pStart = this.object.position.clone();
			const tween = { t: 0 };

			this.animation.add( {
				targets: tween,
				t: 1,
				// targets: this.object.position,
				// x: state.position.x,
				// y: state.position.y,
				// z: state.position.z,
				update: () => { 

					this.object.position.lerpVectors( pStart, state.position, tween.t );
				
				}
			}, 0 );

		}

		if ( this.object.scale.equals( state.scale ) === false ) {
				
			const sStart = this.object.scale.clone();
			const tween = { t: 0 };

			this.animation.add( {
				targets: tween,
				t: 1,
				update: () => { 

					this.object.scale.lerpVectors( sStart, state.scale, tween.t );
				
				}
			}, 0 );

		}

		if ( this.object.rotation.equals( state.rotation ) === false ) {
				
			const qStart = this.object.quaternion.clone();
			// const qEnd = new THREE.Quaternion().setFromEuler( state.rotation );
			const tween = { t: 0 };

			// PATCH to rotate with 360 || - 360
			const diff = { 
				x: this.object.rotation.x - state.rotation.x,
				y: this.object.rotation.y - state.rotation.y,
				z: this.object.rotation.z - state.rotation.z
			};
			const rotation = state.rotation.clone();
			const deg0 = 0.01 * THREE.Math.DEG2RAD;
			const deg360 = 359.99 * THREE.Math.DEG2RAD;
			
			if ( diff.x === Math.PI * 2 ) {
				
				if ( rotation.x === 0 ) rotation.x = deg0;
				else if ( rotation.x === Math.PI * 2 ) rotation.x = deg360;

			} else if ( diff.x === - Math.PI * 2 ) {
				
				if ( rotation.x === 0 ) rotation.x = - deg0;
				else if ( rotation.x === Math.PI * 2 ) rotation.x = - deg360;

			}

			if ( diff.y === Math.PI * 2 ) {
				
				if ( rotation.y === 0 ) rotation.y = deg0;
				else if ( rotation.y === Math.PI * 2 ) rotation.y = deg360;

			}else if ( diff.y === - Math.PI * 2 ) {
				
				if ( rotation.y === 0 ) rotation.y = - deg0;
				else if ( rotation.y === Math.PI * 2 ) rotation.y = - deg360;

			}

			if ( diff.z === Math.PI * 2 ) {
				
				if ( rotation.z === 0 ) rotation.z = deg0;
				else if ( rotation.z === Math.PI * 2 ) rotation.z = deg360;
			
			} else if ( diff.z === - Math.PI * 2 ) {
				
				if ( rotation.z === 0 ) rotation.z = - deg0;
				else if ( rotation.z === Math.PI * 2 ) rotation.z = - deg360;

			}
			
			const qEnd = new THREE.Quaternion().setFromEuler( rotation );

			this.animation.add( {
				targets: tween,
				t: 1,
				update: () => { 

					// THREE.Quaternion.slerp( qStart, qEnd, this.object.quaternion, tween.t );
					SPE.Math.slerp( qStart, qEnd, this.object.quaternion, tween.t );
					
				}
			}, 0 );

		}

		const pStart = new THREE.Vector3();
		const qStart = new THREE.Quaternion();
		const sStart = new THREE.Vector3();
		const pEnd = new THREE.Vector3();
		const qEnd = new THREE.Quaternion();
		const sEnd = new THREE.Vector3();
		const pTarget = new THREE.Vector3();
		const qTarget = new THREE.Quaternion();
		const sTarget = new THREE.Vector3();

		this.object.hiddenMatrix.decompose( pStart, qStart, sStart );
		state.hiddenMatrix.decompose( pEnd, qEnd, sEnd );

		if ( this.object.hiddenMatrix.equals( state.hiddenMatrix ) === false ) {
			
			const tween = { t: 0 };

			this.animation.add( {
				targets: tween,
				t: 1,
				update: () => { 
					
					THREE.Quaternion.slerp( qStart, qEnd, qTarget, tween.t );
					pTarget.lerpVectors( pStart, pEnd, tween.t );
					sTarget.lerpVectors( sStart, sEnd, tween.t );
					this.object.hiddenMatrix.compose( pTarget, qTarget, sTarget );

				}
			}, 0 );
	
		}

	},

	animateGeometry: function( state ) {

		if ( this.object.geometry === undefined ) return;
	
		const parameters = this.object.geometry.userData.parameters;

		if ( state.geometry.width !== parameters.width || state.geometry.height !== parameters.height || state.geometry.depth !== parameters.depth ) {

			this.animation.add( {
				targets: this.object.geometry.userData.parameters,
				width: state.geometry.width,
				height: state.geometry.height,
				depth: state.geometry.depth,
				update: () => {
					
					const geometry = SPE[ this.object.geometry.userData.type ].buildFromGeometry(
						this.object.geometry,
						{ width: parameters.width, height: parameters.height, depth: parameters.depth }
					);
					this.object.updateGeometry( geometry );

				}
			}, 0 );

		}

	},

	animateMaterial: function( state ) {

		if ( this.object.material === undefined ) return;

		const interpolateBetweenValues = ( material, layer, targetLayer, paramNames ) => {

			const layers = material.layersList;
			paramNames = paramNames !== undefined ? paramNames : layer.paramNames;

			for( let i = 0, l = paramNames.length; i < l; ++i ) {

				const param = paramNames[ i ];
				const key = `f${layer.id}_${param}`;
				const targetKey = `f${targetLayer.id}_${param}`;
				const uniform = layer.uniforms[ key ];
				const targetUniform = targetLayer.uniforms[ targetKey ];

				if ( param === 'mode' || typeof uniform.value === 'boolean' ) {
					
					if ( uniform.value !== targetUniform.value ) {

						uniform.value = targetUniform.value;
						layers.updateLayerUniformByLayer( layer, key );

					}
					continue;

				}

				if ( typeof uniform.value === 'number' ) {

					if ( uniform.value !== targetUniform.value ) {

						this.animation.add( {
							targets: uniform,
							value: targetUniform.value,
							update: function() { layers.updateLayerUniformByLayer( layer, key ); }
						}, 0 );

					}
					continue;

				}

				if ( uniform.value instanceof THREE.Vector2 ) {

					if ( uniform.value.equals( targetUniform.value ) === false ) {

						this.animation.add( {
							targets: uniform.value,
							x: targetUniform.value.x,
							y: targetUniform.value.y,
							update: function() { layers.updateLayerUniformByLayer( layer, key ); }
						}, 0 );

					}
					continue;

				}

				if ( uniform.value instanceof THREE.Vector3 ) {

					if ( uniform.value.equals( targetUniform.value ) === false ) {

						this.animation.add( {
							targets: uniform.value,
							x: targetUniform.value.x,
							y: targetUniform.value.y,
							z: targetUniform.value.z,
							update: function() { layers.updateLayerUniformByLayer( layer, key ); }
						}, 0 );

					}
					continue;

				}
				
				if ( uniform.value instanceof THREE.Color ) {

					if ( uniform.value.equals( targetUniform.value ) === false ) {

						this.animation.add( {
							targets: uniform.value,
							r: targetUniform.value.r,
							g: targetUniform.value.g,
							b: targetUniform.value.b,
							update: function() { layers.updateLayerUniformByLayer( layer, key ); }
						}, 0 );

					}
					continue;

				}

			}

			if ( layer.backLayer ) {

				const backId = layer.backLayer.id;
				const backKey = `f${backId}_alpha`;
				const backUniform = layer.backLayer.uniforms[ backKey ];
				
				this.animation.add( {
					targets: backUniform,
					value: 0,
					update: function() { layers.updateLayerUniform( backId, backKey ); }
				}, 0 );
	
			}

		};

		const interpolateBetweenLayers = ( material, layer, targetLayer ) => {

			const layers = material.layersList;

			if ( layer.backLayer === undefined ) {

				const params = targetLayer.getValues();
				params[ 'alpha' ] = 0;

				layer.backLayer = layers.addLayerBeforeAt( params, layer );
				layer.backLayer.isBack = true;
				material.dispose();

			}

			const key = `f${layer.id}_alpha`;
			const backKey = `f${layer.backLayer.id}_alpha`;
			const uniform = layer.uniforms[ key ];
			const backUniform = layer.backLayer.uniforms[ backKey ];

			this.animation
			.add( {
				targets: uniform,
				value: 0,
				update: function() { layers.updateLayerUniformByLayer( layer, key ); },
			}, 0 )
			.add( {
				targets: backUniform,
				value: targetLayer.uniforms[ `f${targetLayer.id}_alpha` ].value,
				update: function() { layers.updateLayerUniformByLayer( layer.backLayer, backKey ); }
			}, 0 );
			
		};

		const interpolateTexture = ( material, layer, targetLayer ) => {

			const layers = material.layersList;
	
			const matKey = `f${layer.id}_mat`;
			const textureKey = `f${layer.id}_texture` ;

			const texture = layer.uniforms[ textureKey ].value;
			const targetTexture = targetLayer.uniforms[ `f${targetLayer.id}_texture` ].value;

			const cropUniform = layer.uniforms[ `f${layer.id}_crop` ];
			const targetCropUniform = targetLayer.uniforms[ `f${targetLayer.id}_crop` ];

			if ( cropUniform.value !== targetCropUniform.value ) {
					
				cropUniform.value = targetCropUniform.value;
				layers.updateLayerUniformByLayer( layer, `f${layer.id}_crop` );

			}

			if ( texture.wrapS !== targetTexture.wrapS || texture.wrapT !== targetTexture.wrapT ) {

				texture.wrapS = targetTexture.wrapS;
				texture.wrapT = targetTexture.wrapT;
				texture.needsUpdate = true;
				layers.updateLayerUniform( layer, textureKey );

			}

			if ( texture.matrix.equals( targetTexture.matrix ) === false ) {

				const value = {
					repeatX: texture.repeat.x, 
					repeatY: texture.repeat.y,
					offsetX: texture.offset.x,
					offsetY: texture.offset.y
				}

				this.animation.add( {
					targets: value,
					repeatX: targetTexture.repeat.x, 
					repeatY: targetTexture.repeat.y,
					offsetX: targetTexture.offset.x,
					offsetY: targetTexture.offset.y,
					update: function() { 

						texture.repeat.set( value.repeatX, value.repeatY );
						texture.offset.set( value.offsetX, value.offsetY );
						texture.updateMatrix();
						layers.updateLayerUniformByLayer( layer, matKey );
					
					}
				}, 0 );

			}

			interpolateBetweenValues( material, layer, targetLayer, [ 'alpha', 'mode' ] );

		}

		const interpolateGradient = ( material, layer, targetLayer ) => {

			const layers = material.layersList;
	
			const numUniform = layer.uniforms[ `f${layer.id}_num` ];
			const targetNumUniform = targetLayer.uniforms[ `f${targetLayer.id}_num` ];

			const stepKey = `f${layer.id}_steps`;
			const targetStepKey = `f${targetLayer.id}_steps`;
			const stepUniform = layer.uniforms[ stepKey ];
			const targetStepUniform = targetLayer.uniforms[ targetStepKey ];

			const colorKey = `f${layer.id}_colors`;
			const targetColorKey = `f${targetLayer.id}_colors`;
			const colorUniform = layer.uniforms[ colorKey ];
			const targetColorUniform = targetLayer.uniforms[ targetColorKey ];
			
			// from lowest to highest steps
			if ( numUniform.value <= targetNumUniform.value ) {

				// initialize the steps color that doesn't have pair, use the color of the last current step
				const targetVector = colorUniform.value[ numUniform.value - 1 ];

				for ( let i = numUniform.value; i < targetNumUniform.value; ++i ) {

					stepUniform.value[ i ] = 1;
					layers.updateLayerUniformByLayer( layer, colorKey );
					
					colorUniform.value[ i ].set( targetVector.x, targetVector.y, targetVector.z, targetVector.w );
					layers.updateLayerUniformByLayer( layer, stepKey );

				}

				// set the number of the steps
				if ( numUniform.value !== targetNumUniform.value ) {
					
					numUniform.value = targetNumUniform.value;
					layers.updateLayerUniformByLayer( layer, `f${layer.id}_num` );

				}

				// interpolate the steps color
				for ( let i = 0; i < targetNumUniform.value; ++i ) {
		
					const vector = colorUniform.value[ i ];
					const targetVector = targetColorUniform.value[ i ];

					if ( stepUniform.value[ i ] !== targetStepUniform.value[ i ] || vector.equals( targetVector ) === false ) {

						const step = { value: stepUniform.value[ i ] };
				
						this.animation.add( {
							targets: [ step, vector ],
							value: targetStepUniform.value[ i ],
							x: targetVector.x, 
							y: targetVector.y, 
							z: targetVector.z, 
							w: targetVector.w,
							update: function() { 

								stepUniform.value[ i ] = step.value;
								layers.updateLayerUniformByLayer( layer, stepKey );
								layers.updateLayerUniformByLayer( layer, colorKey );
							
							}
						}, 0 );

					}
					
				}
				
			// from highest to lowest steps	
			} else {

				const promises = [];

				// interpolate the steps color that have pair
				for ( let i = 0; i < targetNumUniform.value; ++i ) {
		
					const vector = colorUniform.value[ i ];
					const targetVector = targetColorUniform.value[ i ];

					if ( stepUniform.value[ i ] !== targetStepUniform.value[ i ] || vector.equals( targetVector ) === false ) {

						promises.push( new Promise( resolve => { 

							const step = { value: stepUniform.value[ i ] };
					
							this.animation.add( {
								targets: [ step, vector ],
								value: targetStepUniform.value[ i ],
								x: targetVector.x, 
								y: targetVector.y, 
								z: targetVector.z, 
								w: targetVector.w,
								update: function() { 

									stepUniform.value[ i ] = step.value;
									layers.updateLayerUniformByLayer( layer, stepKey );
									layers.updateLayerUniformByLayer( layer, colorKey );
								
								},
								complete: function() { resolve( i ); }
							}, 0 );

						} ) );

					}
					
				}

				// interpolate the steps color that doesn't have pair
				const targetVector = targetColorUniform.value[ targetNumUniform.value - 1 ];

				for ( let i = targetNumUniform.value; i < numUniform.value; ++i ) {
		
					const vector = colorUniform.value[ i ];

					if ( stepUniform.value[ i ] !== targetStepUniform.value[ i ] || vector.equals( targetVector ) === false ) {

						promises.push( new Promise( resolve => { 

							const step = { value: stepUniform.value[ i ] };
					
							this.animation.add( {
								targets: [ step, vector ],
								value: 1, 
								x: targetVector.x, 
								y: targetVector.y, 
								z: targetVector.z, 
								w: targetVector.w,
								update: function() { 

									stepUniform.value[ i ] = step.value;
									layers.updateLayerUniformByLayer( layer, stepKey );
									layers.updateLayerUniformByLayer( layer, colorKey );
								
								},
								complete: function() { resolve( i ); }
							}, 0 );

						} ) );

					}
					
				}

				// set the number of the steps when all the interpolation has finished
				Promise.all( promises ).then( function() {

					numUniform.value = targetNumUniform.value;
					layers.updateLayerUniformByLayer( layer, `f${layer.id}_num` );

				} );

			}

			interpolateBetweenValues( material, layer, targetLayer, [ 'alpha', 'mode', 'gl_type', 'smooth', 'offset', 'morph', 'angle' ] );

		}

		function interpolate( material, targetMaterial ) {

			let layer = material.layersList.head;
			let i = 0;

			while( layer ) {

				if ( layer.isBack === true ) { // avoid the back layer
					
					layer = layer.next; 
					continue; 
			
				}

				const targetLayer = targetMaterial.layersList[ i++ ];
							
				if ( layer.type === 'texture' ) {
					
					const texture = layer.uniforms[ `f${layer.id}_texture` ].value;
					const targetTexture = targetLayer.uniforms[ `f${targetLayer.id}_texture` ].value;

					if ( texture.image === targetTexture.image ) {

						interpolateTexture( material, layer, targetLayer );

					} else {

						interpolateBetweenLayers( material, layer, targetLayer );

					}

				} else if ( layer.type === 'gradient' ) { 
					
					if ( layer.uniforms[ `f${layer.id}_gl_type` ].value === targetLayer.uniforms[ `f${targetLayer.id}_gl_type` ].value ) {

						interpolateGradient( material, layer, targetLayer );

					} else {
						
						interpolateBetweenLayers( material, layer, targetLayer );

					}

				} else {

					interpolateBetweenValues( material, layer, targetLayer );
					
				}

				layer = layer.next;

			}

		}

		if ( Array.isArray( this.object.material ) ) {

			for ( let i = 0, l = this.object.material.length; i < l; ++i ) {
				
				interpolate( this.object.material[ i ], state.material[ i ] );

			}

		} else {

			interpolate( this.object.material, state.material );

		}

	},

	animateCamera: function( state ) {

		if ( ! this.object.isCamera ) return;

		if ( this.object.zoom !== state.zoom ) {

			this.animation.add( {
				targets: this.object,
				zoom: state.zoom,
				update: () => {

					this.object.updateProjectionMatrix();

				}
			}, 0 );

		}

	}

};

// Taken from https://stackoverflow.com/questions/5717093/check-if-a-javascript-string-is-a-url
function IsValidURL( str ) {
	if ( str.indexOf( 'https' ) === -1 ) {
		console.warn( 'Tried opening an url without https protocol' );
		return false;
	}

	var pattern = new RegExp('^(https?:\\/\\/)?'+ // protocol
		'((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|'+ // domain name
		'((\\d{1,3}\\.){3}\\d{1,3}))'+ // OR ip (v4) address
		'(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*'+ // port and path
		'(\\?[;&a-z\\d%_.~+=-]*)?'+ // query string
		'(\\#[-a-z\\d_]*)?$','i'); // fragment locator
	return !!pattern.test( str );
}/**
 * @author nisa
 * 
 */

function InteractionState() {

	this.uuid = THREE.MathUtils.generateUUID();
	
	this.name;
	this.position = new THREE.Vector3();
	this.rotation = new THREE.Euler();
	this.scale = new THREE.Vector3();
	this.hiddenMatrix = new THREE.Matrix4();
	
}

InteractionState.prototype = {

	constructor: InteractionState,

	update: function( object ) {

		this.updateMatrix( object );
		this.updateGeometry( object );
		this.updateMaterial( object );
		this.updateCamera( object );

	},

	updateCamera( object ) {

		if ( object.isCamera ) {

			this.zoom = object.zoom;

		}

	},

	updateMatrix: function( object ) {

		this.position.copy( object.position );
		this.rotation.copy( object.rotation );
		this.scale.copy( object.scale );
		this.hiddenMatrix.copy( object.hiddenMatrix );

	},

	updateGeometry: function( object ) {

		if ( object.geometry !== undefined ) {

			const parameters = object.geometry.userData.parameters;

			this.geometry = {
				width: parameters.width,
				height: parameters.height,
				depth: parameters.depth
			}

		}

	},

	updateMaterial: function( object ) {

		if ( object.material !== undefined ) {

			if ( Array.isArray( object.material ) === true ) {

				this.material = [];

				for ( let i = 0, l = object.material.length; i < l; ++i ) {

					const layersList = [];
					let layer = object.material[ i ].layersList.head;
					
					while ( layer ) {

						layersList.push( layer.clone() );
						layer = layer.next;
			
					}

					this.material.push( { layersList: layersList } );

				}

			} else {

				const layersList = [];
				let layer = object.material.layersList.head;
				
				while ( layer ) {

					layersList.push( layer.clone() );
					layer = layer.next;
		
				}

				this.material = { layersList: layersList };
			
			}

		}

	},

	execute: function( object ) {

		object.position.copy( this.position );
		object.rotation.copy( this.rotation );
		object.scale.copy( this.scale );
		object.hiddenMatrix.copy( this.hiddenMatrix );

		if ( object.geometry !== undefined ) {

			const parameters = object.geometry.userData.parameters;

			if ( this.geometry.width !== parameters.width || this.geometry.height !== parameters.height || this.geometry.depth !== parameters.depth ) {

				const geometry = SPE[ object.geometry.userData.type ].buildFromGeometry(
					object.geometry,
					{ width: this.geometry.width, height: this.geometry.height, depth: this.geometry.depth }
				);
				object.updateGeometry( geometry );
				// object.resizeGeometry( thi-s.width, this.height, this.depth );

			}

		}

		if ( object.material !== undefined ) {

			const material = object.material;

			if ( Array.isArray( material ) === true ) {

				for ( let i = 0, l = this.material.length; i < l; ++i ) {
				
					let layer = material[ i ].layersList.head;
					const targetLayers = this.material[ i ].layersList;
					let j = 0;

					while( layer ) {
	
						layer.copy( targetLayers[ j++ ] );
						layer = layer.next;
	
					}	
				
					material[ i ].dispose();

				}

			} else {

				let layer = material.layersList.head;
				const targetLayers = this.material.layersList;
				let i = 0;

				while( layer ) { 
					
					layer.copyUniforms( targetLayers[ i++ ] );
					layer = layer.next;

				}

				material.dispose();

			}

		}

		if ( object.isCamera ) {

			object.zoom = this.zoom;
			object.updateProjectionMatrix();

		}

	},

	//

	copy: function( source ) {

		this.name = source.name;
		this.position.copy( source.position );
		this.rotation.copy( source.rotation );
		this.scale.copy( source.scale );
		this.hiddenMatrix.copy( source.hiddenMatrix );
		
		if ( source.geometry !== undefined ) {

			this.geometry = {
				width: source.geometry.width,
				height: source.geometry.height,
				depth: source.geometry.depth
			}

		}

		if ( source.material !== undefined ) {

			if ( Array.isArray( source.material ) === true ) {

				this.material = [];

				for ( let i = 0, l = source.material.length; i < l; ++i ) {

					this.material.push( { 
						layersList: source.material[ i ].layersList.map( layer => layer.clone() ) 
					} );

				}

			} else {

				this.material = {
					layersList: source.material.layersList.map( layer => layer.clone() )
				};
				
			}

		}

		if ( source.isCamera ) {

			this.zoom = source.zoom;

		}
		
		return this;

	},

	clone: function() {

		return new InteractionState().copy( this );

	},

	toJSON: function( meta ) {

		const data = {
			uuid: this.uuid,
			name: this.name,
			position: this.position.toArray(),
			rotation: this.rotation.toArray(),
			scale: this.scale.toArray(),
			hiddenMatrix: this.hiddenMatrix.toArray()
		};

		if ( this.geometry !== undefined ) {

			data.geometry = {
				width: this.geometry.width,
				height: this.geometry.height,
				depth: this.geometry.depth
			};

		}

		if ( this.material !== undefined ) {
						
			if ( Array.isArray( this.material ) === true ) {

				data.material = [];

				for ( let i = 0, l = this.material.length; i < l; ++i ) {

					data.material.push( { 
						layersList: this.material[ i ].layersList.map( layer => layer.toJSON( meta ) ) 
					} );

				}

			} else {
				
				data.material = {
					layersList: this.material.layersList.map( layer => layer.toJSON( meta ) )
				};
			
			}

		}

		if ( this.isCamera ) {

			data.zoom = this.zoom;

		}
		
		return data;

	},

	fromJSON: function( data, textures ) {

		this.uuid = data.uuid;
		this.name = data.name;
		
		this.position.fromArray( data.position );
		if ( data.rotation !== undefined ) {
			
			this.rotation.fromArray( data.rotation );
			
		} else {

			const quaternion = new THREE.Quaternion().fromArray( data.quaternion );  // PATCH: changing the version
			this.rotation.setFromQuaternion( quaternion );

		}
		this.scale.fromArray( data.scale );
		this.hiddenMatrix.fromArray( data.hiddenMatrix );

		if ( data.geometry !== undefined ) {

			this.geometry = {
				width: data.geometry.width,
				height: data.geometry.height,
				depth: data.geometry.depth
			};

		}

		if ( data.material !== undefined ) {

			if ( Array.isArray( data.material ) === true ) {

				this.material = [];

				for ( let i = 0, l = data.material.length; i < l; ++i ) {

					this.material.push( { 
						layersList: data.material[ i ].layersList.map( layer => SPE.CreateLayerFromJSON( layer, textures ) ) 
					} );

				}

			} else {
				
				this.material = {
					layersList: data.material.layersList.map( layer => SPE.CreateLayerFromJSON( layer, textures ) )
				};
			
			}

		}

		this.zoom = data.zoom !== undefined ? data.zoom : 1;

		return this;

	}

};
/**
 * @author nisa
 * 
 */

function InteractionTarget() {	

	this._object;
	this.state;

	this.easing = InteractionTarget.EASING.EASE_IN_OUT;
	this.duration = 1000;
	this.delay = 0;
	this.cubicControls = [ .5, .05, .1, .3 ];
	this.springParameters = { mass: 1, stiffness: 80, damping: 10, velocity: 0 };
	this.repeat = false;
	this.cycle = false;
	this.rewind = false;
	this.url = '';
}

InteractionTarget.EASING = {
	LINEAR: 0,
	EASE: 1,
	EASE_IN: 2,
	EASE_OUT: 3,
	EASE_IN_OUT: 4,
	CUBIC: 5,
	SPRING: 6
};

InteractionTarget.prototype = {

	constructor: InteractionTarget,

	get sp_mass() {

		return this.springParameters.mass;

	},

	set sp_mass( mass ) {

		this.springParameters.mass = mass;

	},

	get sp_stiffness() {

		return this.springParameters.stiffness;

	},

	set sp_stiffness( stiffness ) {

		this.springParameters.stiffness = stiffness;

	},

	get sp_damping() {

		return this.springParameters.damping;

	},
	
	set sp_damping( damping ) {

		this.springParameters.damping = damping;

	},

	get sp_velocity() {

		return this.springParameters.velocity;

	},

	set sp_velocity( velocity ) {

		this.springParameters.velocity = velocity;

	},

	get interaction() {

		return this._object !== undefined ? this._object.interaction : undefined;

	},

	get object() {

		return this._object;

	},

	set object( object ) {

		if ( object !== undefined ) {

			const states = object.interaction.states;
			this.state = states.length > 0 ? states[ states.length - 1 ] : undefined;

		} else {

			this.state = undefined;

		}

		this._object = object;

	},

	//

	copy: function( source ) {

		// this._object = source._object;
		// this.state = source.state;

		this.easing = source.easing;
		this.duration = source.duration;
		this.delay = source.delay;
		this.cubicControls = [ ...source.cubicControls ];
		this.springParameters = { 
			mass: source.springParameters.mass, 
			stiffness: source.springParameters.stiffness, 
			damping: source.springParameters.damping, 
			velocity: source.springParameters.velocity 
		};
		this.repeat = source.repeat;
		this.cycle = source.cycle;
		this.rewind = source.rewind;

		return this;

	},

	clone: function() {

		return new InteractionTarget().copy( this );

	},

	toJSON: function() {

		const data = {
			easing: this.easing,
			duration: this.duration,
			delay: this.delay,
			cubicControls: this.cubicControls,
			springParameters: { 
				mass: this.springParameters.mass, 
				stiffness: this.springParameters.stiffness, 
				damping: this.springParameters.damping, 
				velocity: this.springParameters.velocity 
			},
			repeat: this.repeat,
			cycle: this.cycle,
			rewind: this.rewind
		};

		if ( this.object !== undefined ) data.object = this.object.uuid;
		if ( this.state !== undefined ) data.state = this.state.uuid;

		return data;

	},

	fromJSON: function( data, objects, states ) { 
		
		if ( data.object !== undefined ) this._object = objects[ data.object ];
		if ( data.state !== undefined ) this.state = states[ data.state ];
		this.easing = data.easing;
		this.duration = data.duration;
		this.delay = data.delay;
		this.cubicControls = [ ...data.cubicControls ];
		this.repeat = data.repeat;
		this.cycle = data.cycle;
		this.rewind = data.rewind !== undefined ? data.rewind : false;  // PATCH: changing version

		if ( data.springControls !== undefined ) { // PATCH: changing version

			this.springParameters.mass = data.springControls[ 0 ];
			this.springParameters.stiffness = data.springControls[ 1 ];
			this.springParameters.damping = data.springControls[ 2 ];
			this.springParameters.velocity = data.springControls[ 3 ];

		} else {

			this.springParameters.mass = data.springParameters.mass;
			this.springParameters.stiffness = data.springParameters.stiffness;
			this.springParameters.damping = data.springParameters.damping;
			this.springParameters.velocity = data.springParameters.velocity;

		}

		return this;

	}
	
};
/**
 * @author nisa
 */

'use strict';

function InteractionStatesManager( interaction ) {

	this.i = interaction;

}

InteractionStatesManager.prototype = {

	updateObject() {

		if ( this.i.selectedState === undefined ) return;
		
		this.i.states[ this.i.selectedState ].updateMatrix( this.i.object );

	},

	updateCamera() {

		if ( this.i.selectedState === undefined ) return;

		this.i.states[ this.i.selectedState ].updateMatrix( this.i.object );
		this.i.states[ this.i.selectedState ].updateCamera( this.i.object );

	},

	updateGeometry() {

		if ( this.i.selectedState === undefined ) return;
		
		this.i.states[ this.i.selectedState ].updateMatrix( this.i.object );
		this.i.states[ this.i.selectedState ].updateGeometry( this.i.object );

	},

	updateSceneGraph( newParent ) {

		const _m1 = new THREE.Matrix4();
		const m = new THREE.Matrix4();

		newParent.updateWorldMatrix( true, false );

		for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

			const state = this.i.states[ i ];

			_m1.getInverse( newParent.matrixWorld );

			if ( this.i.object.parent !== null ) {

				this.i.object.parent.updateWorldMatrix( true, false );

				_m1.multiply( this.i.object.parent.matrixWorld );

			}

			if ( this.i.object.isLight === true ) {
			
				m.compose( state.position, state.quaternion, state.scale );
				m.premultiply( _m1 );
				m.decompose( state.position, state.quaternion, state.scale );
			
			} else {

				state.hiddenMatrix.premultiply( _m1 );

			}

		}

	},

	updateMaterialLayer( sourceLayer ) {

		if ( this.i.selectedState === undefined ) return;

		const selectedMaterial = this.i.object.userData.selectedMaterial;
		const material = ( selectedMaterial !== undefined ) ? this.i.states[ this.i.selectedState ].material[ selectedMaterial ] : this.i.states[ this.i.selectedState ].material;

		material.layersList.find( layer => layer.id === sourceLayer.id ).copy( sourceLayer );

	},

	pushMaterialLayer( sourceLayer ) {
		
		if ( this.i.states.length === 0 ) return;

		if ( Array.isArray( this.i.object.material ) === true ) {

			const selectedMaterial = this.i.object.userData.selectedMaterial;

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {
		
				const newLayer = sourceLayer.clone();
				if ( this.i.selectedState !== i ) newLayer.uniforms[ `f${newLayer.id}_alpha` ].value = 0;
				this.i.states[ i ].material[ selectedMaterial ].layersList.push( newLayer );
				
			}

		} else {

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {
				
				const newLayer = sourceLayer.clone();
				if ( this.i.selectedState !== i ) newLayer.uniforms[ `f${newLayer.id}_alpha` ].value = 0;
				this.i.states[ i ].material.layersList.push( newLayer );
				
			}

		}
	
	},

	popMaterialLayer() {
				
		if ( this.i.states.length === 0 ) return;

		if ( Array.isArray( this.i.object.material ) === true ) {

			const selectedMaterial = this.i.object.userData.selectedMaterial;

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

				this.i.states[ i ].material[ selectedMaterial ].layersList.pop();

			}

		} else {

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

				this.i.states[ i ].material.layersList.pop();

			}
			
		} 
	
	},

	removeMaterialLayer( pos ) {
		
		if ( this.i.states.length === 0 ) return;

		let oldStates = [];

		if ( Array.isArray( this.i.object.material ) === true ) {

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {
				
				const selectedMaterial = this.i.object.userData.selectedMaterial;
				const material = this.i.states[ i ].material[ selectedMaterial ];

				oldStates.push( { layer: material.layersList[ pos ] } );
				material.layersList.splice( pos, 1 );
				
			}

		} else {

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {
				
				const material = this.i.states[ i ].material;

				oldStates.push( { layer: material.layersList[ pos ] } );
				material.layersList.splice( pos, 1 );
				
			}

		}

		return { states: oldStates, pos: pos };

	},

	restoreMaterialLayerRemoved( oldInteraction ) {
		
		if ( this.i.states.length === 0 ) return;

		if ( Array.isArray( this.i.object.material ) === true ) {

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

				const selectedMaterial = this.i.object.userData.selectedMaterial;
				const material = this.i.states[ i ].material[ selectedMaterial ];
				material.layersList.splice( oldInteraction.pos, 0, oldInteraction.states[ i ].layer );
				
			}

		} else {

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {
				
				const material = this.i.states[ i ].material;
				material.layersList.splice( oldInteraction.pos, 0, oldInteraction.states[ i ].layer );
				
			}

		}

	},

	changeMaterialLayer( sourceLayer ) {
		
		if ( this.i.states.length === 0 ) return;

		let oldStates = [];
		let pos;

		if ( Array.isArray( this.i.object.material ) === true ) {

			const selectedMaterial = this.i.object.userData.selectedMaterial;
			const layersList = this.i.states[ this.i.selectedState ].material[ selectedMaterial ].layersList; 

			for ( let i = 0, l = layersList.length; i < l; ++i ) {

				if ( layersList[ i ].id === sourceLayer.id ) { pos = i; break; }

			}

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

				const oldLayer = this.i.states[ i ].material[ selectedMaterial ].layersList[ pos ];
				const newLayer = sourceLayer.clone();

				if ( this.i.selectedState !== i ) newLayer.uniforms[ `f${newLayer.id}_alpha` ].value = oldLayer.uniforms[ `f${oldLayer.id}_alpha` ].value;
				this.i.states[ i ].material[ selectedMaterial ].layersList[ pos ] = newLayer;

				oldStates.push( { layer: oldLayer } );

			}

		} else {

			const layersList = this.i.states[ this.i.selectedState ].material.layersList; 

			for ( let i = 0, l = layersList.length; i < l; ++i ) {

				if ( layersList[ i ].id === sourceLayer.id ) { pos = i; break; }

			}

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

				const oldLayer = this.i.states[ i ].material.layersList[ pos ];
				const newLayer = sourceLayer.clone();
				
				if ( this.i.selectedState !== i ) newLayer.uniforms[ `f${newLayer.id}_alpha` ].value = oldLayer.uniforms[ `f${oldLayer.id}_alpha` ].value;
				this.i.states[ i ].material.layersList[ pos ] = newLayer;

				oldStates.push( { layer: oldLayer } );

			}
		
		}

		return { states: oldStates, pos: pos };

	},

	restoreMaterialLayerChanged( oldInteraction ) {
		
		if ( this.i.states.length === 0 ) return;

		if ( Array.isArray( this.i.object.material ) === true ) {

			const selectedMaterial = this.i.object.userData.selectedMaterial;

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {
			
				this.i.states[ i ].material[ selectedMaterial ].layersList[ oldInteraction.pos ] = oldInteraction.states[ i ].layer;

			}

		} else {
			
			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {
			
				this.i.states[ i ].material.layersList[ oldInteraction.pos ] = oldInteraction.states[ i ].layer;

			}

		}

	},

	moveMaterialLayer( initial, final ) {
		
		if ( this.i.states.length === 0 ) return;

		if ( Array.isArray( this.i.object.material ) === true ) {

			const selectedMaterial = this.i.object.userData.selectedMaterial;

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

				const layersList = this.i.states[ i ].material[ selectedMaterial ].layersList;
				const tmp = layersList[ initial ];
				layersList[ initial ] = layersList[ final ];
				layersList[ final ] = tmp;

			}

		} else {

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {
		
				const layersList = this.i.states[ i ].material.layersList;
				const tmp = layersList[ initial ];
				layersList[ initial ] = layersList[ final ];
				layersList[ final ] = tmp;
				
			}

		}

	},

	restoreMaterialLayerMoved( initial, final ) {

		this.moveMaterialLayer( initial, final );

	},

	setMaterialLayers( layersList ) {

		const oldStates = [];

		if ( Array.isArray( this.i.object.material ) ) {

			const selectedMaterial = this.i.object.userData.selectedMaterial;
			
			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

				const material = this.i.states[ i ].material[ selectedMaterial ];

				oldStates.push( { layersList: material.layersList } );
				
				let layer = layersList.head;
				material.layersList = [];

				while ( layer !== undefined ) {

					material.layersList.push( layer.clone() );
					layer = layer.next;

				}

			}

		} else {

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

				const material = this.i.states[ i ].material;
				
				oldStates.push( { layersList: material.layersList } );

				let layer = layersList.head;
				material.layersList = [];

				while ( layer !== undefined ) {

					material.layersList.push( layer.clone() );
					layer = layer.next;

				}

			}

		}

		return { states: oldStates };

	},

	restoreMaterialLayersSet( oldInteraction ) {

		if ( Array.isArray( this.i.object.material ) ) {

			const selectedMaterial = object.userData.selectedMaterial;
			
			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

				this.i.states[ i ].material[ selectedMaterial ].layersList = oldInteraction.states[ i ].layersList;

			}

		} else {

			for ( let i = 0, l = this.i.states.length; i < l; ++i ) {

				this.i.states[ i ].material.layersList = oldInteraction.states[ i ].layersList;

			}
			
		}

	}

}
/**
 * @author nisa
 */

'use strict';


 function PlayMode( domElement, scene, camera ) {

	const raycaster = new SPE.Raycaster();
	this.isEnable;

	let map = {};
	let prevInteractionEvent; // only used in mousemove
	
	this.activate = function() {
	
		this.isEnable = true;

		for ( const key in InteractionEvent.TYPE ) {
	
			map[ InteractionEvent.TYPE[ key ] ] = [];
	
		}

		scene.traverseEntity( function( object ) {

			if ( object.interaction !== undefined ) {

				object.interaction.start();

				const interactionEvents = object.interaction.events;

				for ( let i = 0, l = interactionEvents.length; i < l; ++i ) {
				
					map[ interactionEvents[ i ].type ].push( {
						interactionEvent: interactionEvents[ i ],
						object: object
					} );

				}

			}

		} );

		if ( map[ InteractionEvent.TYPE.MOUSE_DOWN ].length > 0 )
			domElement.addEventListener( 'pointerdown', onMouseDown, false );

		if ( map[ InteractionEvent.TYPE.MOUSE_UP ].length > 0 )
			domElement.addEventListener( 'pointerup', onMouseUp, false );

		if ( map[ InteractionEvent.TYPE.MOUSE_HOVER ].length > 0 )
			domElement.addEventListener( 'pointermove', onMouseMove, false );

		if ( map[ InteractionEvent.TYPE.LOOK_AT ].length > 0 )
			domElement.addEventListener( 'mousemove', onLookAt, false );

		if ( map[ InteractionEvent.TYPE.KEY_DOWN ].length > 0 )
			document.addEventListener( 'keydown', onKeyDown, false );
		
		if ( map[ InteractionEvent.TYPE.KEY_UP ].length > 0 )
			document.addEventListener( 'keyup', onKeyUp, false );

	};

	this.deactivate = function() {

		scene.traverseEntity( function( object ) {

			if ( object.interaction !== undefined ) object.interaction.end();

		} );

		if ( map[ InteractionEvent.TYPE.MOUSE_DOWN ].length > 0 )
			domElement.removeEventListener( 'pointerdown', onMouseDown );

		if ( map[ InteractionEvent.TYPE.MOUSE_UP ].length > 0 )
			domElement.removeEventListener( 'pointerup', onMouseUp );
			
		if ( map[ InteractionEvent.TYPE.MOUSE_HOVER ].length > 0 )
			domElement.removeEventListener( 'pointermove', onMouseMove );

		if ( map[ InteractionEvent.TYPE.LOOK_AT ].length > 0 )
			domElement.removeEventListener( 'pointermove', onLookAt, false );

		if ( map[ InteractionEvent.TYPE.KEY_DOWN ].length > 0 )
			document.removeEventListener( 'keydown', onKeyDown );

		if ( map[ InteractionEvent.TYPE.KEY_UP ].length > 0 )
			document.removeEventListener( 'keyup', onKeyUp );

		map = {};

		this.isEnable = false;

	};

	this.reset = function() {

		scene.traverseEntity( function( object ) {

			object.interaction.start();

		} );

	};

	function onMouseDown( evt ) {

		raycaster.setFromCamera( getPointer( evt ), camera );

		const items = map[ InteractionEvent.TYPE.MOUSE_DOWN ];

		for ( let i = 0, l = items.length; i < l; ++i ) {

			if ( raycaster.intersectObject( items[ i ].object, false ).length > 0 ) {

				items[ i ].interactionEvent.dispatch();
				break;

			}
		
		}

	}

	function onMouseUp( evt ) {

		raycaster.setFromCamera( getPointer( evt ), camera );

		const items = map[ InteractionEvent.TYPE.MOUSE_UP ];

		for ( let i = 0, l = items.length; i < l; ++i ) {

			if ( raycaster.intersectObject( items[ i ].object, false ).length > 0 ) {

				items[ i ].interactionEvent.dispatch();
				break;

			}
		
		}

	}

	function onMouseMove( evt ) {

		raycaster.setFromCamera( getPointer( evt ), camera );

		const item = map[ InteractionEvent.TYPE.MOUSE_HOVER ].find( item => 
			raycaster.intersectObject( item.object, false ).length > 0 
		);
		const interactionEvent = item !== undefined ? item.interactionEvent : undefined;

		if ( prevInteractionEvent !== interactionEvent ) {
			
			if ( prevInteractionEvent !== undefined ) { //mouseLeave
				
				prevInteractionEvent.dispatchReverse();

			}
			
			if ( item !== undefined ) { //mouseEnter
				
				interactionEvent.dispatch();

			}

		}

		prevInteractionEvent = interactionEvent;

	}

	function onLookAt( evt ) {

		const mouseX = ( evt.pageX - window.innerWidth / 2 ) * -1;
		const mouseY = ( evt.pageY - window.innerHeight / 2 ) * 1;
		
		map[ InteractionEvent.TYPE.LOOK_AT ].forEach( item => {
							
			item.object.interaction.lookAt( mouseX, mouseY );

		} );

	}

	function onKeyDown( evt ) {

		map[ InteractionEvent.TYPE.KEY_DOWN ].forEach( item => {
			
			if ( item.interactionEvent.key === evt.key ) {
				
				item.interactionEvent.dispatch();

			}

		} );

	}

	function onKeyUp( evt ) {

		map[ InteractionEvent.TYPE.KEY_UP ].forEach( item => {
			
			if ( item.interactionEvent.key === evt.key ) {
				
				item.interactionEvent.dispatch();

			}

		} );
		
	}

	//

	function getPointer( evt ) { // TODO define once

		var rect = domElement.getBoundingClientRect(); // TODO define once

		return {
			x: ( ( evt.clientX - rect.left ) / rect.width ) * 2 - 1,
			// x: ( evt.clientX / window.innerWidth ) * 2 - 1,
			y: - ( ( evt.clientY - rect.top ) / rect.height ) * 2 + 1,
			// y: - ( evt.clientY / window.innerHeight ) * 2 + 1
		};

	}

}/**
 * @author sol
 */

'use strict';

SPE.ConeGeometry = new function() {


	this.build = function(
		{
			width = 100,
			height = width,
			depth = width,
			radialSegments = 32,
			heightSegments = 32,
			openEnded,
			thetaStart,
			thetaLength = 360,
			cornerRadiusTop = 0,
			cornerRadiusBottom = 0,
			cornerSegments = 8,
		}
	) {

		width = Math.abs( width );
		height = Math.abs( height );
		depth = Math.abs( depth );

		let geometry;
		if (cornerRadiusTop > 0 || cornerRadiusBottom > 0 || thetaLength < 360) {
			geometry = new SPE.CylinderGeometry.RoundedCylinderBufferGeometry(0, width / 2, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength * Math.PI / 180, cornerRadiusTop, cornerRadiusBottom, cornerSegments, 0, true);
		} else {
			geometry = new THREE.ConeBufferGeometry( width / 2, height, radialSegments, heightSegments, openEnded);
		}

		geometry.scale( 1, 1, depth / width );
		geometry.userData = {
			type: "ConeGeometry",
			parameters: {
				width,
				height,
				depth,
				radialSegments,
				heightSegments,
				openEnded,
				thetaStart,
				thetaLength,
				cornerRadiusTop,
				cornerRadiusBottom,
				cornerSegments,
			},
		};

		return geometry;

	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			depth = geometry.userData.parameters.depth,
			radialSegments = geometry.userData.parameters.radialSegments,
			heightSegments = geometry.userData.parameters.heightSegments,
			openEnded = geometry.userData.parameters.openEnded,
			thetaStart = geometry.userData.parameters.thetaStart,
			thetaLength = geometry.userData.parameters.thetaLength,
			cornerRadiusTop = geometry.userData.parameters.cornerRadiusTop,
			cornerRadiusBottom = geometry.userData.parameters.cornerRadiusBottom,
			cornerSegments = geometry.userData.parameters.cornerSegments
		}
	) {

		return this.build(
			{ width, height, depth, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, cornerRadiusTop, cornerRadiusBottom, cornerSegments }
		);

	}

}
/**
 * @author sol
 */

'use strict';

SPE.CubeGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			depth = width,
			widthSegments = 1,
			heightSegments = 1,
			depthSegments = 1,
			cornerRadius = 0,
			cornerSegments = 8
		}
	) {
		width = Math.abs(width);
		height = Math.abs(height);
		depth = Math.abs(depth);

		let geometry;
		if ( cornerRadius == 0 )
			geometry = new THREE.BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);
		else
			geometry = new RoundedBoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments, cornerRadius, cornerSegments);
		// Add barycentric coordinates to the buffer-geometry to handle effects that might need this attribute
		//SPE.Geometry.Utils.addBarycentricAttribute( geometry, 'barycentric' );

		geometry.userData = {
			type: "CubeGeometry",
			parameters: {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments,
				cornerRadius: cornerRadius,
				cornerSegments: cornerSegments
			}
		};

		return geometry;
	}

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			depth = geometry.userData.parameters.depth,
			widthSegments = geometry.userData.parameters.widthSegments,
			heightSegments = geometry.userData.parameters.heightSegments,
			depthSegments = geometry.userData.parameters.depthSegments,
			cornerRadius = geometry.userData.parameters.cornerRadius,
			cornerSegments = geometry.userData.parameters.cornerSegments
		}
	) {
		return this.build({width, height, depth, widthSegments, heightSegments, depthSegments, cornerRadius, cornerSegments});
	}

}

const pi2 = Math.PI / 2;

class RoundedBoxBufferGeometry extends THREE.BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1, cornerRadius = 0, cornerSegments = 4) {

		const Vector3 = THREE.Vector3;

		super();

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments,
			cornerRadius: cornerRadius,
			cornerSegments: cornerSegments,
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );
		cornerSegments = Math.floor( cornerSegments );

		cornerRadius = Math.min(cornerRadius, width / 2, height / 2, depth / 2);

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		if (cornerRadius > 0) {

			// build two edges from each side

			buildEdge( 'z', 'y', 'x', -1, -1,  1, depth, height, width, depthSegments, 0 );
			buildEdge( 'z', 'y', 'x',  1, -1, -1, depth, height, width, depthSegments, 1 );
			buildEdge( 'z', 'y', 'x', -1,  1, -1, depth, height, width, depthSegments, 1 );
			buildEdge( 'z', 'y', 'x',  1,  1,  1, depth, height, width, depthSegments, 0 );
			buildEdge( 'x', 'y', 'z', -1, -1, -1, width, height, depth, widthSegments, 0 );
			buildEdge( 'x', 'y', 'z',  1, -1,  1, width, height, depth, widthSegments, 1 );
			buildEdge( 'x', 'y', 'z', -1,  1,  1, width, height, depth, widthSegments, 0 );
			buildEdge( 'x', 'y', 'z',  1,  1, -1, width, height, depth, widthSegments, 1 );
			buildEdge( 'y', 'x', 'z', -1, -1,  1, height, width, depth, heightSegments, 0 );
			buildEdge( 'y', 'x', 'z',  1, -1, -1, height, width, depth, heightSegments, 1 );
			buildEdge( 'y', 'x', 'z',  1,  1,  1, height, width, depth, heightSegments, 1 );
			buildEdge( 'y', 'x', 'z', -1,  1, -1, height, width, depth, heightSegments, 0 );

			// build six corners

			buildCorner(  1,  1,  1 );
			buildCorner( -1,  1,  1 );
			buildCorner(  1, -1,  1 );
			buildCorner( -1, -1,  1 );
			buildCorner(  1,  1, -1 );
			buildCorner( -1,  1, -1 );
			buildCorner(  1, -1, -1 );
			buildCorner( -1, -1, -1 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = (width - 2*cornerRadius) / gridX;
			const segmentHeight = (height - 2*cornerRadius) / gridY;

			const widthHalf = width / 2 - cornerRadius;
			const heightHalf = height / 2 - cornerRadius;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = index + ix + gridX1 * iy;
					const b = index + ix + gridX1 * ( iy + 1 );
					const c = index + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = index + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			index += vertexCounter;

		}

		function buildEdge( u, v, w, udir, vdir, wdir, width, height, depth, gridX, materialIndex ) {

			const segmentWidth = (width - 2*cornerRadius) / gridX;

			const widthHalf = width / 2 - cornerRadius;
			const heightHalf = height / 2 - cornerRadius;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();
			const normal = new Vector3();

			for ( let ia = 0; ia < cornerSegments + 1; ia++ ) {

					const a = ia / cornerSegments * pi2;

					const vd = Math.sin(a) * cornerRadius;
					const wd = (1 - Math.cos(a)) * cornerRadius;

					const nv = Math.sin(a);
					const nw = Math.cos(a);

					vector[ v ] = (heightHalf + vd) * vdir;
					vector[ w ] = (depthHalf - wd) * wdir;

					normal[ u ] = 0;
					normal[ v ] = nv * Math.sign(vector[v]);
					normal[ w ] = nw * Math.sign(vector[w]);

					for ( let ix = 0; ix < gridX1; ix ++ ) {

							const x = ix * segmentWidth - widthHalf;
							vector[ u ] = x * udir;

							// now apply vector to vertex buffer

							vertices.push( vector.x, vector.y, vector.z );

							// now apply normal to normal buffer

							normals.push( normal.x, normal.y, normal.z );

							// uvs

							uvs.push( ix / gridX );
							uvs.push( 0 );

							// counters

							vertexCounter += 1;

					}

			}

			for ( let ia = 0; ia < cornerSegments; ia++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = index + ix + gridX1 * ia;
					const b = index + ix + gridX1 * ( ia + 1 );
					const c = index + ( ix + 1 ) + gridX1 * ( ia + 1 );
					const d = index + ( ix + 1 ) + gridX1 * ia;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			index += vertexCounter;

		}


		function buildCorner( udir, vdir, wdir ) {

			const delta = new Vector3();
			const center = new Vector3(width / 2, height / 2, depth / 2);
			center.subScalar(cornerRadius);

			const rows = [];

			const addface = (udir * vdir * wdir > 0)
				? (function (a,b,c) { indices.push(a,b,c); })
				: (function (a,b,c) { indices.push(a,c,b); });

			for ( let segments = 0; segments <= cornerSegments; segments ++ ) {

				const row = [];

  			const anglePitch = pi2 * (1 - segments / cornerSegments);
				const cosPitch = Math.cos(anglePitch);
				const sinPitch = Math.sin(anglePitch);

				let angleYaw = 0;

				for ( var j = 0; j <= segments; j ++ ) {

						const cosYaw = Math.cos(angleYaw);
						const sinYaw = Math.sin(angleYaw);

						// vertex

						delta.x = cosPitch * cosYaw;
						delta.y = sinPitch;
						delta.z = cosPitch * sinYaw;

						const vector = center.clone().addScaledVector(delta, cornerRadius);
						vertices.push( udir * vector.x, vdir * vector.y, wdir * vector.z );

						// normals

						normals.push( udir * delta.x, vdir * delta.y, wdir * delta.z);

						// uvs

						uvs.push( 0, 0 );

						// index

						row.push( index++ );

	  				angleYaw += pi2 / segments;

				}

				rows.push( row );

			}

			const R = rows.length - 1;

			for ( let r = 0; r < R; r ++ ) {

				// rows: cur/next
				const rC = rows[r];
				const rN = rows[r+1];

				const I = rC.length - 1;

				// first tri
				addface( rC[0], rN[1], rN[0] );

				for ( let i = 1; i <= I; i ++ ) {

					// tri to previous
					addface( rC[i-1], rC[i], rN[i] );

					// tri to next
					addface( rC[i], rN[i+1], rN[i] );

				}

			}

		}

	}

}
/**
 * @author sol
 */

'use strict';

SPE.CylinderGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			depth = width,
			radiusTop = width / 2,
			radiusBottom = width / 2,
			radialSegments = 64,
			heightSegments = 1,
			openEnded = false,
			thetaStart,
			thetaLength = 360,
			cornerRadius = 0,
			cornerSegments = 8,
			hollow = 0,
		}
	) {
		width = Math.abs(width);
		height = Math.abs(height);
		depth = Math.abs(depth);

		let radius = width / 2;

		/****/ if ( radiusTop === radiusBottom ) {
			var radiusTop = radius;
			var radiusBottom = radius;
		} else if ( radiusTop > radiusBottom ) {
			var radiusTop = radius;
			var radiusBottom = radiusBottom * radius / radiusTop;
		} else {
			var radiusTop = radiusTop * radius / radiusBottom;
			var radiusBottom = radius;
		}

		let geometry = new RoundedCylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength * Math.PI / 180, cornerRadius, cornerRadius, cornerSegments, hollow);

		geometry.scale(1, 1, depth / width);
		geometry.userData = {
			type: "CylinderGeometry",
			parameters: {
				width,
				height,
				depth,
				radiusTop,
				radiusBottom,
				radialSegments,
				heightSegments,
				openEnded,
				thetaStart,
				thetaLength,
				cornerRadius,
				cornerSegments,
				hollow,
			}
		};

		return geometry;
	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			depth = geometry.userData.parameters.depth,
			radiusTop = geometry.userData.parameters.radiusTop,
			radiusBottom = geometry.userData.parameters.radiusBottom,
			radialSegments = geometry.userData.parameters.radialSegments,
			heightSegments = geometry.userData.parameters.heightSegments,
			openEnded = geometry.userData.parameters.openEnded,
			thetaStart = geometry.userData.parameters.thetaStart,
			thetaLength = geometry.userData.parameters.thetaLength,
			cornerRadius = geometry.userData.parameters.cornerRadius,
			cornerSegments = geometry.userData.parameters.cornerSegments,
			hollow = geometry.userData.parameters.hollow,
		}
	) {
		return this.build({width, height, depth, radiusTop, radiusBottom, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, cornerRadius, cornerSegments, hollow});
	}

}

// take a 2d vector from side view and a unit vector from the top view
// and output the profile vector turned to the top vector into the 3d vector out
function two2three(profile, top, out) {
	out.x = profile.x * top.x;
	out.y = profile.y;
	out.z = profile.x * top.y;
}

// turn a 2d vector 90deg
function flip(vec) {
	return new THREE.Vector2(vec.y, -vec.x);
}

class RoundedCylinderBufferGeometry extends THREE.BufferGeometry {
	constructor( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, cornerRadiusTop, cornerRadiusBottom, cornerSegments, hollow, roundAtZero=false) {
		super();
		this.type = 'RoundedCylinderBufferGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength,
			cornerRadius: cornerRadiusTop,
			cornerRadius: cornerRadiusBottom,
			cornerSegments: cornerSegments,
			hollow: hollow,
		};

		const scope = this;

		var Vector2 = THREE.Vector2;
		var Vector3 = THREE.Vector3;
		var Float32BufferAttribute = THREE.Float32BufferAttribute;

		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height || 1;

		radialSegments = Math.floor( radialSegments ) || 8;
		heightSegments = Math.floor( heightSegments ) || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		if (openEnded) {
			cornerRadiusTop = 0;
			cornerRadiusBottom = 0;
		}

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry
		const normal = new Vector3();
		const vertex = new Vector3();

		if (roundAtZero && radiusTop == 0) {
			radiusTop = cornerRadiusTop;
		}
		if (roundAtZero && radiusBottom == 0) {
			radiusBottom = cornerRadiusBottom;
		}

		let endTop = new Vector2(radiusTop, halfHeight);
		let endBottom = new Vector2(radiusBottom, -halfHeight);
		let cornerCenterTop = null, cornerCenterBottom = null;
		let innerCornerCenterTop = null, innerCornerCenterBottom = null;
		let delta = endTop.clone().sub(endBottom);

		let wallThickness = 0, radiusInnerTop = 0, radiusInnerBottom = 0;
		if (hollow > 0) {
			wallThickness = Math.min(radiusTop, radiusBottom) * (1 - hollow);
			radiusInnerTop	= radiusTop	- wallThickness;
			radiusInnerBottom = radiusBottom - wallThickness;
		}

		const innerEndTop = endTop.clone();
		innerEndTop.x -= wallThickness;

		const cornerAngleTop	 = Math.PI - delta.angle();
		const cornerAngleBottom	= delta.angle();
		const cornerTanTop	 = Math.tan(cornerAngleBottom / 2);
		const cornerTanBottom	= Math.tan(cornerAngleTop / 2);
		const cornerTanBoth	= cornerTanTop + cornerTanBottom;
		const cornerQotTop	 = hollow ? cornerTanBoth : cornerTanBottom;
		const cornerQotBottom	= hollow ? cornerTanBoth : cornerTanTop;
		cornerRadiusTop	= Math.min(
			cornerRadiusTop,
			(radiusTop	- radiusInnerTop	 ) / cornerQotTop,
			delta.length() / cornerTanBoth
		);
		cornerRadiusBottom = Math.min(
			cornerRadiusBottom,
			(radiusBottom - radiusInnerBottom) / cornerQotBottom,
			delta.length() / cornerTanBoth
		);

		if (cornerRadiusTop > 0) {
			const theThing = cornerRadiusTop / cornerTanTop;
			cornerCenterTop = endTop.clone().sub(new Vector2(theThing, cornerRadiusTop));

			if (hollow) {
				innerCornerCenterTop = cornerCenterTop.clone();
				innerCornerCenterTop.x -= wallThickness - cornerTanBoth * cornerRadiusTop;
			}

			endTop.sub(delta.clone().setLength(theThing));
		}
		if (cornerRadiusBottom > 0) {
			const theThing = cornerRadiusBottom / cornerTanBottom;
			cornerCenterBottom = endBottom.clone().sub(new Vector2(theThing, -cornerRadiusBottom));
			endBottom.add(delta.clone().setLength(theThing));

			if (hollow) {
				innerCornerCenterBottom = cornerCenterBottom.clone();
				innerCornerCenterBottom.x -= wallThickness - cornerTanBoth * cornerRadiusBottom;
				innerEndTop.sub(delta.clone().setLength(theThing));
			}
		}
		delta = endTop.clone().sub(endBottom);
		const noTorso = delta.length() < 0.5;

		const profiles = [];

		for ( let x = 0; x <= radialSegments; x ++ ) {

			const indexProfile = [];

			const u = x / radialSegments;

			const theta = u * thetaLength + thetaStart;
			const top = new Vector2(Math.sin( theta ), Math.cos( theta ));

			if (innerCornerCenterBottom) {
				generateChamfer(indexProfile, u, top, cornerAngleTop, cornerRadiusBottom, innerCornerCenterBottom, -1, true);
				generateChamfer(indexProfile, u, top, cornerAngleBottom, cornerRadiusBottom, cornerCenterBottom, -1, false);
			} else if (cornerCenterBottom) {
				generateCap(indexProfile, top, cornerCenterBottom.x, 0, -1);
				generateChamfer(indexProfile, u, top, cornerAngleBottom, cornerRadiusBottom, cornerCenterBottom, -1, false);
			} else if (!openEnded) {
				generateCap(indexProfile, top, radiusBottom, radiusInnerBottom, -1);
			}

			const norm = flip(delta).normalize();
			two2three(norm, top, normal);

			// torso segments

			if (!noTorso) {
				for ( let y = 0; y <= heightSegments; y ++ ) {

					const v = y / heightSegments;

					// vertex

					const profile = delta.clone().multiplyScalar(v).add(endBottom);
					two2three(profile, top, vertex);
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 0.5 + vertex.y / height );

					indexProfile.push(index++);

				}
			}

			if (innerCornerCenterTop) {
				generateChamfer(indexProfile, u, top, cornerAngleTop, cornerRadiusTop, cornerCenterTop, 1, false);
				generateChamfer(indexProfile, u, top, cornerAngleBottom, cornerRadiusTop, innerCornerCenterTop, 1, true);
			} else if (cornerCenterTop) {
				generateChamfer(indexProfile, u, top, cornerAngleTop, cornerRadiusTop, cornerCenterTop, 1, false);
				generateCap(indexProfile, top, cornerCenterTop.x, 0, 1);
			} else if (!openEnded) {
				generateCap(indexProfile, top, radiusTop, radiusInnerTop, 1);
			}

			if (hollow && !noTorso) {
				// inner torso segments

				// const wallThicknessFixed = 2 * wallThickness / cornerTanBoth;
				// const innerEndTop = endTop.clone().sub(flip(delta).setLength(wallThicknessFixed));
				const norm = flip(delta).multiplyScalar(-1).normalize();
				two2three(norm, top, normal);

				for ( let y = 0; y <= heightSegments; y ++ ) {
					const v = y / heightSegments;

					// vertex

					const profile = delta.clone().multiplyScalar(-v).add(innerEndTop);
					two2three(profile, top, vertex);
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 0.5 + vertex.y / height );

					indexProfile.push(index++);

				}
			}

			if (hollow && !openEnded)
				indexProfile.push(indexProfile[0]);

			profiles.push(indexProfile);

		}

		for ( let i = 0; i < profiles.length - 1; i ++ ) {

			for ( let j = 0; j < profiles[0].length - 1; j ++ ) {

				if (openEnded && hollow && j == heightSegments) {
					continue;
				}

				// we use the index array to access the correct indices

				const a = profiles[ i ][ j ];
				const b = profiles[ i + 1 ][ j ];
				const c = profiles[ i + 1 ][ j + 1 ];
				const d = profiles[ i ][ j + 1 ];

				const cx = vertices[c*3+0];
				const cz = vertices[c*3+2];

				// faces

				indices.push( a, b, d );
				if (cx != 0 || cz != 0)
					indices.push( b, c, d );

				// update group counter

			}

		}

		if (thetaLength < Math.PI * 2) {

			// angle caps

			generateAngleCap(-1, profiles[0], thetaStart);

			generateAngleCap( 1, profiles[profiles.length - 1], thetaStart + thetaLength);

		}
		
		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateChamfer(indexProfile, u, top, startAngle, radius, center, sign, flip) {

				for ( let y = 0; y < cornerSegments + 1; y ++ ) {

					const yy = y / cornerSegments;
					let phi = sign < 0 ? yy : 1 - yy;
					if (flip)
						phi -= 1;
					phi *= startAngle;

					const norm = new Vector2(Math.sin(phi), Math.cos(phi) * sign);

					// vertex

					const profile = norm.clone().multiplyScalar(radius).add(center);

					two2three(profile, top, vertex);
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					two2three(norm, top, normal);
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push(u, 0.5 + vertex.y / height);

					// increase index

					indexProfile.push(index++);

				}

		}
		
		function generateCap( indexProfile, top, radius, innerRadius, sign ) {
			const vertex = new Vector3();
			const profile = new Vector2();
			const radii = [ radius, innerRadius ];

			if (sign < 0)
				radii.reverse();

			for (const x of radii) {

				// vertex

				profile.set(x, halfHeight * sign);
				two2three(profile, top, vertex);
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				indexProfile.push(index ++);

			}

		}

		function generateAngleCap( dir, profile, theta ) {

			const top = new Vector2(Math.sin( theta ), Math.cos( theta ));
			const normal = new Vector2(-Math.cos( theta ), Math.sin( theta ));
			const vertex = new Vector3();

			const addi = (dir < 0) ? ((a,b,c) => indices.push(a,b,c)) :  ((a,b,c) => indices.push(a,c, b));

			// vertex

			const centerProfile = new Vector2((radiusTop + radiusBottom + radiusInnerTop + radiusInnerBottom) / 4, 0);
			two2three(centerProfile, top, vertex);
			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( normal.x, 0, normal.y );

			// uv

			uvs.push( 0.5, 0.5 );

			const centerIndex = index++;

			// clone all edge points with new normals

			for (const vi of profile) {

				// vertex

				const verts = vertices.slice(vi * 3, vi * 3 + 3);
				vertices.push( ...verts );

				// normal

				normals.push( normal.x, 0, normal.y );

				// uv

				const uv = uvs.slice(vi * 2, vi * 2 + 2);
				uvs.push( ...uv );

				// increase index

				index ++;

			}

			// build faces

			for ( let i = centerIndex + 1; i < index-1; i ++ ) {

				addi( centerIndex, i, i+1 );

			}

			addi( centerIndex, index - 1, centerIndex + 1 );

		}

	}

}

SPE.CylinderGeometry.RoundedCylinderBufferGeometry = RoundedCylinderBufferGeometry;
/**
 * @author alejandro, nisa
 */

'use strict';

SPE.EllipseGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			spikes = 128,
			angle = 360,
			innerRadius = 0
		}
	) {

		let geometry;

		if( innerRadius > 0 ) {
			let outerRadius = width * 0.5;
			let innerRadiusAdjusted = (innerRadius * outerRadius) / 100;
			geometry = new THREE.RingBufferGeometry( innerRadiusAdjusted, outerRadius, spikes, 1, Math.PI / 2, angle * Math.PI / 180 );
			geometry.scale(1, Math.abs(height)/Math.abs(width), 1);
			
		} else {

			width = Math.abs(width);
			height = Math.abs(height);

			let reverse = true;
			let outerRadiusX = width * 0.5;
			let outerRadiusY = height * 0.5;
			let cx = 0, cy = 0;  // center
			let step = (angle * Math.PI / 180 * (reverse ? -1 : 1)) / spikes; // PI = 180º
			let shape = new THREE.Shape();

			for (let i = 0; i <= spikes; i++) {
				let angleCurrent = step * i;
				let x = cx + Math.sin(angleCurrent) * outerRadiusX;
				let y = cy + Math.cos(angleCurrent) * outerRadiusY;

				shape.lineTo(x, y);
			}
			// Remove first line to prevent vector duplicates that affect stroke.
			if(angle === 360) {
				shape.curves = shape.curves.slice(1);
			}

			geometry = new THREE.ShapeBufferGeometry(shape);

			// FIX UV MAPPING
			SPE.Math.fixUvs(geometry, width, height);

		}

		// Add barycentric coordinates to the buffer-geometry to handle effects that might need this attribute
		//SPE.Geometry.Utils.addBarycentricAttribute( geometry, 'barycentric' );

		geometry.userData = {
			type: "EllipseGeometry",
			parameters: {
				width: width,
				height: height,
				depth: 0,
				spikes: spikes,
				angle: angle,
				innerRadius: innerRadius
			}
		};

		

		return geometry;
	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			spikes = geometry.userData.parameters.spikes,
			angle = geometry.userData.parameters.angle,
			innerRadius = geometry.userData.parameters.innerRadius,
		}
	) {
		return this.build({width, height, spikes, angle, innerRadius});
	}

}
/**
 * @author nisa
 */

'use strict';

//@classname{SPE.IcosahedronGeometry}
SPE.IcosahedronGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			depth = width,
			detail = 0
		}
	) {
		width = Math.abs(width);
		height = Math.abs(height);
		depth = Math.abs(depth);
		
		let geometry = new THREE.IcosahedronBufferGeometry(width * 0.5, detail);
		// Add barycentric coordinates to the buffer-geometry to handle effects that might need this attribute
		//SPE.Geometry.Utils.addBarycentricAttribute( geometry, 'barycentric' );

		geometry.scale(1, height / width, depth / width);
		geometry.userData = {
			type: "IcosahedronGeometry",
			parameters: {
				width: width,
				height: height,
				depth: depth,
				detail: detail
			}
		};

		return geometry;
	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			depth = geometry.userData.parameters.depth,
			detail = geometry.userData.parameters.detail
		}
	) {
		return this.build({width, height, depth, detail});
	}

}
/**
 * @author nisa
 */

'use strict';

//@classname{SPE.PolygonGeometry}
SPE.PolygonGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			spikes = 5,
			cornerRadius = 0,
			extrudeDepth = 0,
			extrudeBevelSize = 0,
			extrudeBevelSegments = 1
		}
	) {
		width = Math.abs(width);
		height = Math.abs(height);

		let outerRadiusX = width * 0.5;
		let outerRadiusY = height * 0.5;
		let cx = 0, cy = 0;  // center
		let step = (2 * Math.PI) / spikes; // PI = 180º

		let shape = new THREE.Shape();
		for (let i = 0; i <= spikes; i++) {
			let angle = step * i;
			let x = cx + Math.sin(angle) * outerRadiusX;
			let y = cy + Math.cos(angle) * outerRadiusY;

			shape.lineTo(x, y);
		}
		//let shapePointsRaw = [...shape.getPoints()];

		if(cornerRadius !== 0) {
			SPE.Geometry.Utils.roundShapePolygon(shape, shape.getPoints(), cornerRadius);
		}

		let geometry;
		if(extrudeDepth > 0 ) {
			geometry = new THREE.ExtrudeBufferGeometry(
				shape,
				{
					curveSegments: 64,
					steps: 1,
					depth: extrudeDepth,
					bevelEnabled: true,
					bevelThickness: extrudeBevelSize,
					bevelSize: extrudeBevelSize,
					bevelOffset: 0,
					bevelSegments: extrudeBevelSegments
				}
			);

		} else {
			geometry = new THREE.ShapeBufferGeometry( shape, 32 );
		}

		geometry.userData = {
			type: "PolygonGeometry",
			parameters: {
				width: width,
				height: height,
				depth: 0,
				spikes: spikes,
				cornerRadius: cornerRadius,
				extrudeDepth: extrudeDepth,
				extrudeBevelSize: extrudeBevelSize,
				extrudeBevelSegments: extrudeBevelSegments
			}
		};

		// FIX UV MAPPING
		SPE.Math.fixUvs(geometry, width, height);

		return geometry;
	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			spikes = geometry.userData.parameters.spikes,
			cornerRadius = geometry.userData.parameters.cornerRadius,
			extrudeDepth = geometry.userData.parameters.extrudeDepth,
			extrudeBevelSize = geometry.userData.parameters.extrudeBevelSize,
			extrudeBevelSegments = geometry.userData.parameters.extrudeBevelSegments,
		}
	) {
		return this.build({width, height, spikes, cornerRadius, extrudeDepth, extrudeBevelSize, extrudeBevelSegments});
	}

}
/**
 * @author nisa
 */

'use strict';

//@classname{SPE.SphereGeometry}
SPE.SphereGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			depth = width,
			widthSegments = 64,
			heightSegments = 64,
			phiStart,
			phiLength,
			thetaStart,
			thetaLength
		}
	) {

		width = Math.abs( width );
		height = Math.abs( height );
		depth = Math.abs( depth );

		let geometry = new THREE.SphereBufferGeometry( 0.5 * width, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength );
		// @Fix: makes geometry not-indexed, such that barycentric-coordinates work correctly
		//geometry = geometry.toNonIndexed();

		// Add barycentric coordinates to the buffer-geometry to handle effects that might need this attribute
		//SPE.Geometry.Utils.addBarycentricAttribute( geometry, 'barycentric' );

		geometry.scale( 1, height / width, depth / width );
		geometry.userData = {
			type: "SphereGeometry",
			parameters: {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			}
		};

		return geometry;

	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			depth = geometry.userData.parameters.depth,
			widthSegments = geometry.userData.parameters.widthSegments,
			heightSegments = geometry.userData.parameters.heightSegments,
			phiStart = geometry.userData.parameters.phiStart,
			phiLength = geometry.userData.parameters.phiLength,
			thetaStart = geometry.userData.parameters.thetaStart,
			thetaLength = geometry.userData.parameters.thetaLength
		}
	) {

		return this.build( { width, height, depth, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength } );

	}

}
/**
 * @author nisa
 */

'use strict';

//@classname{SPE.StarGeometry}
SPE.StarGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			innerRadiusPercent = 38.19,
			spikes = 5,
			cornerRadius = 0,
			angle = 360,
			extrudeDepth = 0,
			extrudeBevelSize = 0,
			extrudeBevelSegments = 1
		}
	) {

		width = Math.abs( width );
		height = Math.abs( height );

		let outerRadiusX = width * 0.5;
		let outerRadiusY = height * 0.5;
		let cx = 0, cy = 0; // center
		let step = (angle * Math.PI / 360 ) / spikes;
		let rot = Math.PI / 2 * 3 * -1; // -1 for the fisrt spike look at up
		let innerRadiusX = ( outerRadiusX * innerRadiusPercent ) / 100;
		let innerRadiusY = ( outerRadiusY * innerRadiusPercent ) / 100;

		let shape = new THREE.Shape();

		if ( spikes == 3 && innerRadiusPercent == 50 ) { // Alejandro: This is to fix the issue went using 3 spikes ant 50% inner
			step = ( 2 * Math.PI ) / spikes; // PI = 180º
			for ( let i = 0; i <= spikes; i++ ) {
				let angle = step * i;
				let x = cx + Math.sin( angle ) * outerRadiusX;
				let y = cy + Math.cos( angle ) * outerRadiusY;

				shape.lineTo( x, y );
			}

		} else {

			shape.moveTo( cx, cy + angle == 360 ? outerRadiusY : 0);
			for (let i = 0; i < spikes; i++) {
				let x = cx + Math.cos(rot) * outerRadiusX;
				let y = cy + Math.sin(rot) * outerRadiusY;
				shape.lineTo(x, y);
				rot += step;

				x = cx + Math.cos(rot) * innerRadiusX;
				y = cy + Math.sin(rot) * innerRadiusY;
				if(i <= spikes) {
					
				}
				shape.lineTo(x, y);
				rot += step;
			}
			shape.lineTo(cx, cy + angle == 360 ? outerRadiusY : 0);
			// shape.closePath();
		}


		if ( cornerRadius !== 0 )
			SPE.Geometry.Utils.roundShapePolygon( shape, shape.getPoints(), cornerRadius );

		let geometry;
		if(extrudeDepth > 0 ) {
			geometry = new THREE.ExtrudeBufferGeometry(
				shape,
				{
					steps: 1,
					depth: extrudeDepth,
					bevelEnabled: true,
					bevelThickness: extrudeBevelSize,
					bevelSize: extrudeBevelSize,
					bevelOffset: 0,
					bevelSegments: extrudeBevelSegments
				}
			);

		} else {
			geometry = new THREE.ShapeBufferGeometry( shape );
		}

		// Add barycentric coordinates to the buffer-geometry to handle effects that might need this attribute
		//SPE.Geometry.Utils.addBarycentricAttribute( geometry, 'barycentric' );

		geometry.userData = {
			type: "StarGeometry",
			parameters: {
				width: width,
				height: height,
				depth: 0,
				innerRadiusPercent: innerRadiusPercent,
				spikes: spikes,
				cornerRadius: cornerRadius,
				angle: angle,
				extrudeDepth: extrudeDepth,
				extrudeBevelSize: extrudeBevelSize,
				extrudeBevelSegments: extrudeBevelSegments
			}
		};

		// FIX UV MAPPING
		SPE.Math.fixUvs( geometry, width, height );

		return geometry;

	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			innerRadiusPercent = geometry.userData.parameters.innerRadiusPercent,
			spikes = geometry.userData.parameters.spikes,
			cornerRadius = geometry.userData.parameters.cornerRadius,
			angle = geometry.userData.parameters.angle,
			extrudeDepth = geometry.userData.parameters.extrudeDepth,
			extrudeBevelSize = geometry.userData.parameters.extrudeBevelSize,
			extrudeBevelSegments = geometry.userData.parameters.extrudeBevelSegments
		}
	) {

		return this.build( {
			width,
			height,
			innerRadiusPercent,
			spikes,
			cornerRadius,
			angle,
			extrudeDepth,
			extrudeBevelSize,
			extrudeBevelSegments
		
		} );

	}

}
/**
 * @author nisa
 */

'use strict';

//@classname{SPE.TorusGeometry}
SPE.TorusGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			depth,
			tubePercent = 50,
			radialSegments = 128,
			tubularSegments = 64,
			arc = Math.PI * 2,
			cornerRadius =  30,
			cornerSegments = 8
		}
	) {

		let tube = (width * 0.25) * tubePercent * 0.01; // tubePercent = Inside
		let radius = (width * 0.5) - (tube);
		depth = depth ? depth : tube * 2;
		
		let geometry = genTorus( width, height, depth, /*gui_radius*/ 0, arc, radialSegments, /*gui_pathRadius*/ 0, 
								 /*gui_pathType*/ 0, tubularSegments, cornerRadius, cornerSegments );
		

		//let geometry = new THREE.TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc);
		// @Fix: makes geometry not-indexed, such that barycentric-coordinates work correctly
		//geometry = geometry.toNonIndexed();

		// Add barycentric coordinates to the buffer-geometry to handle effects that might need this attribute
		//SPE.Geometry.Utils.addBarycentricAttribute( geometry, 'barycentric' );

//-----------
		//geometry.scale(1, height / width, depth / (tube * 2)); // force dimensions // TODO scale depth
		
		geometry.scale(1, height / width, 1); // force dimensions // TODO scale depth
		
//-----------
		
		geometry.userData = {
			type: "TorusGeometry",
			parameters: {
				width: width,
				height: height,
				depth: depth,
				tubePercent: tubePercent,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc,
				cornerRadius: cornerRadius,
				cornerSegments: cornerSegments
			}
		};

		return geometry;


		function genTorus( width, height, depth, radius, revolutions, segments, pathRadius, pathType, pathSegments, cornerRadius, cornerSegments )
		{
			[ height, depth ] = [ depth, height ]; // this line is just to facilitate reading, instead of exchanging the parameters directly in genHelix() below.
			pathRadius = height / 2;               // same with this line.
			revolutions /= 2 * Math.PI;
			
			if( revolutions == 1 )
				cornerRadius = 0;
			
			return genHelix( true, width, height, depth, radius, revolutions, segments, pathRadius, pathType, pathSegments, cornerRadius, cornerSegments );
		}

	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			depth = geometry.userData.parameters.depth,
			tubePercent = geometry.userData.parameters.tubePercent,
			radialSegments = geometry.userData.parameters.radialSegments,
			tubularSegments = geometry.userData.parameters.tubularSegments,
			arc = geometry.userData.parameters.arc,
			cornerRadius =   geometry.userData.parameters.cornerRadius,
			cornerSegments = geometry.userData.parameters.cornerSegments
		}
	) {

		return this.build({width, height, depth, tubePercent, radialSegments, tubularSegments, arc, cornerRadius, cornerSegments});

	}

}/**
 * @author lawrence
 */

'use strict';

//@classname{SPE.HelixGeometry}
SPE.HelixGeometry = new function() {
	
	
	this.build = function(
		{
			width =           100,
			height =          width,
			depth =           width,
			radius =          20,
			revolutions =      2,
			segments =        40,
			pathRadius =      10,
			pathType =         0,
			pathSegments =    30,
			cornerRadius =    30, 
			cornerSegments =   8
		}
	) {

		let geometry = genHelix(
			false,  // not a torus
			Math.abs( width ),
			Math.abs( height ),
			Math.abs( depth ),
			Math.abs( radius ),
			Math.abs( revolutions ),
			Math.abs( segments ),
			Math.abs( pathRadius ),
			Math.abs( pathType ),
			Math.abs( pathSegments ),
			Math.abs( cornerRadius ),
			Math.abs( cornerSegments )
		);

		geometry.userData = {
			type: "HelixGeometry",
			parameters: {
				height,
				width,
				depth,
				radius,
				revolutions,
				segments,
				pathRadius,
				pathType,
				pathSegments,
				cornerRadius,
				cornerSegments
			},
		};
		
		return geometry;

	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width =          geometry.userData.parameters.width,
			height =         geometry.userData.parameters.height, 
			depth =          geometry.userData.parameters.depth,
			radius =         geometry.userData.parameters.radius,
			revolutions =    geometry.userData.parameters.revolutions,
			segments =       geometry.userData.parameters.segments,
			pathRadius =     geometry.userData.parameters.pathRadius,
			pathType =       geometry.userData.parameters.pathType,
			pathSegments =   geometry.userData.parameters.pathSegments,
			cornerRadius =   geometry.userData.parameters.cornerRadius,
			cornerSegments = geometry.userData.parameters.cornerSegments
		}
	) {

		return this.build(
			{ width, height, depth, radius, revolutions, segments, pathRadius, pathType, pathSegments, cornerRadius, cornerSegments }
		);

	}
}


//=======================================================================
// public function (also used by TorusGeometry.js)
//=======================================================================
function genHelix( 
	isTorus, 
	gui_width, 
	gui_height, 
	gui_depth, 
	gui_radius, 
	gui_revolutions, 
	gui_segments, 
	gui_pathRadius, 
	gui_pathType, 
	gui_pathSegments, 
	gui_cornerRadius, 
	gui_cornerSegments )
{
	//-----------------	
	gui_segments = Math.round( gui_segments ); 
	gui_pathSegments = Math.round( gui_pathSegments );
	gui_cornerSegments = Math.round( gui_cornerSegments );
	//-----------------	

	const indices = [], vertices = [], normals = [], uvs = [], verticesCaps = [], normalsCaps = [], uvsCaps = [];
	let pathCenter = new THREE.Vector3(), cornerCenter = new THREE.Vector3();
	let v0 = new THREE.Vector3(), v1 = new THREE.Vector3(), v2 = new THREE.Vector3(); // auxiliary vectors
	let a, b, c, d, x, y, z, ang, lastCoord = new THREE.Vector3();
	let pathRadiusLine = new THREE.Vector3(), cornerRadiusLine = new THREE.Vector3(), pathRadiusNormal = new THREE.Vector3();
	let abscissa = new THREE.Vector3(), ordinate = new THREE.Vector3(), pathAxis = new THREE.Vector3(); 

	const lockRadius = true; // the same radius for width and depth ?
	const minimumRadius = Math.min( gui_width, gui_depth ) / 2; // gui_radius isn't used for now.
	const radiusWidth = (lockRadius ? minimumRadius : gui_width / 2) - gui_pathRadius;
	const radiusDepth = (lockRadius ? minimumRadius : gui_depth / 2) - gui_pathRadius;

	const heightTotal = gui_height - 2 * gui_pathRadius + .001; // small value added to prevent heightTotal 0 (0 means won't be drawn)
	const revolutionHeight = heightTotal / gui_revolutions;
	const tubeSegments = Math.ceil( gui_segments * gui_revolutions );
	const heightSegment = heightTotal / tubeSegments;
	const baseHeight = -heightTotal / 2;

	const pathSegmentArc = 2 * Math.PI / gui_pathSegments;
	const cornerSegmentArc = Math.PI / 2 / gui_cornerSegments;
	const cornerRadiusPercent = Math.min( (1 - gui_cornerRadius / 100) * gui_pathRadius, gui_pathRadius - .1 ); // sub .1 from pathRadius, otherwise cap's hidden.
	const arcRadius = gui_pathRadius - cornerRadiusPercent; // to use absolute cornerRadius, just replace 'cornerRadiusPercent' with 'gui_cornerRadius'

	function setPathCenter( vec, numSeg )
	{
		const startBottomAngle = Math.PI / 2;
		
		y = numSeg * heightSegment; //  include "+ baseHeight" if want both sides to change simultaneously (and delete the line below, adding baseHeight)
		ang = 2 * Math.PI * (y % revolutionHeight) / revolutionHeight + startBottomAngle;
		y += baseHeight;
		z = Math.sin( ang ) * radiusDepth;
		x = Math.cos( ang ) * radiusWidth; 
		
		if( isTorus )
			vec.set( x, z, y );
		else
			vec.set( x, y, z );
	}

	setPathCenter( v0, -1 ); 
	setPathCenter( v1,  0 );

	lastCoord.copy( v0 );


	// UVs
	const segmentLength = v0.distanceTo( v1 );
	const helixLength = segmentLength * tubeSegments + 2 * arcRadius;
	const startBottomCaps = 0;
	const startTopCaps = helixLength - arcRadius;


	// solucao para distorcao quando width != depth
	// os circulos dos segmentos apontam para o meio da helice, por isso o tubo da helice fica distorcido em qualguer angulo diferente das 4 posicoes onde forma angulo de 90 graus.
	// solucao eh pegar o vetor de 2 eixos consecutivos do tubo ( (pathCenter-lastCoord) - (proximo_pathCenter-proximo_lastCoord)) chamar de "eixoTubo"
	// depois fazer o cross desse eixoTubo com o UpVector, chamar de "vectorToHelixCenter" (atencao, nao eh o exato centro da helix, )


	// tube geometry with caps----------------------------------------------
	for( let numSeg = 0; numSeg <= tubeSegments; numSeg++ ) 
	{
		setPathCenter( pathCenter, numSeg );

		pathAxis.subVectors( pathCenter, lastCoord ).normalize();
		lastCoord.copy( pathCenter );

		abscissa.copy( pathCenter ).setComponent( isTorus + 1, 0 ).normalize();
		ordinate.crossVectors( pathAxis, abscissa ).normalize();

		const startAngle = numSeg == 0 ? 3 * Math.PI / 2 : cornerSegmentArc;
		const offsetUV = numSeg == 0 ? startBottomCaps : startTopCaps;

		for( let i = 0, angPath = 0; i <= gui_pathSegments; i++, angPath = i * pathSegmentArc )
		{
			pathRadiusLine.addVectors( v0.copy( abscissa ).multiplyScalar( gui_pathRadius * Math.cos( angPath )), 
									   v1.copy( ordinate ).multiplyScalar( gui_pathRadius * Math.sin( angPath )));
			pathRadiusNormal.copy( pathRadiusLine ).normalize();

			// top and bottom caps
			if( numSeg == 0 || numSeg == tubeSegments )
			{
				v1.copy( pathRadiusNormal ).multiplyScalar( cornerRadiusPercent );
				cornerCenter.addVectors( pathCenter, v1 );

				for( let j = 0, angCorner = startAngle; j < gui_cornerSegments; j++, angCorner = j * cornerSegmentArc + startAngle )
				{
					cornerRadiusLine.addVectors( v0.copy( pathAxis         ).multiplyScalar( arcRadius * Math.sin( angCorner )), 
												 v1.copy( pathRadiusNormal ).multiplyScalar( arcRadius * Math.cos( angCorner )));

					v1.addVectors( cornerCenter, cornerRadiusLine );

					cornerRadiusLine.normalize();

					verticesCaps.push( v1.x, v1.y, v1.z );
					normalsCaps.push( cornerRadiusLine.x, cornerRadiusLine.y, cornerRadiusLine.z );
					const sinUV = (numSeg == 0) + Math.sin( angCorner );
					uvsCaps.push( ( offsetUV + arcRadius * sinUV ) / helixLength, i / gui_pathSegments, 0 ); // 3 coordinates instead of 2, for merging below
				}				
			}

			v1.addVectors( pathCenter, pathRadiusLine );

			vertices.push( v1.x, v1.y, v1.z );
			normals.push( pathRadiusNormal.x, pathRadiusNormal.y, pathRadiusNormal.z );
			uvs.push( ( arcRadius + numSeg * segmentLength ) / helixLength, i / gui_pathSegments ); 
		}
	}

	// sort/merge caps vertices---------------------------------
	const topCapsInd = verticesCaps.length / 2;

	for( let i = 0; i < gui_cornerSegments; i++ )
	{
		for( let j = 0; j <= gui_pathSegments; j++ )
		{
			// To Do: instead of dynamic allocating these vertices, just allocate all memory once then just assign values using the right array's indices.
			let top = topCapsInd + (j * gui_cornerSegments + i) * 3;
			let bottom = ((gui_pathSegments - j) * gui_cornerSegments + gui_cornerSegments - i - 1 ) * 3;
			vertices.push( ...verticesCaps.slice( top, top + 3 ) );  vertices.unshift( ...verticesCaps.slice( bottom, bottom + 3 ) );
			normals.push( ...normalsCaps.slice( top, top + 3 ) );    normals.unshift( ...normalsCaps.slice( bottom, bottom + 3 ) );
			uvs.push( ...uvsCaps.slice( top, top + 2 ) );            uvs.unshift( ...uvsCaps.slice( bottom, bottom + 2 ) );
		}
	}
	

	// indices for the tube and corners ----------------------------------------
	const ps1 = gui_pathSegments + 1;

	for( let i = 0; i < tubeSegments + 2 * gui_cornerSegments; i++ ) 
	{
		for( let j = 0; j < ps1 - 1; j++ )
		{
			a = i * ps1 + j; b = a + 1;          // a---b is each side of the circle from the current segment
			c = a + ps1    ; d = b + ps1;        // c---d is each corresponding side from the next segment
			indices.push( a, b, c, b, d, c );    // two tris, CW winding.
		}
	}

	// indices for the two cap tops ---------------------------------------------
	a = vertices.length / 3 - gui_pathSegments - 1;

	for( let i = 0; i < gui_pathSegments - 2; i++ ) 
	{
		// fan triangulation
		indices.push( a, a + i + 1, a + i + 2 ); // top cap
		indices.push( 0, i + 2, i + 1 );         // bottom cap
	}

	// --------------------------------------------------------------
	let geometry = new THREE.BufferGeometry();
	geometry.setIndex( indices );
	geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'normal',   new THREE.Float32BufferAttribute( normals, 3 ) );
	geometry.setAttribute( 'uv',       new THREE.Float32BufferAttribute( uvs, 2 ) );
	
	return geometry;
}
		/**
 * @author nisa
 */

'use strict';

//@classname{SPE.TriangleGeometry}
SPE.TriangleGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height,
			cornerRadius = 0,
			extrudeDepth = 0,
			extrudeBevelSize = 0,
			extrudeBevelSegments = 1,
			isRect = false
		}
	) {

		width = Math.abs( width );

		let shape = new THREE.Shape();

		if( isRect ) {

			height = height ? Math.abs(height) : width;

			shape.moveTo( -width * 0.5, height * 0.5 );
			shape.lineTo( width * 0.5, -height * 0.5 );
			shape.lineTo( -width * 0.5, -height * 0.5 );
			shape.lineTo( -width * 0.5, height * 0.5 );

		} else {

			height = Math.abs(height);
			height = height || width * ( Math.sqrt( 3 ) / 2 ); // equilateral triangle
			let r = {x: width * 0.5, y: height * 0.5};
			
			shape.moveTo(0, r.y);
			shape.lineTo(r.x, -r.y);
			shape.lineTo(-r.x, -r.y);
			shape.lineTo(0, r.y);

		}


		if ( cornerRadius !== 0 )
			roundShapePolygonTriangle( shape, shape.getPoints(), cornerRadius );

		let geometry;
		if(extrudeDepth > 0 ) {
			geometry = new THREE.ExtrudeBufferGeometry(
				shape,
				{
					curveSegments: 64,
					steps: 1,
					depth: extrudeDepth,
					bevelEnabled: true,
					bevelThickness: extrudeBevelSize,
					bevelSize: extrudeBevelSize,
					bevelOffset: 0,
					bevelSegments: extrudeBevelSegments
				}
			);

		} else {
			geometry = new THREE.ShapeBufferGeometry( shape, 32 );
		}

		geometry.userData = {
			type: "TriangleGeometry",
			parameters: {
				width: width,
				height: height,
				depth: 0,
				cornerRadius: cornerRadius,
				extrudeDepth: extrudeDepth,
				extrudeBevelSize: extrudeBevelSize,
				extrudeBevelSegments: extrudeBevelSegments,
				isRect: isRect
			}
		};

		// FIX UV MAPPING
		SPE.Math.fixUvs( geometry, width, height );

		return geometry;

	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			cornerRadius = geometry.userData.parameters.cornerRadius,
			extrudeDepth = geometry.userData.parameters.extrudeDepth,
			extrudeBevelSize = geometry.userData.parameters.extrudeBevelSize,
			extrudeBevelSegments = geometry.userData.parameters.extrudeBevelSegments,
			isRect = geometry.userData.parameters.isRect,
		}
	) {

		return this.build( { width, height, cornerRadius, extrudeDepth, extrudeBevelSize, extrudeBevelSegments, isRect } );

	}

	function roundShapePolygonTriangle (shape, points, radius) {

		var i, x, y, len, p1, p2, p3, v1, v2, sinA, sinA90, radDirection, drawDirection, angle, halfAngle, cRadius, lenOut;
		var asVec = function (p, pp, v) {
			v.x = pp.x - p.x;
			v.y = pp.y - p.y;
			v.len = Math.sqrt(v.x * v.x + v.y * v.y);
			v.nx = v.x / v.len;
			v.ny = v.y / v.len;
			v.ang = Math.atan2(v.ny, v.nx);
		}
		v1 = {};
		v2 = {};
		len = points.length - 1;
		p1 = points[len - 1];
		shape.curves = [];

		for (i = 0; i < len; i++) {
			p2 = points[(i) % len];
			p3 = points[(i + 1) % len];
			asVec(p2, p1, v1);
			asVec(p2, p3, v2);
			sinA = v1.nx * v2.ny - v1.ny * v2.nx;
			sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
			angle = Math.asin(sinA);
			radDirection = 1;
			drawDirection = false;
			//   console.log(sinA90, sinA);
			if (sinA90 < 0) {
				if (angle < 0) {
					angle = Math.PI + angle;
				} else {
					angle = Math.PI - angle;
					radDirection = -1;
					drawDirection = true;
				}
			} else {
				if (angle > 0) {
					radDirection = -1;
					drawDirection = true;
				}
			}
			halfAngle = angle * 0.5;
			lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
			if (lenOut > Math.min(v1.len * 0.5, v2.len * 0.5)) {
				lenOut = Math.min(v1.len * 0.5, v2.len * 0.5);
				cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
			} else {
				cRadius = radius;
			}
			x = p2.x + v2.nx * lenOut;
			y = p2.y + v2.ny * lenOut;
			x += -v2.ny * cRadius * radDirection;
			y += v2.nx * cRadius * radDirection;

			shape.absarc(x, y, cRadius, v1.ang + Math.PI / 2 * radDirection, v2.ang - Math.PI / 2 * radDirection, drawDirection);
			//console.log(shape);

			p1 = p2;
			p2 = p3;

		}
		shape.closePath();

	}

}
/**
 * @author nisa
 */

'use strict';

//@classname{SPE.NonParametricGeometry}
SPE.NonParametricGeometry = new function() {

	
	this.build = function(
		geometry = new THREE.BoxBufferGeometry( 100, 100, 100 ), 
		parameters
		/*{ 
			width,
			height,
			depth
		},*/
	) {

		let newGeometry = new THREE.BufferGeometry();
		// let newGeometry = new THREE[ geometry.type ]();
		// Float32BufferAttribute
		// InterleavedBufferAttribute
		newGeometry.copy( geometry );

		// const box3 = new THREE.Box3();
		const size = new THREE.Vector3();

		// box3.setFromArray( geometry.getAttribute( 'position' ).array );
		// box3.getSize( size );

		newGeometry.computeBoundingBox();
		newGeometry.boundingBox.getSize( size );

		if ( parameters ) {
			var width = parameters.width ? parameters.width : size.x;
			var height = parameters.height ? parameters.height: size.y;
			var depth = parameters.depth ? parameters.depth : size.z;

			newGeometry.scale( 
				size.x === 0 ? 1 : width / size.x,
				size.y === 0 ? 1 : height / size.y, 
				size.z === 0 ? 1 : depth / size.z
			);
		
		} else {
			var width = size.x;
			var height = size.y;
			var depth = size.z;

		}

		// Add barycentric coordinates to the buffer-geometry to handle effects that might need this attribute
		//SPE.Geometry.Utils.addBarycentricAttribute( newGeometry, 'barycentric' );

		newGeometry.userData = {
			type: "NonParametricGeometry",
			parameters: { width: width, height: height, depth: depth }
		};

		return newGeometry;

	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			depth = geometry.userData.parameters.depth
		}
	) {

		return this.build( geometry, { width, height, depth } );

	}
	
}
/**
 * @author nisa
 */

'use strict';

SPE.StrokeGeometry = new function() {

	this.build = function(
		meshGeometry, 
		parameters = {}
	) {

		const strokeAlignment = parameters.strokeAlignment || 1;
		const strokeGrowth = parameters.strokeGrowth || 1;
		const arrayOfVector2 = [];
		
		switch ( meshGeometry.userData.type ) {

			case "PolygonGeometry":
				var start = 3;
				var end = meshGeometry.getAttribute( 'position' ).array.length - 3;
				break;
			case "StarGeometry":
				var start = 0;
				var end = meshGeometry.getAttribute( 'position' ).array.length - 3;
				break;
			default:
				var start = 0;
				var end = meshGeometry.getAttribute( 'position' ).array.length;

		}

		for ( let i = start; i < end; i += 3 ) {

			arrayOfVector2.push(
				[
					meshGeometry.getAttribute( 'position' ).array[ i ],
					meshGeometry.getAttribute( 'position' ).array[ i + 1 ]
				]
			);

		}

		const strokeGeometry = createLineGeo(  arrayOfVector2, strokeAlignment, strokeGrowth )( THREE ); // TODO fix global access

		strokeGeometry.userData = {
			type: 'StrokeGeometry',
			parameters: {
				strokeAlignment: strokeAlignment
			}
		};

		strokeGeometry.toJSON = function() { // patch, this is a hack, we need extend of BufferGeometry o use a fork 

			const data = {};

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			data.userData = this.userData;
			data.userData.meshGeometry = meshGeometry.uuid;

			return data;

		}

		return strokeGeometry;

	}

	this.buildFromGeometry = function(
		meshGeometry, 
		strokeGeometry,
		{
			strokeAlignment = strokeGeometry.userData.parameters.strokeAlignment,
			strokeGrowth = strokeGeometry.userData.parameters.strokeGrowth
		}
	) {

		return SPE.StrokeGeometry.build( meshGeometry, { strokeAlignment, strokeGrowth } );

	}

}
/**
 * @author nisa
 */

'use strict';

SPE.TextFrameGeometry = new function() {

	this.build = function(
		{
			width = 100,
			height = width
		}
	) {

		let geometry = new THREE.PlaneBufferGeometry(width, height);

		geometry.userData = {
			type: "TextFrameGeometry",
			parameters: {width: width, height: height, depth: 0}
		};

		return geometry;

	}

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height
		}
	) {

		return this.build({width, height});

	}
	
}/**
 * @author
 */

'use strict';

SPE.Geometry = {};

//@classname{SPE.Geometry.Utils}
SPE.Geometry.Utils = new function() {

	this.roundShapePolygon = function( shape, points, radius ) {

		var i, x, y, len, p1, p2, p3, v1, v2, sinA, sinA90, radDirection, drawDirection, angle, halfAngle, cRadius, lenOut;
		var asVec = function (p, pp, v) {
			v.x = pp.x - p.x;
			v.y = pp.y - p.y;
			v.len = Math.sqrt(v.x * v.x + v.y * v.y);
			v.nx = v.x / v.len;
			v.ny = v.y / v.len;
			v.ang = Math.atan2(v.ny, v.nx);
		}
		v1 = {};
		v2 = {};
		len = points.length;
		p1 = points[len - 2];
		shape.curves = [];

		for (i = 1; i < len - 1; i++) {
			p2 = points[(i) % len];
			p3 = points[(i + 1) % len];
			asVec(p2, p1, v1);
			asVec(p2, p3, v2);
			sinA = v1.nx * v2.ny - v1.ny * v2.nx;
			sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
			angle = Math.asin(sinA);
			radDirection = 1;
			drawDirection = false;
			//   console.log(sinA90, sinA);
			if (sinA90 < 0) {
				if (angle < 0) {
					angle = Math.PI + angle;
				} else {
					angle = Math.PI - angle;
					radDirection = -1;
					drawDirection = true;
				}
			} else {
				if (angle > 0) {
					radDirection = -1;
					drawDirection = true;
				}
			}
			halfAngle = angle / 2;
			lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
			if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
				lenOut = Math.min(v1.len / 2, v2.len / 2);
				cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
			} else {
				cRadius = radius;
			}
			x = p2.x + v2.nx * lenOut;
			y = p2.y + v2.ny * lenOut;
			x += -v2.ny * cRadius * radDirection;
			y += v2.nx * cRadius * radDirection;

			shape.absarc(x, y, cRadius, v1.ang + Math.PI / 2 * radDirection, v2.ang - Math.PI / 2 * radDirection, drawDirection);
			//console.log(shape);

			p1 = p2;
			p2 = p3;

		}
		shape.closePath();
	};
	

	this.resizeGeometry = function( geometry, { width, height, depth } ) {

		width = Math.abs( width );
		height = Math.abs( height );
		depth = Math.abs( depth );

		const parameters = geometry.userData.parameters;
		let scaleX, scaleY, scaleZ;

		if ( width === 0 ) {
			
			width = parameters.width;
			scaleX = 1;

		} else {

			scaleX = width / parameters.width;

		}

		if ( height === 0 ) {
			
			height = parameters.height;
			scaleY = 1;

		} else {

			scaleY = height / parameters.height;

		}
		
		if ( depth === 0 ) {
			
			depth = parameters.depth;
			scaleZ = 1;

		} else {

			scaleZ = depth / parameters.depth;

		}

		geometry.scale( scaleX, scaleY, scaleZ );

		parameters.width = width;
		parameters.height = height;
		parameters.depth = depth;

	};

	this.addBarycentricAttribute = function( geometry, attribName ) {
		const vectors = [ new THREE.Vector3( 1, 0, 0 ),
						  new THREE.Vector3( 0, 1, 0 ),
						  new THREE.Vector3( 0, 0, 1 ) ];

		const position = geometry.attributes.position;
		const barycentric = new Float32Array( position.count * 3 );

		for ( let i = 0, l = position.count; i < l; i++ )
			vectors[i % 3].toArray( barycentric, i * 3 );

		geometry.setAttribute( attribName, new THREE.Float32BufferAttribute( barycentric, 3 ) );
	}

	this.removeBarycentricAttribute = function( geometry, attribName ) {
		geometry.deleteAttribute( attribName );
	};

	this.loadFromUrl = function( url ) {

		return new Promise(

			function ( resolve, reject ) {

				let loader = new THREE.BufferGeometryLoader();

				loader.load(
					url,
					function ( geometry ) { resolve( geometry ); },
					// function ( xhr ) {
					// 	console.log( ( xhr.loaded / xhr.total * 100) + '% loaded' );
					// },
					// function ( err ) {
					// 	console.log( 'An error happened' );
					// }
				);

			}

		);

	};

}
/**
 * @author nisa
 *
 * reference:
 * https://github.com/mrdoob/three.js/blob/7f43f4e6ef087cec168fea25bb53591052d5ff12/examples/js/cameras/CombinedCamera.js
 * https://observablehq.com/@grantcuster/understanding-scale-and-the-three-js-perspective-camera
 * https://stackoverflow.com/questions/48758959/what-is-required-to-convert-threejs-perspective-camera-to-orthographic
 * https://discourse.threejs.org/t/how-to-switch-camera-between-perspective-and-orthographic-with-similar-zoom/10444
 * https://discourse.threejs.org/t/camera-zoom-to-fit-object/936/8
 */

'use strict';

SPE.CombinedCamera = class CombinedCamera extends THREE.Camera {

	constructor( width = 100, height = 100, fov = 45, near = 0.1, far = 50000 ) {

		super();
		width = window.innerWidth;
		height = window.innerHeight;

		this.orthoCamera = new THREE.OrthographicCamera( width * - 0.5, width * 0.5, height * 0.5, height * -0.5, near, far );
		this.perspCamera = new THREE.PerspectiveCamera( fov, width / height, near, far );

		// orthographic parameters
		this.left = this.orthoCamera.left;
		this.right = this.orthoCamera.right;
		this.top = this.orthoCamera.top;
		this.bottom = this.orthoCamera.bottom;
		this.view = this.orthoCamera.view;
		// this._zoom = this.orthoCamera.zoom;
		// this._near = this.orthoCamera.near;
		this.far = this.orthoCamera.far;
		this.isOrthographicCamera = true;
		this._type = 'OrthographicCamera';

		// perspective parameters
		this.aspect = this.perspCamera.aspect;
		this.fov = this.perspCamera.fov;
		this.focus = this.perspCamera.focus;
		this.filmGauge = this.perspCamera.filmGauge;
		this.filmOffset = this.perspCamera.filmOffset;

		// custom parameters
		this.targetOffset = 1000;

		this.userData = {
			type: SPE.CombinedCamera.name,
			isEntity: true,
			lock: false,
			scaleLock: false,
			activeCamera: false,
			hiddenMatrix: new THREE.Matrix4()
		};

		this.enableHelper = false;
		this.objectHelper = new SPE.CombinedCameraHelper( this );

		this.interaction = new Interaction( this );

		this.toOrthographic();

	}

	get hiddenMatrix() {

		return this.userData.hiddenMatrix;

	}

	set hiddenMatrix( mat ) {

		this.userData.hiddenMatrix.copy( mat );

	}

	get geometryHelper() {

		return SPE.CombinedCameraHelper.geometryHelper;

	}

	set visibility( value ) {

		this.visible = value;
		this.objectHelper.visible = value;

		for ( let i = 0, l = this.children.length; i < l; ++i ) {

			// Only entity children (cloner and stroke are not entities)
			if ( this.children[ i ].traverseEntity === undefined ) continue;
			
			this.children[ i ].traverseEntity( function( object ) {

				if ( object.objectHelper !== undefined && object.visible === true ) {

					object.objectHelper.visible = value;

				}

			} );

		}

	}

	get visibility() {

		return this.visible;

	}

	get type() {

		return this._type;

	}

	set type( type ) {

		if ( type === 'PerspectiveCamera' ) {

			this.toPerspective();

		} else if ( type === 'OrthographicCamera' ) {

			this.toOrthographic();

		}

	}

	get near() {

		if ( this.isPerspectiveCamera ) {

			return this.perspCamera.near;

		} else if ( this.isOrthographicCamera ) {

			return this.orthoCamera.near;

		}

	}

	set near( near ) {

		if ( this.isPerspectiveCamera ) {

			this.perspCamera.near = near;

		} else if ( this.isOrthographicCamera ) {

			this.orthoCamera.near = near;

		}

	}

	get zoom() {

		if ( this.isPerspectiveCamera ) {

			return this.perspCamera.zoom;

		} else if ( this.isOrthographicCamera ) {

			return this.orthoCamera.zoom;

		}

	}

	set zoom( zoom ) {

		if ( zoom < 0 ) return;

		if ( this.isPerspectiveCamera ) {

			this.perspCamera.zoom = zoom;

		} else if ( this.isOrthographicCamera ) {

			this.orthoCamera.zoom = zoom;

		}

	}

	getTarget( target, direction ) { // orbitControls need target, it rotate around of a target

		if ( target === undefined ) {

			console.warn( 'SPE.CombinedCamera: .getTarget() target is now required' );
			target = new THREE.Vector3();

		}

		let offset;

		if ( direction === undefined ) {

			// direction = new THREE.Vector3( 0, 0, -1 ).applyQuaternion( this.quaternion );
			offset = this.getWorldDirection( new THREE.Vector3() ).multiplyScalar( this.targetOffset );

		} else {

			offset = direction.clone().multiplyScalar( this.targetOffset );

		}

		target.copy( this.position ).add( offset );

		return target;

	}

	getViewFrontToObject( object ) {

		const target = object.getWorldPosition( new THREE.Vector3() );
		const direction = object.getWorldDirection( new THREE.Vector3() );
		const offset = direction.multiplyScalar( this.targetOffset );

		return { position: target.clone().add( offset ), target: target };

	}

	getViewToObject( object ) {

		const target = object.getWorldPosition( new THREE.Vector3() );
		const direction = this.getWorldDirection( new THREE.Vector3() );
		const offset = direction.multiplyScalar( this.targetOffset );

		return { position: target.clone().sub( offset ), target: target };

	}

	setViewplaneSize( width, height ) {

		this.left  = - width * .5;
		this.right = width * .5;
		this.top = height * .5;
		this.bottom = - height * .5;

		this.aspect = width / height;

		this.updateProjectionMatrix();

	}

	toOrthographic( forceUpdateHelper ) {

		this.orthoCamera.left = this.left;
		this.orthoCamera.right = this.right;
		this.orthoCamera.top = this.top;
		this.orthoCamera.bottom = this.bottom;
		this.orthoCamera.view = this.view;
		// this.orthoCamera.zoom = this.zoom;
		// this.orthoCamera.near = this.near;
		this.orthoCamera.far = this.far;

		this.orthoCamera.updateProjectionMatrix();
		this.projectionMatrix = this.orthoCamera.projectionMatrix;
		this.projectionMatrixInverse = this.orthoCamera.projectionMatrixInverse;

		delete this.isPerspectiveCamera;
		this.isOrthographicCamera = true;
		this._type = 'OrthographicCamera';

		if ( this.enableHelper === true || forceUpdateHelper === true ) this.objectHelper.update();

	}

	toPerspective( forceUpdateHelper ) {

		this.perspCamera.aspect = this.aspect;
		this.perspCamera.fov = this.fov;
		this.perspCamera.view = this.view;
		// this.perspCamera.zoom = this.zoom;
		// this.perspCamera.near = this.near;
		this.perspCamera.far = this.far;

		this.perspCamera.updateProjectionMatrix();
		this.projectionMatrix = this.perspCamera.projectionMatrix;
		this.projectionMatrixInverse = this.perspCamera.projectionMatrixInverse;

		delete this.isOrthographicCamera;
		this.isPerspectiveCamera = true;
		this._type = 'PerspectiveCamera';

		if ( this.enableHelper === true || forceUpdateHelper === true ) this.objectHelper.update();

	}

	// override
	setFocalLength( focalLength ) {

		this.perspCamera.setFocalLength( focalLength );
		this.toPerspective();

	}

	// override
	getFocalLength() {

		return this.perspCamera.getFocalLength();

	}

	// override
	getEffectiveFOV() {

		return this.perspCamera.getEffectiveFOV();

	}

	// override
	getFilmWidth() {

		return this.perspCamera.getFilmWidth();

	}

	// override
	getFilmHeight() {

		return this.perspCamera.getFilmHeight();

	}

	// override
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.isPerspectiveCamera ) {

			this.perspCamera.setViewOffset( fullWidth, fullHeight, x, y, width, height );
			this.toPerspective();

		} else if ( this.isOrthographicCamera ) {

			this.orthoCamera.setViewOffset( fullWidth, fullHeight, x, y, width, height );
			this.toOrthographic();

		}

	}

	// override
	clearViewOffset () {

		if ( this.isPerspectiveCamera ) {

			this.perspCamera.clearViewOffset();
			this.toPerspective();

		} else if ( this.isOrthographicCamera ) {

			this.orthoCamera.clearViewOffset();
			this.toOrthographic();

		}

	}

	// override
	updateProjectionMatrix( forceUpdateHelper ) {

		if ( this.isPerspectiveCamera ) {

			this.toPerspective( forceUpdateHelper );

		} else if ( this.isOrthographicCamera ) {

			this.toOrthographic( forceUpdateHelper );

		}

	}

	// override
	updateMatrixWorld ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				//this.matrixWorld.copy( this.matrix );
				this.matrixWorld.multiplyMatrices( this.userData.hiddenMatrix, this.matrix );

			} else {

				//this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.userData.hiddenMatrix );
				this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

		this.matrixWorldInverse.getInverse( this.matrixWorld );

	}

	// override
	updateWorldMatrix ( updateParents, updateChildren ) {

		var parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			//this.matrixWorld.copy( this.matrix );
			this.matrixWorld.multiplyMatrices( this.userData.hiddenMatrix, this.matrix ); // nisa modification

		} else {

			//this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.userData.hiddenMatrix );  // nisa modification
			this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );  // nisa modification

		}

		// update children

		if ( updateChildren === true ) {

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

		this.matrixWorldInverse.getInverse( this.matrixWorld );

	}

	// override
	attach ( object ) {

		const _m1 = new THREE.Matrix4();

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1.getInverse( this.matrixWorld );

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1.multiply( object.parent.matrixWorld );

		}

		if ( object.userData.hiddenMatrix !== undefined ) {

			object.userData.hiddenMatrix.premultiply( _m1 );

		} else {

			object.applyMatrix4( _m1 );

		}

		object.updateWorldMatrix( false, false );

		this.add( object );

		return this;

	}

    computeSingleBoundingBox() {

		if ( !this.singleBoundingBox ) {

			this.singleBoundingBox = new SPE.Box3();

		}

		this.singleBoundingBox.setFromObjectSize( this, false );
		this.singleBoundingBox.computeVertices();
		this.singleBoundingBox.computeEdges();

	}

    computeComplexBoundingBox( recursive ) {

		if ( !this.complexBoundingBox ) {

			this.complexBoundingBox = new SPE.Box3();

		}

		this.complexBoundingBox.setFromObjectSize( this, recursive );

    }

	// override
	raycast( raycaster, intersects ) {

		// TODO there is a bug if we try intersect with a activeCamera (but not with active and default camera)
		if ( this.enableHelper === true && this.objectHelper.visible === true && this.userData.activeCamera === false ) {

			this.objectHelper.raycast( raycaster, intersects );

		}

	}

	// override
	copy( source, recursive ) {

		// patch: we need use a fork in order to use the argument recursive and prevent to clone children
		const children = source.children;
		source.children = [];
		super.copy( source );
		source.children = children;

		this.userDataFromJson( this.userData );
		this.userData.activeCamera = false;
		this.userData.isEntity = true;
		delete this.userData.isDefaultCamera;

		this.orthoCamera.copy( source.orthoCamera );
		this.perspCamera.copy( source.perspCamera );

		// orthographic parameters
		this.left = source.left,
		this.right = source.right,
		this.top = source.top,
		this.bottom = source.bottom;
		this.far = source.far;
		this.view = source.view === null ? null : Object.assign( {}, source.view );
		this.isOrthographicCamera = source.isOrthographicCamera;
		this._type = source._type;

		// perspective parameters
		this.aspect = source.aspect;
		this.fov = source.fov;
		this.focus = source.focus;
		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;
		this.isPerspectiveCamera = source.isPerspectiveCamera;

		// custom parameters
		this.targetOffset = source.targetOffset;

		// check if exist because there is no helper in the source from customParseObject
		if ( source.enableHelper !== undefined ) this.enableHelper = source.enableHelper;
		if ( source.objectHelper !== undefined ) this.objectHelper.visible = source.objectHelper.visible;

		if ( source.interaction !== undefined ) this.interaction.copy( source.interaction );

		if ( recursive === true ) {

			for ( let i = 0, l = children.length; i < l; ++i ) {

				const child = source.children[ i ];

				if ( child.userData.isEntity === true ) {

					this.add( child.clone() );

				}

			}

		}

		this.updateProjectionMatrix();

		return this;

	}

	traverseEntity ( callback ) {

		function traverse( object ) {

			if ( ! object.userData.isEntity ) return;

			callback( object );

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; ++i ) {

				traverse( children[ i ] );

			}

		}

		traverse( this );

	}

	userDataFromJson( userData ) {

		this.userData = userData;
		this.userData.positionToCenter = new THREE.Vector3();

		this.userData.hiddenMatrix = new THREE.Matrix4();
		if ( userData.hiddenMatrix !== undefined ) this.userData.hiddenMatrix.fromArray( userData.hiddenMatrix.elements );

		if ( userData.lock === undefined ) this.userData.lock = false; // PATCH: changing the version

	}

	fromJSON( data ) { // TODO: it is only a part of the fromJSON, it needs super.fromJSON()

		// orthographic parameters
		this.left = data.left,
		this.right = data.right,
		this.top = data.top,
		this.bottom = data.bottom;
		if ( data.view !== undefined ) this.view = Object.assign( {}, data.view );
		if ( data.zoomOrtho !== undefined ) this.orthoCamera.zoom = data.zoomOrtho;
		if ( data.nearOrtho !== undefined ) this.orthoCamera.near = data.nearOrtho;
		this.far = data.far;
		this._type = data.type;
		if ( data.isOrthographicCamera ) this.isOrthographicCamera = data.isOrthographicCamera;

		// perspective parameters
		this.aspect = data.aspect;
		this.fov = data.fov;
		this.focus = data.focus;
		this.filmGauge = data.filmGauge;
		this.filmOffset = data.filmOffset;
		if ( data.zoomPersp !== undefined ) this.perspCamera.zoom = data.zoomPersp;
		if ( data.nearPersp !== undefined ) this.perspCamera.near = data.nearPersp;
		if ( data.isPerspectiveCamera ) this.isPerspectiveCamera = data.isPerspectiveCamera;

		// custom parameters
		if ( data.targetOffset !== undefined ) this.targetOffset = data.targetOffset;

		this.userDataFromJson( this.userData );

		this.updateProjectionMatrix();

		return this;

	}

	// override
	toJSON( meta ) {

		let data;

		// PATCH to control the data to convert in JSON (we need use a fork o move out from userData)
		const userData = this.userData;
		delete this.userData;
		data = super.toJSON( meta );
		this.userData = userData;

		// orthographic parameters
		data.object.left = this.left,
		data.object.right = this.right,
		data.object.top = this.top,
		data.object.bottom = this.bottom;
		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
		data.object.zoomOrtho = this.orthoCamera.zoom;
		data.object.nearOrtho = this.orthoCamera.near;
		data.object.far = this.far;
		data.object.type = this._type;
		if ( this.isOrthographicCamera ) data.object.isOrthographicCamera = this.isOrthographicCamera;

		// perspective parameters
		data.object.aspect = this.aspect;
		data.object.fov = this.fov;
		data.object.focus = this.focus;
		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;
		data.object.zoomPersp = this.perspCamera.zoom;
		data.object.nearPersp = this.perspCamera.near;
		if ( this.isPerspectiveCamera ) data.object.isPerspectiveCamera = this.isPerspectiveCamera;

		// custom parameters
		data.object.targetOffset = this.targetOffset;

		data.object.userData = {
			type: SPE.CombinedCamera.name,
			isEntity: userData.isEntity,
			lock: userData.lock,
			scaleLock: userData.scaleLock,
			activeCamera: userData.activeCamera,
			hiddenMatrix: { elements: userData.hiddenMatrix.toArray() }
		};

		data.object.enableHelper = this.enableHelper;

		data.object.interaction = this.interaction.toJSON( meta );

		return data;

	}

}/**
 * @author nisa, alejandro
 */

'use strict';

//@classname{SPE.RectangleGeometry}
SPE.RectangleGeometry = new function() {

	
	this.build = function( // TODO if it dont have radius use PlaneBufferGeometry
		{
			width = 100,
			height = width,
			cornerRadius = [0, 0, 0, 0],
			cornerType = 1,
			enabledIndieCorners = false,
			extrudeDepth = 0,
			extrudeBevelSize = 0,
			extrudeBevelSegments = 1
		}
	) {
		width = Math.abs(width);
		height = Math.abs(height);

		let r = {x: width * 0.5, y: height * 0.5}
		let min = {x: -r.x, y: -r.y};
		let max = {x: r.x, y: r.y};

		function scaleRadius(r, a, b){
			if (a > width && b > height) {
				return Math.min((r * width) / a, (r * height) / b);
			} else if (a > width) {
				return (r * width) / a;
			} else if (b > height) {
				return (r * height) / b;
			}
			return r;
		}

		var scaledRadius = [];
		scaledRadius[0] = cornerRadius[0] === 0 ? 0 : scaleRadius(cornerRadius[0], cornerRadius[0] + cornerRadius[3], cornerRadius[0] + cornerRadius[1]);
		scaledRadius[1] = cornerRadius[1] === 0 ? 0 : scaleRadius(cornerRadius[1], cornerRadius[1] + cornerRadius[2], cornerRadius[1] + cornerRadius[0]);
		scaledRadius[2] = cornerRadius[2] === 0 ? 0 : scaleRadius(cornerRadius[2], cornerRadius[2] + cornerRadius[1], cornerRadius[2] + cornerRadius[3]);
		scaledRadius[3] = cornerRadius[3] === 0 ? 0 : scaleRadius(cornerRadius[3], cornerRadius[3] + cornerRadius[0], cornerRadius[3] + cornerRadius[2]);
		
		let left = min.x;
		let right = max.x;
		let top = max.y;
		let bottom = min.y;

		let shape = new THREE.Shape();

		shape.moveTo(left, top - scaledRadius[0]);

		if(cornerType == 1) { // Rounded using Cuadratic Curve (Smooth)
			
			if (cornerRadius[0] > 0) {
                shape.quadraticCurveTo(left, top, left + scaledRadius[0], top );
            }
            shape.lineTo(right - scaledRadius[1], top);
            
            if (cornerRadius[1] > 0) {
                shape.quadraticCurveTo(right, top, right, top - scaledRadius[1]);
            }

            shape.lineTo(right, bottom + scaledRadius[2]);

            if (cornerRadius[2] > 0) {
                shape.quadraticCurveTo(right, bottom, right - scaledRadius[2], bottom);
            }
            shape.lineTo(left + scaledRadius[3], bottom);

            if (cornerRadius[3] > 0) {
                shape.quadraticCurveTo(left, bottom, left, bottom + scaledRadius[3]);
            }

            shape.lineTo(left, top - scaledRadius[0]);

		} else { // Rounded using Bezier Curve (perfect ARC)

			let K = 4 * (Math.SQRT2-1) / 3; // This is a constant to keep perfect arcs using bezier curves.

			if (cornerRadius[0] > 0) {
				shape.bezierCurveTo(left, top + scaledRadius[0]*(K-1), left - scaledRadius[0]*(K-1), top, left + scaledRadius[0], top);
			}
			shape.lineTo(right - scaledRadius[1], top);

			if (cornerRadius[1] > 0) {
				shape.bezierCurveTo(right + scaledRadius[1]*(K-1), top, right, top + scaledRadius[1]*(K-1), right, top - scaledRadius[1]);
			}

			shape.lineTo(right, bottom + scaledRadius[2]);

			if (cornerRadius[2] > 0) {
				shape.bezierCurveTo(right, bottom - scaledRadius[2]*(K-1), right + scaledRadius[2]*(K-1), bottom, right - scaledRadius[2], bottom);
			}
			shape.lineTo(left + scaledRadius[3], bottom);

			if (cornerRadius[3] > 0) {
				shape.bezierCurveTo(left - scaledRadius[3]*(K-1), bottom, left, bottom - scaledRadius[3]*(K-1), left, bottom + scaledRadius[3]);
			}
		}

		shape.lineTo(left, top - scaledRadius[0]);

		// let geometry = new THREE.ShapeBufferGeometry(shape, 32);
		// Add barycentric coordinates to the buffer-geometry to handle effects that might need this attribute
		//SPE.Geometry.Utils.addBarycentricAttribute( geometry, 'barycentric' );

		let geometry;
		if(extrudeDepth > 0 ) {
			geometry = new THREE.ExtrudeBufferGeometry(
				shape,
				{
					curveSegments: 64,
					steps: 1,
					depth: extrudeDepth,
					bevelEnabled: true,
					bevelThickness: extrudeBevelSize,
					bevelSize: extrudeBevelSize,
					bevelOffset: 0,
					bevelSegments: extrudeBevelSegments
				}
			);

		} else {
			geometry = new THREE.ShapeBufferGeometry( shape, 32 );
		}

		geometry.userData = {
			type: "RectangleGeometry",
			ui: {
				enabledIndieCorners: enabledIndieCorners
			},
			parameters: {
				width: width,
				height: height,
				depth: 0,
				cornerRadius: cornerRadius,
				cornerType: cornerType,
				extrudeDepth: extrudeDepth,
				extrudeBevelSize: extrudeBevelSize,
				extrudeBevelSegments: extrudeBevelSegments
			}
		};

		// FIX UV MAPPING
		SPE.Math.fixUvs( geometry, width, height );

		return geometry;

	}
	

	// this.buildFromGeometry = function(geometry, parameters) {
	// 	let width = parameters.width || geometry.userData.parameters.width;
	// 	let height = parameters.height || geometry.userData.parameters.height;
	// 	let cornerRadius = parameters.cornerRadius !== undefined ? parameters.cornerRadius : geometry.userData.parameters.cornerRadius;
	// 	let cornerType = parameters.cornerType || geometry.userData.parameters.cornerType;

	// 	return this.build({width, height, cornerRadius, cornerType});
	// }

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			cornerRadius = geometry.userData.parameters.cornerRadius,
			cornerType = geometry.userData.parameters.cornerType,
			enabledIndieCorners = geometry.userData.ui.enabledIndieCorners,
			extrudeDepth = geometry.userData.parameters.extrudeDepth,
			extrudeBevelSize = geometry.userData.parameters.extrudeBevelSize,
			extrudeBevelSegments = geometry.userData.parameters.extrudeBevelSegments,
		}
	) {

		return this.build( { width, height, cornerRadius, cornerType, enabledIndieCorners, extrudeDepth, extrudeBevelSize, extrudeBevelSegments } );

	}
}
/**
 * @author nisa
 */

'use strict';

SPE.CombinedCameraHelper = class CombinedCameraHelper extends THREE.CameraHelper {

	constructor( camera ) {
		
		super( camera );

		const geometry = new THREE.SphereGeometry( 15, 4, 2 );
		const material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
		const object = new THREE.Mesh( geometry, material );
		this.add( object );
		
		this.isObjectHelper = true;
		this.name = `CombinedCameraHelper: ${camera.uuid}`;
		
	}

	raycast( raycaster, intersects ) { // TODO nisa: simplify

		var _ray = SPE.CombinedCameraHelper._ray; // nisa: we can avoid this using a fork
		var _sphere = SPE.CombinedCameraHelper._sphere;
		var _inverseMatrix = SPE.CombinedCameraHelper._inverseMatrix;

		var geometry = SPE.CombinedCameraHelper.geometryHelper;
		var matrixWorld = this.camera.matrixWorld;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.getInverse( matrixWorld );
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		var intersection;

		var a, b, c;
		var index = geometry.index;
		var position = geometry.attributes.position;
		var drawRange = geometry.drawRange;
		var i, il;
		var start, end;

		// indexed buffer geometry
		start = Math.max( 0, drawRange.start );
		end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

		for ( i = start, il = end; i < il; i += 3 ) {

			a = index.getX( i );
			b = index.getX( i + 1 );
			c = index.getX( i + 2 );

			intersection = checkBufferGeometryIntersection( this.camera, raycaster, _ray, position, a, b, c );

			if ( intersection ) {

				intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
				intersects.push( intersection );

			}

		}

		function checkBufferGeometryIntersection( object, raycaster, ray, position, a, b, c ) {

			var _vA = new THREE.Vector3();
			var _vB = new THREE.Vector3();
			var _vC = new THREE.Vector3();

			var point = new THREE.Vector3();
			var _intersectionPointWorld = new THREE.Vector3();

			_vA.fromBufferAttribute( position, a );
			_vB.fromBufferAttribute( position, b );
			_vC.fromBufferAttribute( position, c );

			var intersect = ray.intersectTriangle( _vA, _vB, _vC, false, point );

			if ( intersect === null ) return null;

			_intersectionPointWorld.copy( point );
			_intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) return null;

			return {
				distance: distance,
				point: _intersectionPointWorld.clone(),
				object: object
			};

		}

	}

}

SPE.CombinedCameraHelper._ray = new THREE.Ray();
SPE.CombinedCameraHelper._sphere = new THREE.Sphere();
SPE.CombinedCameraHelper._inverseMatrix = new THREE.Matrix4();
SPE.CombinedCameraHelper.geometryHelper = new THREE.BoxBufferGeometry( 30, 30, 30 );/**
 * @author sciecode
 */

'use strict';

SPE.LightSpot = class LightSpot extends THREE.SpotLight {

	constructor( color, intensity, distance, angle, penumbra, decay ) {

		super( color, intensity, distance, angle, penumbra, decay );

		this.shadow.mapSize.width = 1024;
		this.shadow.mapSize.height = 1024;

		this.userData = {
			type: SPE.LightSpot.name,
			isEntity: true,
			lock: false,
			scaleLock: false,
			hiddenMatrix: new THREE.Matrix4()
		};

		this.enableHelper = false;
		this.objectHelper = new SPE.SpotLightHelper( this );
		
		this.interaction = new Interaction( this );

		// Storage for all gizmos handled by this object
		this._gizmos = {};

		// Configure the shadow-map to some default acceptable parameters
		const shadowmapConfig = this.shadow;
		const viewFrustum = shadowmapConfig.camera;
		// Keep the frustum to the same size as the spotlight-angle
		viewFrustum.fov = THREE.MathUtils.RAD2DEG * 2 * this.angle; viewFrustum.aspect = 1;
		viewFrustum.near = 100.0; viewFrustum.far = 2500.0;

		// Add a gizmo to visualize the view-frustum handled by the shadow-map
		const shadowmapViewGizmo = new THREE.CameraHelper( this.shadow.camera );
		shadowmapViewGizmo.visible = false;
		this._gizmos['shadowmap'] = shadowmapViewGizmo;

        this.update();

	}

	get hiddenMatrix() { return this.userData.hiddenMatrix; }

	set hiddenMatrix( mat ) { this.userData.hiddenMatrix.copy( mat ); }

	get geometryHelper() { return SPE.SpotLightHelper.geometryHelper; }

	get gizmos() { return this._gizmos; }

	set visibility( value ) {

		this.visible = value;
		this.objectHelper.visible = value;

		for ( let i = 0, l = this.children.length; i < l; ++i ) {

			// Only entity children (cloner and stroke are not entities)
			if ( this.children[ i ].traverseEntity === undefined ) continue;

			this.children[ i ].traverseEntity( function( object ) {

				if ( object.objectHelper !== undefined && object.visible === true ) {
						
					object.objectHelper.visible = value;

				}

			} );

		}

	}

	get visibility() {

		return this.visible;

	}

	showGizmos() {

		for ( const [name, gizmo] of Object.entries( this._gizmos ) ) {

			/**/ if ( gizmo instanceof THREE.CameraHelper ) {

				gizmo.visible = true;

			}

		}

	}

	hideGizmos() {

		for ( const [name, gizmo] of Object.entries( this._gizmos ) ) {

			/**/ if ( gizmo instanceof THREE.CameraHelper ) {

				gizmo.visible = false;

			}

		}

	}

    update() {

		// Update the current frustum of the shadow volume
		this.shadow.camera.updateProjectionMatrix();
		// Update gizmos, as they depend on this object as its parent
		for ( const [name, gizmo] of Object.entries( this._gizmos ) ) {

			/**/ if ( gizmo instanceof THREE.CameraHelper ) {

				gizmo.update();

			}

		}

	}

	updateMatrixWorld ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				//this.matrixWorld.copy( this.matrix );
				this.matrixWorld.multiplyMatrices( this.userData.hiddenMatrix, this.matrix );

			} else {

				//this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.userData.hiddenMatrix );
				this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		if ( this.enableHelper === true && this.objectHelper.viisble === true ) this.objectHelper.update();

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {
			
			children[ i ].updateMatrixWorld( force );

		}

	}

	updateWorldMatrix ( updateParents, updateChildren ) {

		var parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			//this.matrixWorld.copy( this.matrix );
			this.matrixWorld.multiplyMatrices( this.userData.hiddenMatrix, this.matrix ); // nisa modification

		} else {

			//this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.userData.hiddenMatrix );  // nisa modification
			this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );  // nisa modification

		}

		// update children

		if ( updateChildren === true ) {

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	}

	attach ( object ) {

		const _m1 = new THREE.Matrix4();

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1.getInverse( this.matrixWorld );

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1.multiply( object.parent.matrixWorld );

		}

		if ( object.userData.hiddenMatrix !== undefined ) {

			object.userData.hiddenMatrix.premultiply( _m1 );
		
		} else {

			object.applyMatrix4( _m1 );

		}
		
		object.updateWorldMatrix( false, false );

		this.add( object );

		return this;

	}
	
    computeSingleBoundingBox() {

		if ( !this.singleBoundingBox ) {

			this.singleBoundingBox = new SPE.Box3();

		}

		this.singleBoundingBox.setFromObjectSize( this, false );
		this.singleBoundingBox.computeVertices();
		this.singleBoundingBox.computeEdges();

	}

    computeComplexBoundingBox( recursive ) {

		if ( !this.complexBoundingBox ) {

			this.complexBoundingBox = new SPE.Box3();

		}

		this.complexBoundingBox.setFromObjectSize( this, recursive );
		
	}
	
	raycast( raycaster, intersects ) {
			
		this.objectHelper.raycast( raycaster, intersects );

	}

	copy( source, recursive ) {

		// patch: we need use a fork in order to use the argument recursive and prevent to clone children
		const children = source.children;
		source.children = [];
		super.copy( source );
		source.children = children;

		this.userDataFromJson( this.userData );
		
		// check if exist because there is no helper in the source from customParseObject
		if ( source.enableHelper !== undefined ) this.enableHelper = source.enableHelper;
		if ( source.objectHelper !== undefined ) this.objectHelper.visible = source.objectHelper.visible;

		if ( source.interaction !== undefined ) this.interaction.copy( source.interaction );

		if ( recursive === true ) {

			for ( let i = 0, l = children.length; i < l; ++i ) {

				const child = source.children[ i ];

				if ( child.userData.isEntity === true ) {

					this.add( child.clone() );

				}

			}

		}

		return this;

	}

	traverseEntity ( callback ) {

		function traverse( object ) {

			if ( ! object.userData.isEntity ) return;

			callback( object );

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; ++i ) {

				traverse( children[ i ] );

			}

		}
		
		traverse( this );

	}

	userDataFromJson( userData ) {

		this.userData = userData;
		
		if ( userData.hiddenMatrix !== undefined ) {

			this.userData.hiddenMatrix = new THREE.Matrix4().fromArray( userData.hiddenMatrix.elements );

		}

		if ( userData.lock === undefined ) this.userData.lock = false; // PATCH: changing the version

	}

	toJSON( meta ) {
 
		// PATCH to control the data to convert in JSON (we need use a fork o move out from userData)
		const userData = this.userData;
		delete this.userData;

		const data = super.toJSON( meta );
		data.object.userData = {
			type: SPE.LightSpot.name,
			isEntity: userData.isEntity,
			lock: userData.lock,
			scaleLock: userData.scaleLock,
			hiddenMatrix: { elements: userData.hiddenMatrix.toArray() }
		};
		data.object.enableHelper = this.enableHelper;
		data.object.interaction = this.interaction.toJSON( meta );
		// data.object.gizmos = {
		// 	shadowmap: { visible: this._gizmos[ 'shadowmap' ].visible }
		// };

		this.userData = userData;
		
		return data;

	}

}/**
 * @author alejandro
 * @author nisa
 */

'use strict';

class Cloner extends THREE.Object3D {

	constructor( object, params = {} ) {

		super();

		this.object = object;
		this.userData.type = 'Cloner';
		this.userData.skip = true;

		object.computeComplexBoundingBox( true );
		const size = object.complexBoundingBox.getSize( new THREE.Vector3() );
		const margin = 0.1;
		
		this.parameters = {
			type: params.type !== undefined ? params.type : 'radial',
			hideBase: params.hideBase !== undefined ? params.hideBase : false,
			count: params.count !== undefined ? params.count : 3,
			ra_radius: params.ra_radius !== undefined ? params.ra_radius : Math.max( size.x, size.y ) * 2,
			ra_startAngle: params.ra_startAngle !== undefined ? params.ra_startAngle : 0,
			ra_endAngle: params.ra_endAngle !== undefined ? params.ra_endAngle : 360,
			ra_align: params.ra_align !== undefined ? params.ra_align : false,
			ra_axis: params.ra_axis !== undefined ? params.ra_axis : 'y',
			ra_scale: params.ra_scale !== undefined ? params.ra_scale.clone() : new THREE.Vector3(),
			ra_rotation: params.ra_rotation !== undefined ? params.ra_rotation.clone() : new THREE.Euler(),
			ra_position: params.ra_position !== undefined ? params.ra_position.clone() : new THREE.Vector3(),
			li_scale: params.li_scale !== undefined ? params.li_scale.clone() : new THREE.Vector3(),
			li_rotation: params.li_rotation !== undefined ? params.li_rotation.clone() : new THREE.Euler(),
			li_position: params.li_position !== undefined ? params.li_position.clone() : new THREE.Vector3( size.x + ( size.x * margin ), 0, 0 ).round(),
			gr_count: params.gr_count !== undefined ? params.gr_count.clone() : new THREE.Vector3( 2, 2, 2 ),
			gr_size: params.gr_size !== undefined ? params.gr_size.clone() : new THREE.Vector3( size.x + ( size.x * margin ), size.y + ( size.y * margin ), size.z + ( size.z * margin ) ).round(),
			gr_fromCenter: params.gr_fromCenter !== undefined ? params.gr_fromCenter : true
		};

		this.update();
		this.setHideBase( this.parameters.hideBase );
		
	}

	refreshMaterial() {

		for ( let i = 0, l = this.children.length; i < l; ++i ) {
			
			this.children[ i ].material = this.object.material;

		}	

	}

	setHideBase( hideBase ) {

		if ( this.object.material === undefined ) return;

		if ( this.children.length > 0 ) {

			this.object.material.visible = true;

			if ( hideBase === true ) {

				const material = this.object.material.clone();

				for ( let i = 0, l = this.children.length; i < l; ++i ) {

					this.children[ i ].material = material;

				}

			} else {

				for ( let i = 0, l = this.children.length; i < l; ++i ) {

					this.children[ i ].material = this.object.material;

				}

			}

		}

		this.object.material.visible = !hideBase;
		this.parameters.hideBase = hideBase;

	}

	update() {

		this._updateCount();

		switch ( this.parameters.type ) {
			case 'radial':
				this._updateRadial();
				break;
			case 'linear':
				this._updateLinear();
				break;
			case 'grid':
				this._updateGrid();
		}
		
	}

	_updateCount() {
		
		const params = this.parameters;
		const count = ( params.type === 'grid' ) ? ( params.gr_count.x * params.gr_count.y * params.gr_count.z ) : params.count;

		if ( this.children.length === count ) return;

		if ( this.children.length < count ) {
			
			for ( let i = 0, l = count - this.children.length; i < l; ++i ) {

				const clone = this.object.shallowClone( false );
				delete clone.userData.isEntity;
				this.add( clone );
	
			}

		} else {

			for ( let i = 0, l = this.children.length - count; i < l; ++i ) {
				
				this.remove( this.children[ 0 ] );

			}

		}

	}

	_updateRadial() {

		const params = this.parameters;
		const startRad = params.ra_startAngle * THREE.Math.DEG2RAD;
		const endRad = params.ra_endAngle * THREE.Math.DEG2RAD;
		const diffRad = startRad - endRad;
		const rotation = new THREE.Euler(
			params.ra_rotation.x * THREE.Math.DEG2RAD,
			params.ra_rotation.y * THREE.Math.DEG2RAD,
			params.ra_rotation.z * THREE.Math.DEG2RAD,
		);
		let axisVector;
		if ( params.ra_axis == 'x' ) axisVector = new THREE.Vector3( 1, 0, 0 );
		if ( params.ra_axis == 'y' ) axisVector = new THREE.Vector3( 0, 1, 0 );
		if ( params.ra_axis == 'z' ) axisVector = new THREE.Vector3( 0, 0, 1 );
	
		for ( let i = 0; i < params.count; i++ ) {
			
			const child = this.children[ i ];

			child.hiddenMatrix.identity();

			child.scale.x = params.ra_scale.x + 1;
			child.scale.y = params.ra_scale.y + 1;
			child.scale.z = params.ra_scale.z + 1;

			child.position.setScalar( 0 );
			const rotationAxis = ( diffRad / params.count * i ) - startRad;
			if ( params.ra_axis == 'x' ) child.rotation.set( 0, rotationAxis, 0 );
			if ( params.ra_axis == 'y' ) child.rotation.set( 0, 0, rotationAxis );
			if ( params.ra_axis == 'z' ) child.rotation.set( rotationAxis, 0, 0) ;
			child.translateOnAxis( axisVector, params.ra_radius );
			child.position.add( params.ra_position );

			if ( params.ra_align === true ) {
				
				child.rotation.x += rotation.x;
				child.rotation.y += rotation.y;
				child.rotation.z += rotation.z;

			} else {

				child.rotation.copy( rotation );

			}

		}

	}

	_updateLinear() {

		const params = this.parameters;
		const rotation = new THREE.Euler(
			params.li_rotation.x * THREE.Math.DEG2RAD,
			params.li_rotation.y * THREE.Math.DEG2RAD,
			params.li_rotation.z * THREE.Math.DEG2RAD,
		);

		for ( let i = 0; i < params.count; i++ ) {
  
			const child = this.children[ i ];

			child.hiddenMatrix.identity();
			
			child.scale.x = params.li_scale.x * i + 1;
			child.scale.y = params.li_scale.y * i + 1;
			child.scale.z = params.li_scale.z * i + 1;
			
			child.rotation.x = rotation.x * i;
			child.rotation.y = rotation.y * i;
			child.rotation.z = rotation.z * i;

			child.position.x = params.li_position.x * i;
			child.position.y = params.li_position.y * i;
			child.position.z = params.li_position.z * i;
		
		}	  

	}

	_updateGrid() {

		const params = this.parameters;
		let index = 0;

		if ( params.gr_fromCenter === true ) {

			const discount = {
				x: ( params.gr_count.x % 2 ) === 0 ? 2 : 1,
				y: ( params.gr_count.y % 2 ) === 0 ? 2 : 1,
				z: ( params.gr_count.z % 2 ) === 0 ? 2 : 1
			};
			const offset = new THREE.Vector3( 
				( params.gr_size.x * ( params.gr_count.x - discount.x ) ) * 0.5,
				( params.gr_size.y * ( params.gr_count.y - discount.y ) ) * 0.5,
				( params.gr_size.z * ( params.gr_count.z - discount.z ) ) * 0.5
			);

			for ( let i = 0; i < params.gr_count.x; i++ ) {

				for ( let j = 0; j < params.gr_count.y; j++ ) {
				
					for ( let k = 0; k < params.gr_count.z; k++ ) {

						const child = this.children[ index++ ];
						
						child.hiddenMatrix.identity();
						child.scale.setScalar( 1 );
						child.rotation.set( 0, 0, 0 );
						
						child.position.x = params.gr_size.x * i - offset.x;
						child.position.y = params.gr_size.y * j - offset.y;
						child.position.z = params.gr_size.z * k - offset.z;

					}

				}

			}

		} else {

			for ( let i = 0; i < params.gr_count.x; i++ ) {
			
				for ( let j = 0; j < params.gr_count.y; j++ ) {
					
					for ( let k = 0; k < params.gr_count.z; k++ ) {

						const child = this.children[ index++ ];

						child.hiddenMatrix.identity();
						child.scale.setScalar( 1 );
						child.rotation.set( 0, 0, 0 );

						child.position.x = params.gr_size.x * i;
						child.position.y = - params.gr_size.y * j;
						child.position.z = - params.gr_size.z * k;

					}

				}

			}
			
		}

	}
 
	toJSON() {

		const params = this.parameters;
		const data = {};
		
		data.parameters = {
			type: params.type,
			hideBase: params.hideBase,
			count: params.count,
			ra_radius: params.ra_radius,
			ra_startAngle: params.ra_startAngle,
			ra_endAngle: params.ra_endAngle,
			ra_align: params.ra_align,
			ra_axis: params.ra_axis,
			ra_scale: params.ra_scale.toArray(),
			ra_rotation: params.ra_rotation.toArray(),
			ra_position: params.ra_position.toArray(),
			li_scale: params.li_scale.toArray(),
			li_rotation: params.li_rotation.toArray(),
			li_position: params.li_position.toArray(),
			gr_count: params.gr_count.toArray(),
			gr_size: params.gr_size.toArray(),
			gr_fromCenter: params.gr_fromCenter
		};

		return data;

	}

	fromJSON( data ) {

		const params = data.parameters;

		this.parameters = {
			type: params.type,
			hideBase: params.hideBase,
			count: params.count,
			ra_radius: params.ra_radius,
			ra_startAngle: params.ra_startAngle,
			ra_endAngle: params.ra_endAngle,
			ra_align: params.ra_align,
			ra_axis: params.ra_axis,
			ra_scale: new THREE.Vector3().fromArray( params.ra_scale ),
			ra_rotation: new THREE.Vector3().fromArray( params.ra_rotation ),
			ra_position: new THREE.Vector3().fromArray( params.ra_position ),
			li_scale: new THREE.Vector3().fromArray( params.li_scale ),
			li_rotation: new THREE.Vector3().fromArray( params.li_rotation ),
			li_position: new THREE.Vector3().fromArray( params.li_position ),
			gr_count: new THREE.Vector3().fromArray( params.gr_count ),
			gr_size: new THREE.Vector3().fromArray( params.gr_size ),
			gr_fromCenter: params.gr_fromCenter,
		};

		this.update();
		this.setHideBase( this.parameters.hideBase );

		return this;

	}
	 
}/**
 * @author sciecode
 */

'use strict';

SPE.LightPoint = class LightPoint extends THREE.PointLight {

	constructor( color, intensity, distance, decay ) {

        super( color, intensity, distance, decay );

		this.shadow.mapSize.width = 1024;
		this.shadow.mapSize.height = 1024;

		this.userData = {
			type: SPE.LightPoint.name,
			isEntity: true,
			lock: false,
			scaleLock: false,
			hiddenMatrix: new THREE.Matrix4()
		};

		this.enableHelper = false;
		this.objectHelper = new SPE.PointLightHelper( this );
		
		this.interaction = new Interaction( this );

		// Storage for all gizmos handled by this object
		this._gizmos = {};

		// Configure the shadow-map to some default acceptable parameters
		const shadowmapConfig = this.shadow;
		const viewFrustum = shadowmapConfig.camera;
		// Keep 90° and aspect-1 for the frustums to generate a cubemap
		viewFrustum.fov = 90; viewFrustum.aspect = 1;
		viewFrustum.near = 100.0; viewFrustum.far = 2500.0;

		// Add a gizmo to visualize the view-frustum handled by the shadow-map
		const v_min = new THREE.Vector3( -viewFrustum.far + this.position.x,
										 -viewFrustum.far + this.position.y,
										 -viewFrustum.far + this.position.z );
		const v_max = new THREE.Vector3( viewFrustum.far + this.position.x,
										 viewFrustum.far + this.position.y,
										 viewFrustum.far + this.position.z );
		const shadpwmapViewBox = new THREE.Box3( v_min, v_max );
		const shadowmapViewGizmo = new THREE.Box3Helper( shadpwmapViewBox, new THREE.Color( 0xffaa00 ) );
		shadowmapViewGizmo.visible = false;
		this._gizmos['shadowmap'] = shadowmapViewGizmo;

		this.update();
		
	}

	get hiddenMatrix() { return this.userData.hiddenMatrix; }

	set hiddenMatrix( mat ) { this.userData.hiddenMatrix.copy( mat ); }

	get geometryHelper() { return SPE.PointLightHelper.geometryHelper; }

	get gizmos() { return this._gizmos; }

	set visibility( value ) {

		this.visible = value;
		this.objectHelper.visible = value;

		for ( let i = 0, l = this.children.length; i < l; ++i ) {

			// Only entity children (cloner and stroke are not entities)
			if ( this.children[ i ].traverseEntity === undefined ) continue;

			this.children[ i ].traverseEntity( function( object ) {

				if ( object.objectHelper !== undefined && object.visible === true ) {
						
					object.objectHelper.visible = value;

				}

			} );

		}

	}

	get visibility() {

		return this.visible;

	}

	showGizmos() {

		for ( const [name, gizmo] of Object.entries( this._gizmos ) ) {

			/**/ if ( gizmo instanceof THREE.Box3Helper ) {

				gizmo.visible = true;

			}

		}

	}

	hideGizmos() {

		for ( const [name, gizmo] of Object.entries( this._gizmos ) ) {

			/**/ if ( gizmo instanceof THREE.Box3Helper ) {

				gizmo.visible = false;

			}

		}

	}

	update() {
		
		if ( this.shadow ) {
			// Update the current frustum of the shadow volume
			this.shadow.camera.updateProjectionMatrix();
			if ( this._gizmos ) {
				// Update gizmos, as they depend on this object as its parent
				for ( const [name, gizmo] of Object.entries( this._gizmos ) ) {
					/**/ if ( gizmo instanceof THREE.Box3Helper ) {
						const viewFrustum = this.shadow.camera;
						const v_min = new THREE.Vector3( -viewFrustum.far + this.position.x,
														 -viewFrustum.far + this.position.y,
														 -viewFrustum.far + this.position.z );
						const v_max = new THREE.Vector3( viewFrustum.far + this.position.x,
														 viewFrustum.far + this.position.y,
														 viewFrustum.far + this.position.z );
						gizmo.box.set( v_min, v_max );
						gizmo.updateMatrixWorld( true );
					}
				}
			}
		}
		
	}

	updateMatrixWorld ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				//this.matrixWorld.copy( this.matrix );
				this.matrixWorld.multiplyMatrices( this.userData.hiddenMatrix, this.matrix );

			} else {

				//this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.userData.hiddenMatrix );
				this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

		this.update(); // nisa: check why?

	}

	updateWorldMatrix ( updateParents, updateChildren ) {

		var parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			//this.matrixWorld.copy( this.matrix );
			this.matrixWorld.multiplyMatrices( this.userData.hiddenMatrix, this.matrix ); // nisa modification

		} else {

			//this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.userData.hiddenMatrix );  // nisa modification
			this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );  // nisa modification

		}

		// update children

		if ( updateChildren === true ) {

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	}

	attach ( object ) {

		const _m1 = new THREE.Matrix4();

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1.getInverse( this.matrixWorld );

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1.multiply( object.parent.matrixWorld );

		}

		if ( object.userData.hiddenMatrix !== undefined ) {

			object.userData.hiddenMatrix.premultiply( _m1 );
		
		} else {

			object.applyMatrix4( _m1 );

		}
		
		object.updateWorldMatrix( false, false );

		this.add( object );

		return this;

	}

    computeSingleBoundingBox() {

		if ( !this.singleBoundingBox ) {

			this.singleBoundingBox = new SPE.Box3();

		}

		this.singleBoundingBox.setFromObjectSize( this, false );
		this.singleBoundingBox.computeVertices();
		this.singleBoundingBox.computeEdges();

	}

    computeComplexBoundingBox( recursive ) {

		if ( !this.complexBoundingBox ) {

			this.complexBoundingBox = new SPE.Box3();

		}

		this.complexBoundingBox.setFromObjectSize( this, recursive );

    }

	raycast( raycaster, intersects ) {
			
		this.objectHelper.raycast( raycaster, intersects );

	}

	copy( source, recursive ) {

		// patch: we need use a fork in order to use the argument recursive and prevent to clone children
		const children = source.children;
		source.children = [];
		super.copy( source );
		source.children = children;

		this.userDataFromJson( this.userData );

		// check if exist because there is no helper in the source from customParseObject
		if ( source.enableHelper !== undefined ) this.enableHelper = source.enableHelper;
		if ( source.objectHelper !== undefined ) this.objectHelper.visible = source.objectHelper.visible;

		if ( source.interaction !== undefined ) this.interaction.copy( source.interaction );

		if ( recursive === true ) {

			for ( let i = 0, l = children.length; i < l; ++i ) {

				const child = source.children[ i ];

				if ( child.userData.isEntity === true ) {

					this.add( child.clone() );

				}

			}

		}

		return this;

	}

	traverseEntity ( callback ) {

		function traverse( object ) {

			if ( ! object.userData.isEntity ) return;

			callback( object );

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; ++i ) {

				traverse( children[ i ] );

			}

		}
		
		traverse( this );

	}

	userDataFromJson( userData ) {

		this.userData = userData;
		this.userData.positionToCenter = new THREE.Vector3();
		
		if ( userData.hiddenMatrix !== undefined ) {

			this.userData.hiddenMatrix = new THREE.Matrix4().fromArray( userData.hiddenMatrix.elements );

		}

		if ( userData.lock === undefined ) this.userData.lock = false; // PATCH: changing the version

	}

	toJSON( meta ) {
 
		// PATCH to control the data to convert in JSON (we need use a fork o move out from userData)
		const userData = this.userData;
		delete this.userData;

		const data = super.toJSON( meta );
		data.object.userData = {
			type: SPE.LightPoint.name,
			isEntity: userData.isEntity,
			lock: userData.lock,
			scaleLock: userData.scaleLock,
			hiddenMatrix: { elements: userData.hiddenMatrix.toArray() }
		};
		data.object.enableHelper = this.enableHelper;
		data.object.interaction = this.interaction.toJSON( meta );
		// data.object.gizmos = {
		// 	shadowmap: { visible: this._gizmos[ 'shadowmap' ].visible }
		// };

		this.userData = userData;
		
		return data;

	}

}/**
 * @author sciecode
 */

'use strict';

SPE.LightDirectional = class LightDirectional extends THREE.DirectionalLight {

	constructor( color, intensity ) {

		super( color, intensity );

		this.shadow.mapSize.width = 1024;
		this.shadow.mapSize.height = 1024;

		this.userData = {
			type: SPE.LightDirectional.name,
			isEntity: true,
			lock: false,
			scaleLock: false,
			hiddenMatrix: new THREE.Matrix4()
		};

		this.enableHelper = false;
		this.objectHelper = new SPE.DirectionalLightHelper( this );

		this.interaction = new Interaction( this );
		
		// Storage for all gizmos handled by this object
		this._gizmos = {};

		// Configure the shadow-map to some default acceptable parameters
		const shadowmapConfig = this.shadow;
		const viewFrustum = shadowmapConfig.camera;
		viewFrustum.top = 1250.0; viewFrustum.bottom = -1250.0;
		viewFrustum.right = 1250.0; viewFrustum.left = -1250.0;
		viewFrustum.near = 1.0; viewFrustum.far = 2500.0;

		// Add a gizmo to visualize the view-frustum handled by the shadow-map
		const shadowmapViewGizmo = new THREE.CameraHelper( this.shadow.camera );
		shadowmapViewGizmo.visible = false;
		this._gizmos['shadowmap'] = shadowmapViewGizmo;

		this.update();

	}

	get hiddenMatrix() { return this.userData.hiddenMatrix; }

	set hiddenMatrix( mat ) { this.userData.hiddenMatrix.copy( mat ); }

	get geometryHelper() { return SPE.DirectionalLightHelper.geometryHelper; }
	
	get gizmos() {

		return this._gizmos;

	}

	set visibility( value ) {

		this.visible = value;
		this.objectHelper.visible = value;

		for ( let i = 0, l = this.children.length; i < l; ++i ) {

			// Only entity children (cloner and stroke are not entities)
			if ( this.children[ i ].traverseEntity === undefined ) continue;

			this.children[ i ].traverseEntity( function( object ) {

				if ( object.objectHelper !== undefined && object.visible === true ) {
						
					object.objectHelper.visible = value;

				}

			} );

		}

	}

	get visibility() {

		return this.visible;

	}

	showGizmos() {

		for ( const [name, gizmo] of Object.entries( this._gizmos ) ) {

			/**/ if ( gizmo instanceof THREE.CameraHelper ) {

				gizmo.visible = true;

			}

		}

	}

	hideGizmos() {

		for ( const [name, gizmo] of Object.entries( this._gizmos ) ) {

			/**/ if ( gizmo instanceof THREE.CameraHelper ) {

				gizmo.visible = false;

			}

		}

	}

	update() {

		// Update the current frustum of the shadow volume
		this.shadow.camera.updateProjectionMatrix();
		// Update gizmos, as they depend on this object as its parent
		for ( const [name, gizmo] of Object.entries( this._gizmos ) ) {

			/**/ if ( gizmo instanceof THREE.CameraHelper ) {

				gizmo.update();

			}

		}

	}

	updateMatrixWorld ( force ) {
		
		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				//this.matrixWorld.copy( this.matrix );
				this.matrixWorld.multiplyMatrices( this.userData.hiddenMatrix, this.matrix );

			} else {

				//this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.userData.hiddenMatrix );
				this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		if ( this.enableHelper === true ) this.objectHelper.update();

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {
			
			children[ i ].updateMatrixWorld( force );

		}

	}

	updateWorldMatrix ( updateParents, updateChildren ) {

		var parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			//this.matrixWorld.copy( this.matrix );
			this.matrixWorld.multiplyMatrices( this.userData.hiddenMatrix, this.matrix ); // nisa modification

		} else {

			//this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.userData.hiddenMatrix );  // nisa modification
			this.matrixWorld.multiplyMatrices( this.matrixWorld, this.matrix );  // nisa modification

		}

		// update children

		if ( updateChildren === true ) {

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	}

	attach ( object ) {

		const _m1 = new THREE.Matrix4();

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1.getInverse( this.matrixWorld );

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1.multiply( object.parent.matrixWorld );

		}

		if ( object.userData.hiddenMatrix !== undefined ) {

			object.userData.hiddenMatrix.premultiply( _m1 );
		
		} else {

			object.applyMatrix4( _m1 );

		}
		
		object.updateWorldMatrix( false, false );

		this.add( object );

		return this;

	}

	computeSingleBoundingBox() {

		if ( !this.singleBoundingBox ) {

			this.singleBoundingBox = new SPE.Box3();

		}

		this.singleBoundingBox.setFromObjectSize( this, false );
		this.singleBoundingBox.computeVertices();
		this.singleBoundingBox.computeEdges();

	}

	computeComplexBoundingBox( recursive ) {

		if ( !this.complexBoundingBox ) {

			this.complexBoundingBox = new SPE.Box3();

		}

		this.complexBoundingBox.setFromObjectSize( this, recursive );

	}

	raycast( raycaster, intersects ) {
			
		this.objectHelper.raycast( raycaster, intersects );

	}

	copy( source, recursive ) {

		// patch: we need use a fork in order to use the argument recursive and prevent to clone children
		const children = source.children;
		source.children = [];
		super.copy( source );
		source.children = children;

		this.userDataFromJson( this.userData );

		// check if exist because there is no helper in the source from customParseObject
		if ( source.enableHelper !== undefined ) this.enableHelper = source.enableHelper;
		if ( source.objectHelper !== undefined ) this.objectHelper.visible = source.objectHelper.visible;

		if ( source.interaction !== undefined ) this.interaction.copy( source.interaction );

		if ( recursive === true ) {

			for ( let i = 0, l = children.length; i < l; ++i ) {

				const child = source.children[ i ];

				if ( child.userData.isEntity === true ) {

					this.add( child.clone() );

				}

			}

		}

		return this;

	}

	traverseEntity ( callback ) {

		function traverse( object ) {

			if ( ! object.userData.isEntity ) return;

			callback( object );

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; ++i ) {

				traverse( children[ i ] );

			}

		}
		
		traverse( this );

	}

	userDataFromJson( userData ) {

		this.userData = userData;

		if ( userData.hiddenMatrix !== undefined ) {

			this.userData.hiddenMatrix = new THREE.Matrix4().fromArray( userData.hiddenMatrix.elements );

		}

		if ( userData.lock === undefined ) this.userData.lock = false; // PATCH: changing the version
		
	}

	toJSON( meta ) {
 
		// PATCH to control the data to convert in JSON (we need use a fork o move out from userData)
		const userData = this.userData;
		delete this.userData;

		const data = super.toJSON( meta );
		data.object.userData = {
			type: SPE.LightDirectional.name,
			isEntity: userData.isEntity,
			lock: userData.lock,
			scaleLock: userData.scaleLock,
			hiddenMatrix: { elements: userData.hiddenMatrix.toArray() }
		};
		data.object.enableHelper = this.enableHelper;
		data.object.interaction = this.interaction.toJSON( meta );
		// data.object.gizmos = {
		// 	shadowmap: { visible: this._gizmos[ 'shadowmap' ].visible }
		// };

		this.userData = userData;
		
		return data;

	}

}/**
 * @author nisa
 */

'use strict';

SPE.SpotLightHelper = class SpotLightHelper extends THREE.SpotLightHelper {

	constructor( light, color = 0x666666 ) {

		super( light, color );

		this.isObjectHelper = true;
		this.name = `SpotLightHelper: ${light.uuid}`;
		
	}

	update() {

		// this.light.updateMatrixWorld(); // remove to prevent loop, light.updateMatrixWorld is calling this method

		const _vector = SPE.SpotLightHelper._vector; // nisa: we can avoid this using a fork

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}
	
	raycast( raycaster, intersects ) { // TODO nisa: simplify

		var _ray = SPE.SpotLightHelper._ray; // nisa: we can avoid this using a fork
		var _sphere = SPE.SpotLightHelper._sphere;
		var _inverseMatrix = SPE.SpotLightHelper._inverseMatrix;

		var geometry = SPE.SpotLightHelper.geometryHelper;
		var matrixWorld = this.light.matrixWorld;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.getInverse( matrixWorld );
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		var intersection;

		var a, b, c;
		var index = geometry.index;
		var position = geometry.attributes.position;
		var drawRange = geometry.drawRange;
		var i, il;
		var start, end;

		// indexed buffer geometry
		start = Math.max( 0, drawRange.start );
		end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

		for ( i = start, il = end; i < il; i += 3 ) {

			a = index.getX( i );
			b = index.getX( i + 1 );
			c = index.getX( i + 2 );

			intersection = checkBufferGeometryIntersection( this.light, raycaster, _ray, position, a, b, c );

			if ( intersection ) {

				intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
				intersects.push( intersection );

			}

		}

		function checkBufferGeometryIntersection( object, raycaster, ray, position, a, b, c ) {

			var _vA = new THREE.Vector3();
			var _vB = new THREE.Vector3();
			var _vC = new THREE.Vector3();

			var point = new THREE.Vector3();
			var _intersectionPointWorld = new THREE.Vector3();

			_vA.fromBufferAttribute( position, a );
			_vB.fromBufferAttribute( position, b );
			_vC.fromBufferAttribute( position, c );

			var intersect = ray.intersectTriangle( _vA, _vB, _vC, false, point );

			if ( intersect === null ) return null;

			_intersectionPointWorld.copy( point );
			_intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) return null;

			return {
				distance: distance,
				point: _intersectionPointWorld.clone(),
				object: object
			};

		}

	}

}

SPE.SpotLightHelper._vector = new THREE.Vector3();
SPE.SpotLightHelper._ray = new THREE.Ray();
SPE.SpotLightHelper._sphere = new THREE.Sphere();
SPE.SpotLightHelper._inverseMatrix = new THREE.Matrix4();
SPE.SpotLightHelper.geometryHelper = new THREE.BoxBufferGeometry( 30, 30, 30 );/**
 * @author nisa
 */

'use strict';

SPE.PointLightHelper = class PointLightHelper extends THREE.PointLightHelper {

	constructor( light, sphereSize = 15, color = 0x666666 ) {

		super( light, sphereSize, color );

		this.isObjectHelper = true;
		this.name = `PointLightHelper: ${light.uuid}`;

	}

	raycast( raycaster, intersects ) { // TODO nisa: simplify

		var _ray = SPE.PointLightHelper._ray; // nisa: we can avoid this using a fork
		var _sphere = SPE.PointLightHelper._sphere;
		var _inverseMatrix = SPE.PointLightHelper._inverseMatrix;

		var geometry = SPE.PointLightHelper.geometryHelper;
		var matrixWorld = this.light.matrixWorld;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.getInverse( matrixWorld );
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		var intersection;

		var a, b, c;
		var index = geometry.index;
		var position = geometry.attributes.position;
		var drawRange = geometry.drawRange;
		var i, il;
		var start, end;

		// indexed buffer geometry
		start = Math.max( 0, drawRange.start );
		end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

		for ( i = start, il = end; i < il; i += 3 ) {

			a = index.getX( i );
			b = index.getX( i + 1 );
			c = index.getX( i + 2 );

			intersection = checkBufferGeometryIntersection( this.light, raycaster, _ray, position, a, b, c );

			if ( intersection ) {

				intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
				intersects.push( intersection );

			}

		}

		function checkBufferGeometryIntersection( object, raycaster, ray, position, a, b, c ) {

			var _vA = new THREE.Vector3();
			var _vB = new THREE.Vector3();
			var _vC = new THREE.Vector3();

			var point = new THREE.Vector3();
			var _intersectionPointWorld = new THREE.Vector3();

			_vA.fromBufferAttribute( position, a );
			_vB.fromBufferAttribute( position, b );
			_vC.fromBufferAttribute( position, c );

			var intersect = ray.intersectTriangle( _vA, _vB, _vC, false, point );

			if ( intersect === null ) return null;

			_intersectionPointWorld.copy( point );
			_intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) return null;

			return {
				distance: distance,
				point: _intersectionPointWorld.clone(),
				object: object
			};

		}

	}

}

SPE.PointLightHelper._ray = new THREE.Ray();
SPE.PointLightHelper._sphere = new THREE.Sphere();
SPE.PointLightHelper._inverseMatrix = new THREE.Matrix4();
SPE.PointLightHelper.geometryHelper = new THREE.BoxBufferGeometry( 30, 30, 30 );/**
 * @author nisa
 */

'use strict';

SPE.DirectionalLightHelper = class DirectionalLightHelper extends THREE.DirectionalLightHelper {

	constructor( light, size = 15, color = 0x999999 ) {

		super( light, size, color);

		this.isObjectHelper = true;
		this.name = `DirectionalLightHelper: ${light.uuid}`;
		
	}

	raycast( raycaster, intersects ) { // TODO nisa: simplify

		var _ray = SPE.DirectionalLightHelper._ray; // nisa: we can avoid this using a fork
		var _sphere = SPE.DirectionalLightHelper._sphere;
		var _inverseMatrix = SPE.DirectionalLightHelper._inverseMatrix;

		var geometry = SPE.DirectionalLightHelper.geometryHelper;
		var matrixWorld = this.light.matrixWorld;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.getInverse( matrixWorld );
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		var intersection;

		var a, b, c;
		var index = geometry.index;
		var position = geometry.attributes.position;
		var drawRange = geometry.drawRange;
		var i, il;
		var start, end;

		// indexed buffer geometry
		start = Math.max( 0, drawRange.start );
		end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

		for ( i = start, il = end; i < il; i += 3 ) {

			a = index.getX( i );
			b = index.getX( i + 1 );
			c = index.getX( i + 2 );

			intersection = checkBufferGeometryIntersection( this.light, raycaster, _ray, position, a, b, c );

			if ( intersection ) {

				intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
				intersects.push( intersection );

			}

		}

		function checkBufferGeometryIntersection( object, raycaster, ray, position, a, b, c ) {

			var _vA = new THREE.Vector3();
			var _vB = new THREE.Vector3();
			var _vC = new THREE.Vector3();

			var point = new THREE.Vector3();
			var _intersectionPointWorld = new THREE.Vector3();

			_vA.fromBufferAttribute( position, a );
			_vB.fromBufferAttribute( position, b );
			_vC.fromBufferAttribute( position, c );

			var intersect = ray.intersectTriangle( _vA, _vB, _vC, false, point );

			if ( intersect === null ) return null;

			_intersectionPointWorld.copy( point );
			_intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) return null;

			return {
				distance: distance,
				point: _intersectionPointWorld.clone(),
				object: object
			};

		}

	}

}

SPE.DirectionalLightHelper._ray = new THREE.Ray();
SPE.DirectionalLightHelper._sphere = new THREE.Sphere();
SPE.DirectionalLightHelper._inverseMatrix = new THREE.Matrix4();
SPE.DirectionalLightHelper.geometryHelper = new THREE.BoxBufferGeometry( 30, 30, 30 );
/**
 * @author nisa
 */

'use strict';

SPE.Raycaster = class extends THREE.Raycaster {

	/**
	 * override setFromCamera. For orthograpics camera we need set ray origin on the near plane
	 * PATCH: use a fork
	 */
	setFromCamera ( coords, camera ) {

		if ( ( camera && camera.isPerspectiveCamera ) ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( ( camera && camera.isOrthographicCamera ) ) {

			// this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera ); // nisa modification: set origin in near plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type.' );

		}

	}

	/**
	 * Helper to draw the ray. It is more helpful with CameraHelper
	 */
	createRaycastLineHelper() {

		const material = new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 10 } );
		const geometry = new THREE.Geometry();
		const start = new THREE.Vector3( this.ray.origin.x, this.ray.origin.y, this.ray.origin.z );
		const end = new THREE.Vector3( this.ray.direction.x, this.ray.direction.y, this.ray.direction.z );
		const mid = new THREE.Vector3().lerpVectors( start, end, 0.5 ); // get the point in the middle

		end.multiplyScalar( 0 ); // could be any number
		
		geometry.vertices.push( start );
		geometry.vertices.push( mid );
		geometry.vertices.push( end );
	
		return new THREE.Line( geometry, material );

	  }

}
/**
 * @author nisa
 */

'use strict';

//@classname{SPE.TorusKnotGeometry}
SPE.TorusKnotGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			depth = 1,
			tube = 50,
			tubularSegments = 64,
			radialSegments = 32,
			p = 2,
			q = 3
		}
	) {

		let radius = (width * 0.5) - (tube);

		let geometry = new THREE.TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q);

		// geometry.scale(1, height / width, 1);
		geometry.userData = {
			type: "TorusKnotGeometry",
			parameters: {
				width: width,
				height: height,
				depth: depth,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			}
		};

		return geometry;

	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			depth = geometry.userData.parameters.depth,
			tube = geometry.userData.parameters.tube,
			tubularSegments = geometry.userData.parameters.tubularSegments,
			radialSegments = geometry.userData.parameters.radialSegments,
			p = geometry.userData.parameters.p,
			q = geometry.userData.parameters.q
		}
	) {

		return this.build({ width, height, depth, tube, tubularSegments, radialSegments, p, q });

	}

}/**
 * @author alejandro
 */

'use strict';

//@classname{SPE.LatheGeometry}
SPE.LatheGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			depth = width,
			segments = 64,
			verticalSegments = 64,
			points = [
				{x: 0, y: -50, id: 0},
				{x: 50, y: -50, id: 1},
				{x: 50, y: 50, id: 2},
				{x: 0, y: 50, id: 3}
			]
		}
	) {

		let shape = new THREE.Shape();

		shape.moveTo(points[0].x, points[0].y);

		shape.bezierCurveTo(
			points[1].x, points[1].y,	//CP1
			points[2].x, points[2].y,	//CP2
			points[3].x, points[3].y	//Final position
		);

		let geometry = new THREE.LatheBufferGeometry( shape.extractPoints(verticalSegments).shape, segments );

		geometry.rotateZ(Math.PI);

		geometry.userData = {
			type: "LatheGeometry",
			parameters: {
				width: width,
				height: height,
				depth: depth,
				segments: segments,
				verticalSegments: verticalSegments,
				points: points
			}
		};

		

		return geometry;
	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			depth = geometry.userData.parameters.depth,
			segments = geometry.userData.parameters.segments,
			verticalSegments = geometry.userData.parameters.verticalSegments,
			points = geometry.userData.parameters.points
		}
	) {
		return this.build({width, height, depth, segments, verticalSegments, points});
	}

}/**
 * @author sol
 */

'use strict';

//@classname{SPE.PyramidGeometry}
SPE.PyramidGeometry = new function() {

	
	this.build = function(
		{
			width = 100,
			height = width,
			depth = width,
			radialSegments = 4,
			heightSegments = 1,
			openEnded,
			cornerRadius = 0,
			cornerSegments = 8
		}
	) {
		width = Math.abs(width);
		height = Math.abs(height);
		depth = Math.abs(depth);

		let geometry = new RoundedPyramidBufferGeometry(width * 0.5, height, radialSegments, heightSegments, openEnded, cornerRadius, cornerSegments);

		// Add barycentric coordinates to the buffer-geometry to handle effects that might need this attribute
		//SPE.Geometry.Utils.addBarycentricAttribute( geometry, 'barycentric' );

		geometry.scale(1, 1, depth / width);
		geometry.userData = {
			type: "PyramidGeometry",
			parameters: {
				width: width,
				height: height,
				depth: depth,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				cornerRadius: cornerRadius,
				cornerSegments: cornerSegments
			}
		};

		return geometry;
	}
	

	this.buildFromGeometry = function(
		geometry,
		{
			width = geometry.userData.parameters.width,
			height = geometry.userData.parameters.height,
			depth = geometry.userData.parameters.depth,
			radialSegments = geometry.userData.parameters.radialSegments,
			heightSegments = geometry.userData.parameters.heightSegments,
			openEnded = geometry.userData.parameters.openEnded,
			cornerRadius = geometry.userData.parameters.cornerRadius,
			cornerSegments = geometry.userData.parameters.cornerSegments
		}
	) {
		return this.build({width, height, depth, radialSegments, heightSegments, openEnded, cornerRadius, cornerSegments});
	}

}

// take a 2d vector from side view and a unit vector from the top view
// and output the profile vector turned to the top vector into the 3d vector out
function two2three(profile, top, out) {

	out.x = profile.x * top.x;
	out.y = profile.y;
	out.z = profile.x * top.y;

}

// inset/offset point by distA from the edge to edgeEndA and distB from the edge to edgeEndB.
// store result in out
function offset3d(point, edgeEndA, edgeEndB, distA, distB, out) {

	const deltaA = edgeEndA.clone().sub(point);
	const deltaB = edgeEndB.clone().sub(point);
	const angle = deltaA.angleTo(deltaB);
	deltaA.normalize();
	deltaB.normalize();

	if (distA === distB) {

		const bisector = deltaA.add(deltaB).normalize();
		out.copy(point).addScaledVector(bisector, distA / Math.sin(angle/2));

	} else {

		const angle = deltaA.angleTo(deltaB);

		out.copy(point);
		out.addScaledVector(deltaA, distB / Math.sin(angle));
		out.addScaledVector(deltaB, distA / Math.sin(angle));

	}

}

// project point orthagonally onto line through lA, lB
function projectOntoLine( point, lA, lB ) {

	const deltaPoint = point.clone().sub(lA);
	const deltaLine = lB.clone().sub(lA);


	deltaPoint.projectOnVector(deltaLine);
	return deltaPoint.add(lA);

}

function intersectLines( startA, endA, startB, endB ) {

	const p13 = startA.clone().sub(startB);
	const p43 = endB.clone().sub(startB);
	const p21 = endA.clone().sub(startA);

	if (p43.manhattanLength() <= 3*Number.Epsilon || p21.manhattanLength() <= 3*Number.Epsilon)
		return false;

	const d1343 = p13.dot(p43);
	const d4321 = p43.dot(p21);
	const d1321 = p13.dot(p21);
	const d2121 = p21.dot(p21);
	const d4343 = p43.dot(p43);

  const denom = d2121 * d4343 - d4321 * d4321;
	if (Math.abs(denom) <= Number.Epsilon)
		return false;
	const numer = d1343 * d4321 - d1321 * d4343;

  const mua = numer / denom;
  const mub = (d1343 + d4321 * (mua)) / d4343;

	const pa = startA.clone().addScaledVector(p21, mua);
	const pb = startB.clone().addScaledVector(p43, mub);

	if (pa.distanceToSquared(pb) > Number.Epsilon)
		return false;

  return pa;

}

class RoundedPyramidBufferGeometry extends THREE.BufferGeometry {

	constructor( radius = 0.5, height = 1, radialSegments = 4, heightSegments = 1, openEnded = false, cornerRadius = 0, cornerSegments = 4 ) {

		const Vector2 = THREE.Vector2;
		const Vector3 = THREE.Vector3;

		super();

		this.type = 'RoundedPyramidBufferGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			cornerRadius: cornerRadius,
			cornerSegments: cornerSegments,
		};

		const scope = this;

		// segments

		radialSegments = Math.floor( Math.max( 3, radialSegments) );
		heightSegments = Math.floor( heightSegments );
		cornerSegments = Math.floor( cornerSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;

		const halfHeight = height / 2;

		const startAngle = Math.PI / radialSegments;

		const innerRadius = radius *  Math.cos(Math.PI / radialSegments)
		const centerAngle = 2 * Math.PI / radialSegments;
		const innerAngle = (radialSegments - 2) * Math.PI / radialSegments;
		const outerAngle = Math.PI - innerAngle;

		const bottomCenter = new Vector3(0, -halfHeight, 0);
		const topCenter = new Vector3(0,  halfHeight, 0);
		const bottomOuter = new Vector2(radius, -halfHeight);
		const bottomInner = new Vector2(innerRadius, -halfHeight);

		const deltaFace = new Vector2().copy(topCenter).sub(bottomInner);
		const deltaEdge = new Vector2().copy(topCenter).sub(bottomOuter);
		const normalFace2d = new Vector2(deltaFace.y, -deltaFace.x).normalize();
		const normalEdge2d = new Vector2(deltaEdge.y, -deltaEdge.x).normalize();

		const cornerPullBottomMax = radius * Math.cos(Math.PI / radialSegments);
		const cornerRadiusMax = cornerPullBottomMax *  Math.tan((Math.PI - deltaFace.angle()) / 2) - 1e-8;
		cornerRadius = Math.min(cornerRadius, cornerRadiusMax);

		let innerAngleSide;
		{
			const normal = new Vector3(normalFace2d.x, normalFace2d.y, 0);
			const nextNormal = new Vector3(Math.cos(centerAngle)*normal.x, normal.y, Math.sin(centerAngle)*normal.x);
			innerAngleSide = normal.angleTo(nextNormal);
		}

		const cornerPullBottom = cornerRadius / Math.tan((Math.PI - deltaFace.angle()) / 2);
		const cornerPullSide = cornerRadius / Math.tan((Math.PI - innerAngleSide) / 2);

		const vector = new Vector3();

		if (!openEnded) {

			// bottom polygon fan

			vertices.push( bottomCenter.x, bottomCenter.y, bottomCenter.z );
			normals.push( 0, -1, 0 );
			uvs.push( 0, 0);
			const center = index ++;

			const loop = [];

			const bottomOutCornered = bottomOuter.clone();
			const rad = cornerPullBottom / Math.cos(Math.PI / radialSegments);
			bottomOutCornered.x -= rad;

			for ( let i = 0; i < radialSegments; i ++ ) {

				const ia = i / radialSegments * Math.PI * 2 + startAngle;
				const top = new Vector2(Math.sin( ia ), Math.cos( ia ));

				// vertex

				two2three(bottomOutCornered, top, vector);
				vertices.push( vector.x, vector.y, vector.z );

				// normals

				normals.push( 0, -1, 0 );

				// uvs

				uvs.push( 0, 0 );

				// counter

				loop.push( index ++ );

			}

			for ( let i = 0; i < loop.length; i ++ ) {

				indices.push( loop[i], center, loop[(i+1) % loop.length] );

			}

		}

		const topLoop = [];

		{

			// side faces

			const normal = new Vector3();
			const start = new Vector3();
			const stop = new Vector3();
			const top2 = new Vector3();
			const start2 = new Vector3();
			const stop2 = new Vector3();

			for ( let i = 0; i < radialSegments; i ++ ) {

				const iaStart =       i / radialSegments * Math.PI * 2 + startAngle;
				const iaMid   = (i +.5) / radialSegments * Math.PI * 2 + startAngle;
				const iaStop  = (i + 1) / radialSegments * Math.PI * 2 + startAngle;

				const turnStart = new Vector2(Math.sin( iaStart ), Math.cos( iaStart ));
				const turnMid 	= new Vector2(Math.sin( iaMid 	), Math.cos( iaMid 	 ));
				const turnStop 	= new Vector2(Math.sin( iaStop 	), Math.cos( iaStop  ));

				// find original triangle corners and normal

				two2three(bottomOuter, turnStart, start);
				two2three(bottomOuter, turnStop, stop);
				two2three(normalFace2d, turnMid, normal);

				// offset vertices

				offset3d(topCenter, start, stop, cornerPullSide, cornerPullSide, top2);
				vertices.push( top2.x, top2.y, top2.z );
				offset3d(start, topCenter, stop, cornerPullSide, cornerPullBottom, start2);
				vertices.push( start2.x, start2.y, start2.z );
				offset3d(stop, start, topCenter, cornerPullBottom, cornerPullSide, stop2);
				vertices.push( stop2.x, stop2.y, stop2.z );

				// normals

				normals.push( normal.x, normal.y, normal.z );
				normals.push( normal.x, normal.y, normal.z );
				normals.push( normal.x, normal.y, normal.z );

				// uvs

				uvs.push( 0, 0 );
				uvs.push( 0, 0 );
				uvs.push( 0, 0 );

				// counter

				const iTop = index ++;
				const iStart = index ++;
				const iStop = index ++;
				indices.push( iTop, iStart, iStop );

				if ( cornerRadius > 0 ) {

					{

						// bottom bevel

						const center = start.clone().add(stop).multiplyScalar(0.5);
						const toTop = topCenter.clone().sub(center).normalize();
						const toBottom = bottomCenter.clone().sub(center).normalize();
						const out = toBottom.add(toTop).normalize().multiplyScalar(-1);
						const across = stop2.clone().sub(start2);

						buildBevel( center, across, out, deltaFace.angle() );

					}

					let bevelEnd, clampedIndices;

					{

						// side bevel

						const out = new Vector3();
						two2three(normalEdge2d, turnStop, out);

						let center = stop2.clone().add(top2).multiplyScalar(0.5);
						center = projectOntoLine(center, stop, topCenter);
						const across = stop2.clone().sub(top2);

						[ bevelEnd, clampedIndices ] = buildBevel( center, across, out, innerAngleSide, top2.y );

					}

					{

						// side corner

						const center = bevelEnd;

						const u = center.clone().setY(0).normalize(); // outwards from the corner
						const v = new Vector3(0, -1, 0);							// downwards
						const w = u.clone().cross(v);									// cross the last

						buildCorner3( center, u, v, w );

					}

					topLoop.concat(clampedIndices);

				{

					// top half-sphere segment

					const angleStart = deltaFace.angle();
					const angleDelta = Math.PI - angleStart;
					const center = topCenter.clone();
					center.y -= cornerRadius / Math.sin(angleStart - Math.PI/2);

					const delta = new Vector3();
					const vector = new Vector3();
					const rows = [];

					for ( let segments = 0; segments < cornerSegments; segments ++ ) {

						const row = [];

		  			const anglePitch = Math.PI / 2 - angleDelta * segments / cornerSegments;
						const cosPitch = Math.cos(anglePitch);
						const sinPitch = Math.sin(anglePitch);

						let angleYaw = iaMid;

						for ( var j = 0; j <= segments; j ++ ) {

								const cosYaw = Math.cos(angleYaw);
								const sinYaw = Math.sin(angleYaw);

								normal.x = cosPitch * sinYaw;
								normal.y = sinPitch;
								normal.z = cosPitch * cosYaw;
								vector.copy(center).addScaledVector(normal, cornerRadius);

								// vertex

								vertices.push( vector.x, vector.y, vector.z );
								normals.push( normal.x, normal.y, normal.z);
								uvs.push( 0, 0 );

								// index

								row.push( index++ );

			  				angleYaw += Math.PI * 2 / segments / radialSegments;

							}

							rows.push( row );

						}

						clampedIndices.reverse();
						rows.push( clampedIndices );

						const R = rows.length - 1;

						for ( let r = 0; r < R; r ++ ) {

							// rows: cur/next
							const rC = rows[r];
							const rN = rows[r+1];

							const I = rC.length - 1;

							// first tri
							indices.push( rN[1], rC[0], rN[0] );

							for ( let i = 1; i <= I; i ++ ) {

								// tri to previous
								indices.push( rC[i], rC[i-1], rN[i] );

								// tri to next
								indices.push( rN[i+1], rC[i], rN[i] );

							}

						}

					}

				}

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );

		/*
     * bevel an edge between the two points at center ± across
		 * the centerline of the bevel-cylinder is recessed by cornerRadius in the
		 * direction of -out.
		 * angleDelta is the total angle between the two faces adjacent to the edge.
		 * clampYMax is an optional absolute Y value defining a plane above which to
		 * clamp all vertices. This is a special feature only used for the top of
		 * the pyramid.
		 */
		function buildBevel( center, across, out, angleDelta, clampYMax ) {

			const angleStart = -angleDelta / 2;
			const aspectAngle2 = (Math.PI - angleDelta) / 2;

			const up  = across.clone().normalize().cross(out);
			center.addScaledVector(out, -cornerRadius / Math.sin(aspectAngle2));

			const vector = new Vector3();
			const normal = new Vector3();

			const acrossSegments = 1;
			const startIndex = index;
			const clampedVerts = [];

			for ( let ia = 0; ia <= cornerSegments; ia++ ) {

					const a = angleStart + ia / cornerSegments * angleDelta;

					normal.set(0, 0, 0);
					normal.addScaledVector(up,  Math.sin(a));
					normal.addScaledVector(out, Math.cos(a));

					for ( let is = 0; is <= acrossSegments; is ++ ) {

						const i = is / acrossSegments - 0.5;

						vector.copy(center);
						vector.addScaledVector(across, i);
						vector.addScaledVector(normal, cornerRadius);

						if ( clampYMax != null ) {

								const clampAmt = Math.max(0, vector.y - clampYMax);
								vector.addScaledVector(across, -clampAmt / across.y);

						}

						// vertex

						vertices.push( vector.x, vector.y, vector.z );

						normals.push( normal.x, normal.y, normal.z );

						uvs.push( 0, 0 );

						// counters

						if (is === 0)
							clampedVerts.push(index);

						index ++;

					}

			}

			for ( let ia = 0; ia < cornerSegments; ia ++ ) {

				for ( let is = 0; is < acrossSegments; is ++ ) {

					const a = startIndex + is + (acrossSegments+1) * ia;
					const b = a + (acrossSegments+1);
					const c = b + 1;
					const d = a + 1;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			return [
				center.clone().addScaledVector(across, 0.5),
				clampedVerts
			];

		}

		function buildCorner3( center, u, v, w ) {

			const pi2 = Math.PI / 2;
			const targetPitch = deltaEdge.angle() - pi2;
			const rows = [];

			const normal = new Vector3();
			const vector = new Vector3();

			for ( let segments = 0; segments <= cornerSegments; segments ++ ) {

				// close corner up to the lower two bevels

				const row = [];

				const ss = segments / cornerSegments;

				for ( var j = 0; j <= segments; j ++ ) {

					const jj = segments ? j / segments : 0;

					const angleYaw = (jj - .5) * outerAngle;
					const cosYaw = Math.cos(angleYaw);
					const sinYaw = Math.sin(angleYaw);

					const maxPitch = Math.atan(Math.tan(targetPitch) * cosYaw);
					const anglePitch = (pi2 + maxPitch)*ss;

					const cosPitch = Math.cos(anglePitch);
					const sinPitch = Math.sin(anglePitch);

					// vertex

					normal.set(0, 0, 0);
					normal.addScaledVector(u, sinPitch * cosYaw);
					normal.addScaledVector(v, cosPitch);
					normal.addScaledVector(w, sinPitch * sinYaw);

					vector.copy(center).addScaledVector(normal, cornerRadius);
					vertices.push( vector.x, vector.y, vector.z );

					// normals

					normals.push( normal.x, normal.y, normal.z);

					// uvs

					uvs.push( 0, 0 );

					// index

					row.push( index++ );

				}

				rows.push( row );

			}

			const R = rows.length - 1;

			for ( let r = 0; r < R; r ++ ) {

				// rows: cur/next
				const rC = rows[r];
				const rN = rows[r+1];

				const I = rC.length - 1;

				// first tri
				indices.push( rC[0], rN[1], rN[0] );

				for ( let i = 1; i <= I; i ++ ) {

					// tri to previous
					indices.push( rC[i-1], rC[i], rN[i] );

					// tri to next
					indices.push( rC[i], rN[i+1], rN[i] );

				}

			}

		}

	}

}
/**
 * @author nisa
 * 
 * reference: 
 * {@link https://github.com/mrdoob/three.js/issues/11967}
 */

'use strict';



SPE.Box3 = function(min, max) {
	THREE.Box3.call(this, min, max);
	
	this.transform = new THREE.Matrix4();

};
SPE.Box3.prototype = Object.create(THREE.Box3.prototype);
SPE.Box3.prototype.constructor = SPE.Box3;

///

SPE.Box3.prototype.setFromObjectSize = function ( object, recursive ) {
	// reference: https://github.com/mrdoob/three.js/issues/11967

	object.updateWorldMatrix( false, false );

	this.makeEmpty();
	this.transform = object.matrixWorld; // nisa: hack - we should use a clone of matrixWorld to keep the same box3 when this function is called, but we would need call this function everytime the object.matrixWorld changes
	let inverseTransform = new THREE.Matrix4().getInverse(object.matrixWorld);

	return this.expandByObjectSize( object, inverseTransform, recursive );
}

SPE.Box3.prototype.expandByObjectSize = function() {
	
	var scope;

	// let _position = new THREE.Vector3();
	// let _quaternion = new THREE.Quaternion();
	// let _scale = new THREE.Vector3();
	// let _matrix4 = new THREE.Matrix4();

	var _transform;
	var halfSize = new THREE.Vector3();
	var matrix = new THREE.Matrix4();
	var vertices;
	const box3 = new THREE.Box3();	
	const center = new THREE.Vector3();
	var enableHelper;
	
	function traverse( node ) {

		if ( node.geometry !== undefined ) {

			const parameters = node.geometry.userData.parameters;
			
			box3.setFromArray(node.geometry.getAttribute( 'position' ).array);
			box3.getCenter(center);
			halfSize.set(parameters.width, parameters.height, parameters.depth).multiplyScalar(0.5);

		} else if ( node.geometryHelper !== undefined && enableHelper === true ) {

			box3.setFromArray(node.geometryHelper.getAttribute( 'position' ).array);
			box3.getCenter(center);
			box3.getSize(halfSize).multiplyScalar(0.5);

		} else {

			center.setScalar( 0 );
			halfSize.setScalar( 0 );

		}

		matrix.copy(_transform).multiply(node.matrixWorld);

		node.userData.positionToCenter = center;
		
		if ( halfSize.x === 0 && halfSize.y === 0 && halfSize.z === 0 ) {

			vertices.push( new THREE.Vector3(center.x, center.y, center.z).applyMatrix4(matrix) );

		} else {

			/* vertices
				 4____7
				0/___3/|
				| 5__|_6
				1/___2/
			*/
			vertices.push(
				new THREE.Vector3(-halfSize.x, halfSize.y, halfSize.z).add(center).applyMatrix4(matrix),
				new THREE.Vector3(-halfSize.x, -halfSize.y, halfSize.z).add(center).applyMatrix4(matrix),
				new THREE.Vector3(halfSize.x, -halfSize.y, halfSize.z).add(center).applyMatrix4(matrix),
				new THREE.Vector3(halfSize.x, halfSize.y, halfSize.z).add(center).applyMatrix4(matrix),
				new THREE.Vector3(-halfSize.x, halfSize.y, -halfSize.z).add(center).applyMatrix4(matrix),
				new THREE.Vector3(-halfSize.x, -halfSize.y, -halfSize.z).add(center).applyMatrix4(matrix),
				new THREE.Vector3(halfSize.x, -halfSize.y, -halfSize.z).add(center).applyMatrix4(matrix),
				new THREE.Vector3(halfSize.x, halfSize.y, -halfSize.z).add(center).applyMatrix4(matrix)
			);

		}

	}

	return function expandByObjectSize( object, transform, recursive ) {

		scope = this;

		_transform = transform;
		enableHelper = object.enableHelper;
		vertices = [];
		
		if ( recursive === true ) {
		
			object.traverseEntity(traverse);
			this.setFromPoints(vertices);
		
		} else {
			
			traverse(object);
			this.setFromPoints(vertices);
			
		}	

		return this;

	};
}();

SPE.Box3.prototype.getCenter = function(target){
	target = THREE.Box3.prototype.getCenter.call(this, target);
	target.applyMatrix4(this.transform);
	return target;
}

///

SPE.Box3.prototype.setFromObject = function ( object, transform ) {
	// reference: https://github.com/mrdoob/three.js/issues/11967

	this.makeEmpty();

	return this.expandByObject( object, transform );
}

SPE.Box3.prototype.expandByObject = function() {
	// reference: https://github.com/mrdoob/three.js/issues/11967

	var scope, i, l;

	var v1 = new THREE.Vector3();

	var _transform;

	function traverse( node ) {
		
		var geometry = node.geometry;

		if ( geometry !== undefined ) {

			if ( geometry.isGeometry ) {

				var vertices = geometry.vertices;

				for ( i = 0, l = vertices.length; i < l; i ++ ) {

					v1.copy( vertices[ i ] );
					v1.applyMatrix4( node.matrixWorld );

					if (_transform !== undefined) { v1.applyMatrix4(_transform); }

					scope.expandByPoint( v1 );

				}

			} else if ( geometry.isBufferGeometry ) {

				var attribute = geometry.attributes.position;

				if ( attribute !== undefined ) {

					for ( i = 0, l = attribute.count; i < l; i ++ ) {

						v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

						if (_transform !== undefined) { v1.applyMatrix4(_transform); }

						scope.expandByPoint( v1 );

					}

				}

			}

		}

	}

	return function expandByObject( object, transform ) {

		scope = this;

		object.updateMatrixWorld( true );

		_transform = transform;
		
		object.traverse( traverse );

		return this;

	};
}();

///

SPE.Box3.prototype.computeVertices = function() {
	var size = this.getSize(new THREE.Vector3());
	let halfSize = size.multiplyScalar(0.5);
	var center = this.getCenter(new THREE.Vector3());
	var matrix = new THREE.Matrix4().copy(this.transform).setPosition(center);
	
	/* vertices
		  4____7
		0/___3/|
		| 5__|_6
		1/___2/
	*/

	this.vertices = [
		new THREE.Vector3(-halfSize.x, halfSize.y, halfSize.z).applyMatrix4(matrix),
		new THREE.Vector3(-halfSize.x, -halfSize.y, halfSize.z).applyMatrix4(matrix),
		new THREE.Vector3(halfSize.x, -halfSize.y, halfSize.z).applyMatrix4(matrix),
		new THREE.Vector3(halfSize.x, halfSize.y, halfSize.z).applyMatrix4(matrix),
		new THREE.Vector3(-halfSize.x, halfSize.y, -halfSize.z).applyMatrix4(matrix),
		new THREE.Vector3(-halfSize.x, -halfSize.y, -halfSize.z).applyMatrix4(matrix),
		new THREE.Vector3(halfSize.x, -halfSize.y, -halfSize.z).applyMatrix4(matrix),
		new THREE.Vector3(halfSize.x, halfSize.y, -halfSize.z).applyMatrix4(matrix)
	];
} 

SPE.Box3.prototype.computeEdges = function() {

	if (!this.vertices) {
		this.computeVertices();
	}

	/* vertices and edges
		  4____7		   __3_        ____        ____
		0/___3/|		 /__0 /|     /___ /|    8/___11|
		| 5__|_6		| |_2|_|    4 7__5_6    | |__|_|
		1/___2/		    |/_1_|/     |/___|/     |9___|10
	*/
	this.edges = [
		new THREE.Line3().set(this.vertices[0], this.vertices[3]), 
		new THREE.Line3().set(this.vertices[1], this.vertices[2]),
		new THREE.Line3().set(this.vertices[5], this.vertices[6]), 
		new THREE.Line3().set(this.vertices[4], this.vertices[7]),
		new THREE.Line3().set(this.vertices[0], this.vertices[1]), 
		new THREE.Line3().set(this.vertices[3], this.vertices[2]), 
		new THREE.Line3().set(this.vertices[7], this.vertices[6]), 
		new THREE.Line3().set(this.vertices[4], this.vertices[5]),
		new THREE.Line3().set(this.vertices[0], this.vertices[4]), 
		new THREE.Line3().set(this.vertices[1], this.vertices[5]), 
		new THREE.Line3().set(this.vertices[2], this.vertices[6]), 
		new THREE.Line3().set(this.vertices[3], this.vertices[7])
	];
}

SPE.Box3.prototype.computeFaces = function() {
	
	if (!this.vertices) {
		this.computeVertices();
	}
	
	/* vertices
		  4____7
		0/___3/|
		| 5__|_6
		1/___2/
	*/

	this.faces = [
		new THREE.Vector3().copy( this.vertices[ 0 ] ).sub( this.vertices[ 2 ] ).multiplyScalar( 0.5 ).add( this.vertices[ 2 ] ),
		new THREE.Vector3().copy( this.vertices[ 3 ] ).sub( this.vertices[ 6 ] ).multiplyScalar( 0.5 ).add( this.vertices[ 6 ] ),
		new THREE.Vector3().copy( this.vertices[ 7 ] ).sub( this.vertices[ 5 ] ).multiplyScalar( 0.5 ).add( this.vertices[ 5 ] ),
		new THREE.Vector3().copy( this.vertices[ 4 ] ).sub( this.vertices[ 1 ] ).multiplyScalar( 0.5 ).add( this.vertices[ 1 ] ),
		new THREE.Vector3().copy( this.vertices[ 0 ] ).sub( this.vertices[ 7 ] ).multiplyScalar( 0.5 ).add( this.vertices[ 7 ] ),
		new THREE.Vector3().copy( this.vertices[ 1 ] ).sub( this.vertices[ 6 ] ).multiplyScalar( 0.5 ).add( this.vertices[ 6 ] )
	];
} 
/**
 * @author nisa, alejandro
 */

//@classname{SPE.Math}
SPE.Math = class {

	/**
	 * Use this instead THREE.Quaternion.slerp if you need deg > 180 || deg < -180
	 */
	static slerp( qa, qb, qm, t ) {

		if ( t === 0 ) { return qm.copy( qa ); }
		if ( t === 1 ) { return qm.copy( qb ); }

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = qa.w * qb.w + qa.x * qb.x + qa.y * qb.y + qa.z * qb.z;

		if ( cosHalfTheta >= 1.0 ) {

			return qm.copy( qa );

		}

		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) { 

			var s = 1 - t;
			qm.w = s * qa.w + t * qb.w;
			qm.x = s * qa.x + t * qb.x;
			qm.y = s * qa.y + t * qb.y;
			qm.z = s * qa.z + t * qb.z;

			qm.normalize();

			return qm;

		}

		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		qm.w = ( qa.w * ratioA + qb.w * ratioB );
		qm.x = ( qa.x * ratioA + qb.x * ratioB );
		qm.y = ( qa.y * ratioA + qb.y * ratioB );
		qm.z = ( qa.z * ratioA + qb.z * ratioB );

		return qm;

	}

	/**
	 *  reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
	 * @param {int } min - inclusive
	 * @param {int} max - exclusive
	 */
	static getRandomInt( min, max ) {

		min = Math.ceil( min );
		max = Math.floor( max );
		return Math.floor( Math.random() * ( max - min ) + min ); //The maximum is exclusive and the minimum is inclusive

	}

	/*
	get projection U into V where 
	U = a - b		b -> a
	V = c - b		b -> c
	reference: http://web.ma.utexas.edu/users/kit/Precalculus/Section_9.2-The%20Dot%20Product/The%20Dot%20Product.pdf
	*/
	static getProjection(a, b, c) {
		let uVector = a.clone().sub(b);
		let vVector = c.clone().sub(b);
		let vDistance = b.distanceTo(c);
		return uVector.dot(vVector) / vDistance;
	}

	static projectOnVector(uVector, vVector) {
		//let uVector = a.clone().sub(b);
		//let vVector = c.clone().sub(b);
		//let vDistance = b.distanceTo(c);
		return uVector.clone().dot(vVector) / vVector.length();
	}

	static angle2D(centerX, centerY, radiusX, radiusY, complete = false) {
		let dx = radiusX - centerX;
		let dy = radiusY - centerY;
		let theta = Math.atan2(dy, dx); // range (-PI, PI]
		theta *= 180 / Math.PI; // rads to degs, range (-180, 180]
		if (complete && theta < 0) theta = 360 + theta; // range [0, 360)
		return theta;
	}

	static angle3D(a, b, c) {
		let baVector = a.clone().sub(b);
		let bcVector = c.clone().sub(b);
		let baDistance = b.distanceTo(a);
		let bcDistance = b.distanceTo(c);

		let theta = baVector.dot(bcVector) / (baDistance * bcDistance);
		return Math.acos(theta);
	}

	/* 
	theta: float in radians
	*/
	static rotatePosition2D(x, y, theta) {
		return {
			x: x * Math.cos(theta) - y * Math.sin(theta),
			y: x * Math.sin(theta) + y * Math.cos(theta),
			z: 0
		};
	}

	/* 
	theta: vector3 in radians
	*/
	static rotatePosition3D(position, theta) {
		return position
			.clone()
			.applyMatrix3(SPE.Math.getRotateMatrix(theta.x, theta.y, theta.z));
	}

	/* 
	NOTE: i think we can use new THREE.Matrix4().makeRotationY(0.005);
	reference:
	https://stackoverflow.com/questions/4642687/given-start-point-angles-in-each-rotational-axis-and-a-direction-calculate-end		https://stackoverflow.com/questions/34050929/3d-point-rotation-algorithm/34060479
		
	angleX, angleY, angleZ: float in radians
	*/
	static getRotateMatrix(angleX, angleY, angleZ) {
		let rx = new THREE.Matrix3();
		let ry = new THREE.Matrix3();
		let rz = new THREE.Matrix3();

		rx.set(
			1,
			0,
			0,
			0,
			Math.cos(angleX),
			-Math.sin(angleX),
			0,
			Math.sin(angleX),
			Math.cos(angleX)
		);

		ry.set(
			Math.cos(angleY),
			0,
			Math.sin(angleY),
			0,
			1,
			0,
			-Math.sin(angleY),
			0,
			Math.cos(angleY)
		);

		rz.set(
			Math.cos(angleZ),
			-Math.sin(angleZ),
			0,
			Math.sin(angleZ),
			Math.cos(angleZ),
			0,
			0,
			0,
			1
		);
		return rx.multiply(ry).multiply(rz);
	}

	// Alejandro: I merged my math utils on this SPE.Math class, so the code below came from the old math utils js.

	// Handles precise rounding of numbers with custom decimal places (better than Math.round)
	static round(number, precision) {
		let pair = (number + "e").split("e");
		let value = Math.round(pair[0] + "e" + (+pair[1] + precision));
		pair = (value + "e").split("e");
		return +(pair[0] + "e" + (+pair[1] - precision));
	}

	static normalize(value, min, max) {
		return (value - min) / (max - min);
	}

	static lerp(norm, min, max) {
		return (max - min) * norm + min;
	}

	static map(value, sourceMin, sourceMax, destMin, destMax) {
		return SPE.Math.lerp(SPE.Math.normalize(value, sourceMin, sourceMax), destMin, destMax);
	}

	static clamp(value, min, max) {
		return Math.min(Math.max(value, min), max);
	}

	static getMiddlePointByPerc(pointA, pointB, percentage) {
		let dir = pointB.clone().sub(pointA);
		let len = dir.length();
		dir = dir.normalize().multiplyScalar(len * percentage);
		return pointA.clone().add(dir);
	}

	static getVectorDistanceInFloat(v1, v2) {
		let dx = v1.x - v2.x;
		let dy = v1.y - v2.y;
		let dz = v1.z - v2.z;

		return Math.sqrt(dx * dx + dy * dy + dz * dz);
	}

	static getVectorDistanceInVector(v1, v2) {
		let dx = v1.x - v2.x;
		let dy = v1.y - v2.y;
		let dz = v1.z - v2.z;

		return new THREE.Vector3(dx, dy, dz);
	}

	static getObjectSize(object) {
		let size = new THREE.Vector3();
		object.geometry.computeBoundingBox();
		size.x =
			object.geometry.boundingBox.max.x - object.geometry.boundingBox.min.x;
		size.y =
			object.geometry.boundingBox.max.y - object.geometry.boundingBox.min.y;
		size.z =
			object.geometry.boundingBox.max.z - object.geometry.boundingBox.min.z;

		return size;
	}

	// Handles transform reset
	static resetTransform(transform, array) {
		for (let i = 0; i < array.length; i++) {
			if (transform == "all") {
				array[i].position.set(0, 0, 0);
				array[i].scale.set(1, 1, 1);
				array[i].rotation.set(0, 0, 0);
			} else if (transform == "scale") {
				array[i].scale.set(1, 1, 1);
			} else {
				array[i].rotation.set(0, 0, 0);
			}

			if (array[i].geometry) {
				array[i].geometry.computeBoundingBox();
			}
		}
	}

	static containsObject(obj, list) {
		for (let i = 0; i < list.length; i++) {
			if (list[i] === obj) {
				return true;
			}
		}

		return false;
	}

	// Find the centroid of selected elements for later alignment features and return the vector 3

	static findCentroid(array) {
		let centroid = new THREE.Vector3();
		let numPoints = array.length;

		for (let i = 0; i < array.length; i++) {
			centroid.set(
				centroid.x + array[i].position.x,
				centroid.y + array[i].position.y,
				centroid.z + array[i].position.z
			);
		}

		centroid.set(
			centroid.x / numPoints,
			centroid.y / numPoints,
			centroid.z / numPoints
		);

		return centroid;
	}

	// Function that handles removing from array

	static removeFromArray(array, element) {
		const index = array.indexOf(element);
		array.splice(index, 1);
	}

	static getPositionRelativeToElement(evt) {
		let rect = evt.target.getBoundingClientRect();

		return {
			mx: evt.clientX - rect.left,
			my: evt.clientY - rect.top
		};
	}

	static getElementMousePos(element, event) {
		let elemMousePos = {
			mx: event.pageX - element.offset().left,
			my: event.pageY - element.offset().top
		};

		return elemMousePos;
	}

	static changeColor(line, options) {
		let colors = line.geometry.attributes.color.array;
		let segments = line.geometry.attributes.color.count * 3;
		let frequency = 1 / (options.steps * segments);
		let color = new THREE.Color();

		for (let i = 0, l = segments; i < l; i++) {
			color.set(makeColorGradient(i, frequency, options.phase));

			colors[i * 3] = color.r;
			colors[i * 3 + 1] = color.g;
			colors[i * 3 + 2] = color.b;
		}

		line.geometry.attributes["color"].needsUpdate = true;
	}

	// Create colored line using buffer geometry. Alejandro: I believe initial function code was from threejs source.
	static getColoredBufferLine(steps, phase, geometry) {
		let vertices = geometry.vertices;
		let segments = geometry.vertices.length;

		let newGeometry = new THREE.BufferGeometry();
		let lineMaterial = new THREE.LineBasicMaterial({
			vertexColors: THREE.VertexColors
		});

		let positions = new Float32Array(segments * 3); // 3 vertices per point
		let colors = new Float32Array(segments * 3);

		let frequency = 1 / (steps * segments);
		let color = new THREE.Color();

		let x, y, z;

		for (let i = 0, l = segments; i < l; i++) {
			x = vertices[i].x;
			y = vertices[i].y;
			z = vertices[i].z;

			positions[i * 3] = x;
			positions[i * 3 + 1] = y;
			positions[i * 3 + 2] = z;

			color.set(makeColorGradient(i, frequency, phase));

			colors[i * 3] = color.r;
			colors[i * 3 + 1] = color.g;
			colors[i * 3 + 2] = color.b;
		}

		newGeometry.setAttribute(
			"position",
			new THREE.BufferAttribute(positions, 3)
		);
		newGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

		let line = new THREE.Line(newGeometry, lineMaterial);

		return line;
	}

	/* COLORS */
	static makeColorGradient(i, frequency, phase) {
		let center = 128;
		let width = 127;

		let redFrequency, grnFrequency, bluFrequency;
		grnFrequency = bluFrequency = redFrequency = frequency;

		let phase2 = phase + 2;
		let phase3 = phase + 4;

		let red = Math.sin(redFrequency * i + phase) * width + center;
		let green = Math.sin(grnFrequency * i + phase2) * width + center;
		let blue = Math.sin(bluFrequency * i + phase3) * width + center;

		return parseInt("0x" + _byte2Hex(red) + _byte2Hex(green) + _byte2Hex(blue));
	}

	static _byte2Hex(n) {
		let nybHexString = "0123456789ABCDEF";
		return (
			String(nybHexString.substr((n >> 4) & 0x0f, 1)) +
			nybHexString.substr(n & 0x0f, 1)
		);
	}

	// Function to draw bezier tangents. TODO: probably need to delete/change this in the future.
	static drawBezierTangent(point1, point2) {
		let curve = new THREE.LineCurve3(point1, point2);
		let points = curve.getPoints(1);
		let geometry = new THREE.BufferGeometry().setFromPoints(points);
		let line = new THREE.Line(
			geometry,
			new THREE.LineBasicMaterial({ color: 0xff0000 })
		);
		return line;
	}

	
	static fixUvs(geometry, width, height) {
		for (let i = 0; i < geometry.attributes.uv.array.length; i += 2) {
			geometry.attributes.uv.array[i] =
				(geometry.attributes.uv.array[i] + width / 2) / width;
			geometry.attributes.uv.array[i + 1] =
				1 - ((geometry.attributes.uv.array[i + 1] - height / 2) / height) * -1;
		}
	}
	

	// static parseBool(value) { // nisa: we don't need this because Property.Radio was improved
	// 	if (value == "true") {
	// 		return true;
	// 	} else if (value == "false") {
	// 		return false;
	// 	}
	// }

	// static parseStringFromBool(value) { // nisa: we don't need this because Property.Radio was improved
	// 	if (value == true) {
	// 		return "true";
	// 	} else if (value == false) {
	// 		return "false";
	// 	}
	// }

	static flattenArray(array) {
		array = [].concat.apply([], array);
		return array;
	}

	static sortNumber(a,b){
		return a - b;
	}

	static swapArrayValues(array, a, b) {
		let temp = array[a];
		array[a] = array[b];
		array[b] = temp;
	}
};
